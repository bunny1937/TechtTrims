This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.gitignore
eslint.config.mjs
jsconfig.json
next.config.js
next.config.mjs
package.json
postcss.config.mjs
public/file.svg
public/globe.svg
public/next.svg
public/vercel.svg
public/window.svg
README.md
src/components/Admin/AdminLayout.js
src/components/Admin/SalonDetailsModal.js
src/components/Admin/StatsCards.js
src/components/Admin/UserDetailsModal.js
src/components/Background.js
src/components/Background.module.css
src/components/FullBG.js
src/components/Layout/Layout.js
src/components/Maps/LocationMap.js
src/components/Maps/LocationPicker.js
src/components/Maps/SalonMap.js
src/components/NetworkStatus.js
src/components/OnBoardingLogout.js
src/components/OwnerSidebar.js
src/components/RetryButton.js
src/components/Salon/ReviewSection.js
src/components/Salon/SalonCard.js
src/components/Salon/SalonDashboard.js
src/components/Salon/SalonRegisterForm.js
src/components/TextMorph.jsx
src/hooks/useNetworkStatus.js
src/lib/adminAuth.js
src/lib/auth.js
src/lib/config.js
src/lib/constants.js
src/lib/fetchWithRetry.js
src/lib/maps.js
src/lib/middleware/requireRole.js
src/lib/mongodb.js
src/lib/qrcode.js
src/lib/rateLimit.js
src/lib/resetToken.js
src/lib/statsHelper.js
src/lib/userData.js
src/lib/utils.js
src/lib/validators.js
src/lib/walkinHelpers.js
src/models/Barber.js
src/models/Booking.js
src/models/Feedback.js
src/models/Salon.js
src/models/Service.js
src/models/Staff.js
src/models/User.js
src/models/WalkinBooking.js
src/pages/_app.js
src/pages/admin/analytics.js
src/pages/admin/dashboard.js
src/pages/admin/login.js
src/pages/admin/reports.js
src/pages/admin/revenue.js
src/pages/admin/salons.js
src/pages/admin/users.js
src/pages/api/admin/analytics/index.js
src/pages/api/admin/dashboard/stats.js
src/pages/api/admin/reports/generate.js
src/pages/api/admin/revenue/index.js
src/pages/api/admin/salons/[id]/barbers.js
src/pages/api/admin/salons/[id]/bookings.js
src/pages/api/admin/salons/[id]/reviews.js
src/pages/api/admin/salons/[id]/toggle-status.js
src/pages/api/admin/salons/index.js
src/pages/api/admin/users/[id]/bookings.js
src/pages/api/admin/users/index.js
src/pages/api/auth/admin/login.js
src/pages/api/auth/forgot-password.js
src/pages/api/auth/reset-password.js
src/pages/api/auth/salon/login.js
src/pages/api/auth/salon/register.js
src/pages/api/auth/send-otp.js
src/pages/api/auth/user/login.js
src/pages/api/auth/user/register.js
src/pages/api/auth/verify-otp.js
src/pages/api/barber/service-control.js
src/pages/api/barber/update-status.js
src/pages/api/bookings.js
src/pages/api/bookings/[id].js
src/pages/api/bookings/create.js
src/pages/api/bookings/status/[id].js
src/pages/api/bookings/update-status.js
src/pages/api/bookings/update.js
src/pages/api/maps/geocode.js
src/pages/api/maps/reverse.js
src/pages/api/ping.js
src/pages/api/salon/notifications.js
src/pages/api/salons/[id].js
src/pages/api/salons/[id]/reviews-detailed.js
src/pages/api/salons/barbers/[id].js
src/pages/api/salons/barbers/available.js
src/pages/api/salons/barbers/index.js
src/pages/api/salons/bookings.js
src/pages/api/salons/bookings/[id].js
src/pages/api/salons/bookings/today.js
src/pages/api/salons/bookings/update-status.js
src/pages/api/salons/index.js
src/pages/api/salons/nearby.js
src/pages/api/salons/profile.js
src/pages/api/salons/services/[id].js
src/pages/api/salons/services/index.js
src/pages/api/salons/staff/[id].js
src/pages/api/salons/staff/index.js
src/pages/api/user/bookings.js
src/pages/api/user/payments.js
src/pages/api/user/profile.js
src/pages/api/user/register.js
src/pages/api/user/sync-booking-history.js
src/pages/api/walkin/booking/[id].js
src/pages/api/walkin/create-booking.js
src/pages/api/walkin/salon-state.js
src/pages/api/walkin/verify-arrival.js
src/pages/auth/reset-password.js
src/pages/auth/salon/login.js
src/pages/auth/salon/register.js
src/pages/auth/user/login.js
src/pages/auth/user/register.js
src/pages/booking/confirmed.js
src/pages/feedback.js
src/pages/index.js
src/pages/onboarding.js
src/pages/salons/[id].js
src/pages/salons/barbers/index.js
src/pages/salons/book.js
src/pages/salons/bookings/[id].js
src/pages/salons/bookings/index.js
src/pages/salons/dashboard.js
src/pages/salons/profile.js
src/pages/salons/register.js
src/pages/salons/services/[id].js
src/pages/salons/services/index.js
src/pages/salons/staff/[id].js
src/pages/salons/staff/index.js
src/pages/styles/globals.css
src/pages/styles/Home.module.css
src/pages/styles/Onboarding.module.css
src/pages/styles/Owner.module.css
src/pages/user/dashboard.js
src/pages/walkin/barber-select.js
src/pages/walkin/booking-form.js
src/pages/walkin/confirmation.js
src/pages/walkin/salon-select.js
src/styles/Admin/AdminAnalytics.module.css
src/styles/Admin/AdminDashboard.module.css
src/styles/Admin/AdminLayout.module.css
src/styles/Admin/AdminLogin.module.css
src/styles/Admin/AdminModal.module.css
src/styles/Admin/AdminReports.module.css
src/styles/Admin/AdminRevenue.module.css
src/styles/Admin/AdminSalons.module.css
src/styles/Admin/AdminStatsCards.module.css
src/styles/Admin/AdminUsers.module.css
src/styles/Auth.module.css
src/styles/Auth/SalonAuth.module.css
src/styles/Auth/UserAuth.module.css
src/styles/Booking.module.css
src/styles/BookingConfirmed.module.css
src/styles/Feedback.module.css
src/styles/globals.css
src/styles/Home.module.css
src/styles/Onboarding.module.css
src/styles/Owner.module.css
src/styles/OwnerSidebar.module.css
src/styles/ReviewsSection.module.css
src/styles/SalonDashboard.module.css
src/styles/SalonDetail.module.css
src/styles/SalonDetails.module.css
src/styles/SalonMap.module.css
src/styles/SalonRegister.module.css
src/styles/User.module.css
src/styles/WalkinBarberSelect.module.css
src/styles/WalkinConfirmation.module.css
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".gitignore">
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.*
.yarn/*
!.yarn/patches
!.yarn/plugins
!.yarn/releases
!.yarn/versions

# testing
/coverage

# next.js
/.next/
/out/

# production
/build

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*
.pnpm-debug.log*

# env files (can opt-in for committing if needed)
.env*

# vercel
.vercel

# typescript
*.tsbuildinfo
next-env.d.ts
</file>

<file path="eslint.config.mjs">
import { dirname } from "path";
import { fileURLToPath } from "url";
import { FlatCompat } from "@eslint/eslintrc";

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

const compat = new FlatCompat({
  baseDirectory: __dirname,
});

const eslintConfig = [
  ...compat.extends("next/core-web-vitals"),
  {
    ignores: [
      "node_modules/**",
      ".next/**",
      "out/**",
      "build/**",
      "next-env.d.ts",
    ],
  },
];

export default eslintConfig;
</file>

<file path="jsconfig.json">
{
  "compilerOptions": {
    "paths": {
      "@/*": ["./src/*"]
    }
  }
}
</file>

<file path="next.config.mjs">
/** @type {import('next').NextConfig} */
const nextConfig = {};

export default nextConfig;
</file>

<file path="postcss.config.mjs">
const config = {
  plugins: ["@tailwindcss/postcss"],
};

export default config;
</file>

<file path="public/file.svg">
<svg fill="none" viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M14.5 13.5V5.41a1 1 0 0 0-.3-.7L9.8.29A1 1 0 0 0 9.08 0H1.5v13.5A2.5 2.5 0 0 0 4 16h8a2.5 2.5 0 0 0 2.5-2.5m-1.5 0v-7H8v-5H3v12a1 1 0 0 0 1 1h8a1 1 0 0 0 1-1M9.5 5V2.12L12.38 5zM5.13 5h-.62v1.25h2.12V5zm-.62 3h7.12v1.25H4.5zm.62 3h-.62v1.25h7.12V11z" clip-rule="evenodd" fill="#666" fill-rule="evenodd"/></svg>
</file>

<file path="public/globe.svg">
<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><g clip-path="url(#a)"><path fill-rule="evenodd" clip-rule="evenodd" d="M10.27 14.1a6.5 6.5 0 0 0 3.67-3.45q-1.24.21-2.7.34-.31 1.83-.97 3.1M8 16A8 8 0 1 0 8 0a8 8 0 0 0 0 16m.48-1.52a7 7 0 0 1-.96 0H7.5a4 4 0 0 1-.84-1.32q-.38-.89-.63-2.08a40 40 0 0 0 3.92 0q-.25 1.2-.63 2.08a4 4 0 0 1-.84 1.31zm2.94-4.76q1.66-.15 2.95-.43a7 7 0 0 0 0-2.58q-1.3-.27-2.95-.43a18 18 0 0 1 0 3.44m-1.27-3.54a17 17 0 0 1 0 3.64 39 39 0 0 1-4.3 0 17 17 0 0 1 0-3.64 39 39 0 0 1 4.3 0m1.1-1.17q1.45.13 2.69.34a6.5 6.5 0 0 0-3.67-3.44q.65 1.26.98 3.1M8.48 1.5l.01.02q.41.37.84 1.31.38.89.63 2.08a40 40 0 0 0-3.92 0q.25-1.2.63-2.08a4 4 0 0 1 .85-1.32 7 7 0 0 1 .96 0m-2.75.4a6.5 6.5 0 0 0-3.67 3.44 29 29 0 0 1 2.7-.34q.31-1.83.97-3.1M4.58 6.28q-1.66.16-2.95.43a7 7 0 0 0 0 2.58q1.3.27 2.95.43a18 18 0 0 1 0-3.44m.17 4.71q-1.45-.12-2.69-.34a6.5 6.5 0 0 0 3.67 3.44q-.65-1.27-.98-3.1" fill="#666"/></g><defs><clipPath id="a"><path fill="#fff" d="M0 0h16v16H0z"/></clipPath></defs></svg>
</file>

<file path="public/next.svg">
<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 394 80"><path fill="#000" d="M262 0h68.5v12.7h-27.2v66.6h-13.6V12.7H262V0ZM149 0v12.7H94v20.4h44.3v12.6H94v21h55v12.6H80.5V0h68.7zm34.3 0h-17.8l63.8 79.4h17.9l-32-39.7 32-39.6h-17.9l-23 28.6-23-28.6zm18.3 56.7-9-11-27.1 33.7h17.8l18.3-22.7z"/><path fill="#000" d="M81 79.3 17 0H0v79.3h13.6V17l50.2 62.3H81Zm252.6-.4c-1 0-1.8-.4-2.5-1s-1.1-1.6-1.1-2.6.3-1.8 1-2.5 1.6-1 2.6-1 1.8.3 2.5 1a3.4 3.4 0 0 1 .6 4.3 3.7 3.7 0 0 1-3 1.8zm23.2-33.5h6v23.3c0 2.1-.4 4-1.3 5.5a9.1 9.1 0 0 1-3.8 3.5c-1.6.8-3.5 1.3-5.7 1.3-2 0-3.7-.4-5.3-1s-2.8-1.8-3.7-3.2c-.9-1.3-1.4-3-1.4-5h6c.1.8.3 1.6.7 2.2s1 1.2 1.6 1.5c.7.4 1.5.5 2.4.5 1 0 1.8-.2 2.4-.6a4 4 0 0 0 1.6-1.8c.3-.8.5-1.8.5-3V45.5zm30.9 9.1a4.4 4.4 0 0 0-2-3.3 7.5 7.5 0 0 0-4.3-1.1c-1.3 0-2.4.2-3.3.5-.9.4-1.6 1-2 1.6a3.5 3.5 0 0 0-.3 4c.3.5.7.9 1.3 1.2l1.8 1 2 .5 3.2.8c1.3.3 2.5.7 3.7 1.2a13 13 0 0 1 3.2 1.8 8.1 8.1 0 0 1 3 6.5c0 2-.5 3.7-1.5 5.1a10 10 0 0 1-4.4 3.5c-1.8.8-4.1 1.2-6.8 1.2-2.6 0-4.9-.4-6.8-1.2-2-.8-3.4-2-4.5-3.5a10 10 0 0 1-1.7-5.6h6a5 5 0 0 0 3.5 4.6c1 .4 2.2.6 3.4.6 1.3 0 2.5-.2 3.5-.6 1-.4 1.8-1 2.4-1.7a4 4 0 0 0 .8-2.4c0-.9-.2-1.6-.7-2.2a11 11 0 0 0-2.1-1.4l-3.2-1-3.8-1c-2.8-.7-5-1.7-6.6-3.2a7.2 7.2 0 0 1-2.4-5.7 8 8 0 0 1 1.7-5 10 10 0 0 1 4.3-3.5c2-.8 4-1.2 6.4-1.2 2.3 0 4.4.4 6.2 1.2 1.8.8 3.2 2 4.3 3.4 1 1.4 1.5 3 1.5 5h-5.8z"/></svg>
</file>

<file path="public/vercel.svg">
<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1155 1000"><path d="m577.3 0 577.4 1000H0z" fill="#fff"/></svg>
</file>

<file path="public/window.svg">
<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><path fill-rule="evenodd" clip-rule="evenodd" d="M1.5 2.5h13v10a1 1 0 0 1-1 1h-11a1 1 0 0 1-1-1zM0 1h16v11.5a2.5 2.5 0 0 1-2.5 2.5h-11A2.5 2.5 0 0 1 0 12.5zm3.75 4.5a.75.75 0 1 0 0-1.5.75.75 0 0 0 0 1.5M7 4.75a.75.75 0 1 1-1.5 0 .75.75 0 0 1 1.5 0m1.75.75a.75.75 0 1 0 0-1.5.75.75 0 0 0 0 1.5" fill="#666"/></svg>
</file>

<file path="README.md">
This is a [Next.js](https://nextjs.org) project bootstrapped with [`create-next-app`](https://github.com/vercel/next.js/tree/canary/packages/create-next-app).

## Getting Started

First, run the development server:

```bash
npm run dev
# or
yarn dev
# or
pnpm dev
# or
bun dev
```

Open [http://localhost:3000](http://localhost:3000) with your browser to see the result.

You can start editing the page by modifying `app/page.js`. The page auto-updates as you edit the file.

This project uses [`next/font`](https://nextjs.org/docs/app/building-your-application/optimizing/fonts) to automatically optimize and load [Geist](https://vercel.com/font), a new font family for Vercel.

## Learn More

To learn more about Next.js, take a look at the following resources:

- [Next.js Documentation](https://nextjs.org/docs) - learn about Next.js features and API.
- [Learn Next.js](https://nextjs.org/learn) - an interactive Next.js tutorial.

You can check out [the Next.js GitHub repository](https://github.com/vercel/next.js) - your feedback and contributions are welcome!

## Deploy on Vercel

The easiest way to deploy your Next.js app is to use the [Vercel Platform](https://vercel.com/new?utm_medium=default-template&filter=next.js&utm_source=create-next-app&utm_campaign=create-next-app-readme) from the creators of Next.js.

Check out our [Next.js deployment documentation](https://nextjs.org/docs/app/building-your-application/deploying) for more details.
</file>

<file path="src/components/Admin/AdminLayout.js">
import { useRouter } from "next/router";
import styles from "../../styles/Admin/AdminLayout.module.css";

export default function AdminLayout({ children }) {
  const router = useRouter();

  const handleLogout = () => {
    localStorage.removeItem("adminToken");
    localStorage.removeItem("adminData");
    router.push("/admin/login");
  };

  const navigation = [
    { name: "Dashboard", path: "/admin/dashboard", icon: "📊" },
    { name: "Salons", path: "/admin/salons", icon: "🏢" },
    { name: "Users", path: "/admin/users", icon: "👥" },
    { name: "Revenue", path: "/admin/revenue", icon: "💰" },
    { name: "Analytics", path: "/admin/analytics", icon: "📈" },
    { name: "Reports", path: "/admin/reports", icon: "📄" },
  ];

  return (
    <div className={styles.layout}>
      {/* Sidebar */}
      <aside className={styles.sidebar}>
        <div className={styles.logo}>
          <h2>TechTrims Admin</h2>
        </div>

        <nav className={styles.nav}>
          {navigation.map((item) => (
            <button
              key={item.path}
              className={`${styles.navItem} ${
                router.pathname === item.path ? styles.active : ""
              }`}
              onClick={() => router.push(item.path)}
            >
              <span className={styles.icon}>{item.icon}</span>
              <span>{item.name}</span>
            </button>
          ))}
        </nav>

        <button className={styles.logoutBtn} onClick={handleLogout}>
          🚪 Logout
        </button>
      </aside>

      {/* Main Content */}
      <main className={styles.main}>{children}</main>
    </div>
  );
}
</file>

<file path="src/components/Admin/SalonDetailsModal.js">
import { useState, useEffect } from "react";
import styles from "../../styles/Admin/AdminModal.module.css";

export default function SalonDetailsModal({ salon, onClose }) {
  const [bookings, setBookings] = useState([]);
  const [reviews, setReviews] = useState([]);
  const [barbers, setBarbers] = useState([]);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    fetchSalonDetails();
  }, [salon._id]);

  const fetchSalonDetails = async () => {
    try {
      const token = localStorage.getItem("adminToken");
      const salonId = salon._id.toString(); // Convert to string

      console.log("Fetching details for salon:", salonId);

      // Fetch bookings
      const bookingsRes = await fetch(`/api/admin/salons/${salonId}/bookings`, {
        headers: { Authorization: `Bearer ${token}` },
      });

      if (bookingsRes.ok) {
        const bookingsData = await bookingsRes.json();
        console.log("Bookings received:", bookingsData.bookings);
        setBookings(bookingsData.bookings || []);
      }

      // Fetch reviews
      const reviewsRes = await fetch(`/api/admin/salons/${salonId}/reviews`, {
        headers: { Authorization: `Bearer ${token}` },
      });

      if (reviewsRes.ok) {
        const reviewsData = await reviewsRes.json();
        console.log("Reviews received:", reviewsData.reviews);
        setReviews(reviewsData.reviews || []);
      }

      // Fetch barbers
      const barbersRes = await fetch(`/api/admin/salons/${salonId}/barbers`, {
        headers: { Authorization: `Bearer ${token}` },
      });

      if (barbersRes.ok) {
        const barbersData = await barbersRes.json();
        console.log("Barbers received:", barbersData.barbers);
        setBarbers(barbersData.barbers || []);
      }
    } catch (error) {
      console.error("Error fetching salon details:", error);
    } finally {
      setLoading(false);
    }
  };

  return (
    <div className={styles.overlay} onClick={onClose}>
      <div className={styles.modal} onClick={(e) => e.stopPropagation()}>
        <button className={styles.closeBtn} onClick={onClose}>
          ✕
        </button>

        <h2 className={styles.title}>{salon.salonName}</h2>

        {loading ? (
          <div className={styles.loading}>Loading details...</div>
        ) : (
          <div className={styles.content}>
            {/* Basic Info */}
            <section className={styles.section}>
              <h3>Basic Information</h3>
              <div className={styles.info}>
                <p>
                  <strong>Owner:</strong> {salon.ownerName}
                </p>
                <p>
                  <strong>Email:</strong> {salon.email}
                </p>
                <p>
                  <strong>Phone:</strong> {salon.phone}
                </p>
                <p>
                  <strong>Address:</strong>{" "}
                  {salon.location?.address || "Not set"}
                </p>
                <p>
                  <strong>Status:</strong>{" "}
                  {salon.isActive ? "✅ Active" : "❌ Inactive"}
                </p>
                <p>
                  <strong>Verified:</strong>{" "}
                  {salon.isVerified ? "✅ Yes" : "❌ No"}
                </p>
              </div>
            </section>

            {/* Stats */}
            <section className={styles.section}>
              <h3>Statistics</h3>
              <div className={styles.stats}>
                <div className={styles.statCard}>
                  <span>Total Bookings</span>
                  <strong>{bookings.length}</strong>
                </div>
                <div className={styles.statCard}>
                  <span>Rating</span>
                  <strong>
                    ⭐ {(salon.ratings?.overall || 5.0).toFixed(1)}
                  </strong>
                </div>
                <div className={styles.statCard}>
                  <span>Reviews</span>
                  <strong>{reviews.length}</strong>
                </div>
              </div>
            </section>

            {/* Barbers */}
            <section className={styles.section}>
              <h3>Barbers ({barbers.length})</h3>
              <div className={styles.list}>
                {barbers.length > 0 ? (
                  barbers.map((barber) => (
                    <div key={barber._id} className={styles.listItem}>
                      <p>
                        <strong>{barber.name}</strong>
                      </p>
                      <p className={styles.small}>
                        {barber.experience} years | ⭐ {barber.rating} |{" "}
                        {barber.totalBookings} bookings
                      </p>
                    </div>
                  ))
                ) : (
                  <p className={styles.small}>No barbers added yet</p>
                )}
              </div>
            </section>

            {/* Recent Bookings */}
            <section className={styles.section}>
              <h3>Recent Bookings ({bookings.length})</h3>
              <div className={styles.list}>
                {bookings.length > 0 ? (
                  bookings.slice(0, 5).map((booking) => (
                    <div key={booking._id} className={styles.listItem}>
                      <p>
                        <strong>{booking.customerName}</strong>
                      </p>
                      <p className={styles.small}>
                        {booking.service} - {booking.date} at {booking.time}
                      </p>
                      <p className={styles.small}>
                        Status: {booking.status} | ₹{booking.price}
                      </p>
                    </div>
                  ))
                ) : (
                  <p className={styles.small}>No bookings yet</p>
                )}
              </div>
            </section>

            {/* Reviews */}
            <section className={styles.section}>
              <h3>Recent Reviews ({reviews.length})</h3>
              <div className={styles.list}>
                {reviews.length > 0 ? (
                  reviews.slice(0, 5).map((review) => (
                    <div key={review._id} className={styles.listItem}>
                      <p>
                        <strong>{review.customerName}</strong>
                      </p>
                      <p>⭐ {review.rating}/5</p>
                      <p className={styles.small}>
                        {review.comment || "No comment"}
                      </p>
                    </div>
                  ))
                ) : (
                  <p className={styles.small}>No reviews yet</p>
                )}
              </div>
            </section>
          </div>
        )}
      </div>
    </div>
  );
}
</file>

<file path="src/components/Admin/StatsCards.js">
import styles from "../../styles/Admin/AdminStatsCards.module.css";

export default function StatsCards({ stats }) {
  const cards = [
    {
      title: "Total Salons",
      value: stats?.totalSalons || 0,
      icon: "🏢",
      color: "#f59e0b",
    },
    {
      title: "Total Users",
      value: stats?.totalUsers || 0,
      icon: "👥",
      color: "#3b82f6",
    },
    {
      title: "Total Bookings",
      value: stats?.totalBookings || 0,
      icon: "📅",
      color: "#10b981",
    },
    {
      title: "Total Revenue",
      value: `₹${stats?.totalRevenue || 0}`,
      icon: "💰",
      color: "#8b5cf6",
    },
  ];

  return (
    <div className={styles.container}>
      {cards.map((card) => (
        <div
          key={card.title}
          className={styles.card}
          style={{ borderLeft: `4px solid ${card.color}` }}
        >
          <div
            className={styles.icon}
            style={{ background: `${card.color}20`, color: card.color }}
          >
            {card.icon}
          </div>
          <div className={styles.content}>
            <h3 className={styles.title}>{card.title}</h3>
            <p className={styles.value}>{card.value}</p>
          </div>
        </div>
      ))}
    </div>
  );
}
</file>

<file path="src/components/FullBG.js">
// components/FullBG.js
import { useEffect, useRef } from "react";
import { Renderer, Program, Mesh, Triangle } from "ogl";

const hexToRgb = (hex) => {
  const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
  if (!result) return [1, 0.5, 0.2];
  return [
    parseInt(result[1], 16) / 255,
    parseInt(result[2], 16) / 255,
    parseInt(result[3], 16) / 255,
  ];
};

const vertex = `#version 300 es
precision highp float;
in vec2 position;
in vec2 uv;
out vec2 vUv;
void main() {
  vUv = uv;
  gl_Position = vec4(position, 0.0, 1.0);
}`;

const fragment = `#version 300 es
precision highp float;
uniform vec2 iResolution;
uniform float iTime;
uniform vec3 uCustomColor;
uniform float uUseCustomColor;
uniform float uSpeed;
uniform float uDirection;
uniform float uScale;
uniform float uOpacity;
uniform vec2 uMouse;
uniform float uMouseInteractive;
out vec4 fragColor;

void mainImage(out vec4 o, vec2 C) {
  vec2 center = iResolution.xy * 0.5;
  C = (C - center) / uScale + center;
  
  vec2 mouseOffset = (uMouse - center) * 0.0002;
  C += mouseOffset * length(C - center) * step(0.5, uMouseInteractive);
  
  float i, d, z, T = iTime * uSpeed * uDirection;
  vec3 O, p, S;

  for (vec2 r = iResolution.xy, Q; ++i < 60.; O += o.w/d*o.xyz) {
    p = z*normalize(vec3(C-.5*r,r.y)); 
    p.z -= 4.; 
    S = p;
    d = p.y-T;
    
    p.x += .4*(1.+p.y)*sin(d + p.x*0.1)*cos(.34*d + p.x*0.05); 
    Q = p.xz *= mat2(cos(p.y+vec4(0,11,33,0)-T)); 
    z+= d = abs(sqrt(length(Q*Q)) - .25*(5.+S.y))/3.+8e-4; 
    o = 1.+sin(S.y+p.z*.5+S.z-length(S-p)+vec4(2,1,0,8));
  }
  
  o.xyz = tanh(O/1e4);
}

bool finite1(float x){ return !(isnan(x) || isinf(x)); }
vec3 sanitize(vec3 c){
  return vec3(
    finite1(c.r) ? c.r : 0.0,
    finite1(c.g) ? c.g : 0.0,
    finite1(c.b) ? c.b : 0.0
  );
}

void main() {
  vec4 o = vec4(0.0);
  mainImage(o, gl_FragCoord.xy);
  vec3 rgb = sanitize(o.rgb);
  
  float intensity = (rgb.r + rgb.g + rgb.b) / 3.0;
  vec3 customColor = intensity * uCustomColor;
  vec3 finalColor = mix(rgb, customColor, step(0.5, uUseCustomColor));
  
  float alpha = length(rgb) * uOpacity;
  fragColor = vec4(finalColor, alpha);
}`;

export const Plasma = ({
  color = "#ffffff",
  speed = 1,
  direction = "forward",
  scale = 1,
  opacity = 1,
  mouseInteractive = true,
}) => {
  const containerRef = useRef(null);
  const mousePos = useRef({ x: 0, y: 0 });

  useEffect(() => {
    if (!containerRef.current) return;

    const useCustomColor = color ? 1.0 : 0.0;
    const customColorRgb = color ? hexToRgb(color) : [1, 1, 1];
    const directionMultiplier = direction === "reverse" ? -1.0 : 1.0;

    const renderer = new Renderer({
      webgl: 2,
      alpha: true,
      antialias: false,
      dpr: Math.min(window.devicePixelRatio || 1, 2),
    });
    const gl = renderer.gl;
    const canvas = gl.canvas;
    canvas.style.display = "block";
    canvas.style.width = "100%";
    canvas.style.height = "100%";
    containerRef.current.appendChild(canvas);

    const geometry = new Triangle(gl);

    const program = new Program(gl, {
      vertex: vertex,
      fragment: fragment,
      uniforms: {
        iTime: { value: 0 },
        iResolution: { value: new Float32Array([1, 1]) },
        uCustomColor: { value: new Float32Array(customColorRgb) },
        uUseCustomColor: { value: useCustomColor },
        uSpeed: { value: speed * 0.4 },
        uDirection: { value: directionMultiplier },
        uScale: { value: scale },
        uOpacity: { value: opacity },
        uMouse: { value: new Float32Array([0, 0]) },
        uMouseInteractive: { value: mouseInteractive ? 1.0 : 0.0 },
      },
    });

    const mesh = new Mesh(gl, { geometry, program });

    const handleMouseMove = (e) => {
      if (!mouseInteractive) return;
      const rect = containerRef.current.getBoundingClientRect();
      mousePos.current.x = e.clientX - rect.left;
      mousePos.current.y = e.clientY - rect.top;
      const mouseUniform = program.uniforms.uMouse.value;
      mouseUniform[0] = mousePos.current.x;
      mouseUniform[1] = mousePos.current.y;
    };

    if (mouseInteractive) {
      containerRef.current.addEventListener("mousemove", handleMouseMove);
    }

    const setSize = () => {
      const rect = containerRef.current.getBoundingClientRect();
      const width = Math.max(1, Math.floor(rect.width));
      const height = Math.max(1, Math.floor(rect.height));
      renderer.setSize(width, height);
      const res = program.uniforms.iResolution.value;
      res[0] = gl.drawingBufferWidth;
      res[1] = gl.drawingBufferHeight;
    };

    const ro = new ResizeObserver(setSize);
    ro.observe(containerRef.current);
    setSize();

    let raf = 0;
    const t0 = performance.now();
    const loop = (t) => {
      let timeValue = (t - t0) * 0.001;

      if (direction === "pingpong") {
        const cycle = Math.sin(timeValue * 0.5) * directionMultiplier;
        program.uniforms.uDirection.value = cycle;
      }

      program.uniforms.iTime.value = timeValue;
      renderer.render({ scene: mesh });
      raf = requestAnimationFrame(loop);
    };
    raf = requestAnimationFrame(loop);

    return () => {
      cancelAnimationFrame(raf);
      ro.disconnect();
      if (mouseInteractive && containerRef.current) {
        containerRef.current.removeEventListener("mousemove", handleMouseMove);
      }
      try {
        containerRef.current?.removeChild(canvas);
      } catch {
        console.warn("Canvas already removed");
      }
    };
  }, [color, speed, direction, scale, opacity, mouseInteractive]);

  return (
    <div
      ref={containerRef}
      style={{
        position: "fixed",
        inset: 0,
        width: "100vw",
        height: "100vh",
        zIndex: 0,
        overflow: "hidden",
        pointerEvents: "none",
      }}
    />
  );
};

export default Plasma;
</file>

<file path="src/components/NetworkStatus.js">
import { useState, useEffect } from "react";
import useNetworkStatus from "../hooks/useNetworkStatus";

export default function NetworkStatus() {
  const { isOnline, isSlowConnection, connectionType } = useNetworkStatus();
  const [showNotification, setShowNotification] = useState(false);
  const [notificationType, setNotificationType] = useState("offline");

  useEffect(() => {
    if (!isOnline) {
      setNotificationType("offline");
      setShowNotification(true);
    } else if (isSlowConnection) {
      setNotificationType("slow");
      setShowNotification(true);
    } else {
      // Hide notification when connection is good, but with delay for better UX
      const timer = setTimeout(() => {
        setShowNotification(false);
      }, 2000);
      return () => clearTimeout(timer);
    }
  }, [isOnline, isSlowConnection]);

  if (!showNotification) return null;

  const getNotificationConfig = () => {
    switch (notificationType) {
      case "offline":
        return {
          icon: "📡",
          title: "You're Offline",
          message: "Check your internet connection",
          bgColor: "bg-red-500",
          textColor: "text-white",
        };
      case "slow":
        return {
          icon: "🐌",
          title: "Slow Connection",
          message: `Connection: ${connectionType.toUpperCase()}`,
          bgColor: "bg-yellow-500",
          textColor: "text-black",
        };
      default:
        return {
          icon: "✅",
          title: "Back Online",
          message: "Connection restored",
          bgColor: "bg-green-500",
          textColor: "text-white",
        };
    }
  };

  const config = getNotificationConfig();

  return (
    <>
      {/* Mobile-first notification bar */}
      <div
        className={`fixed top-0 left-0 right-0 z-100 ${config.bgColor} ${
          config.textColor
        } px-4 py-3 text-center transform transition-transform duration-300 ${
          showNotification ? "translate-y-0" : "-translate-y-full"
        }`}
      >
        <div className="flex items-center justify-center gap-2 text-sm font-medium">
          <span className="text-lg">{config.icon}</span>
          <span>{config.title}</span>
          <span className="hidden sm:inline">- {config.message}</span>
        </div>
      </div>

      {/* Desktop floating notification */}
      {/* <div
        className={`fixed top-4 left-4 z-50 hidden sm:block transform transition-all duration-300 ${
          showNotification
            ? "translate-x-0 opacity-100"
            : "-translate-x-full opacity-0"
        }`}
      >
        <div
          className={`${config.bgColor} ${config.textColor} rounded-lg shadow-lg p-4 max-w-xs`}
        >
          <div className="flex items-center gap-3">
            <span className="text-2xl">{config.icon}</span>
            <div>
              <div className="font-semibold text-sm">{config.title}</div>
              <div className="text-xs opacity-90">{config.message}</div>
            </div>
            <button
              onClick={() => setShowNotification(false)}
              className="ml-2 text-xs opacity-70 hover:opacity-100"
            >
              ✕
            </button>
          </div>
        </div>
      </div> */}
    </>
  );
}
</file>

<file path="src/components/OnBoardingLogout.js">
import { useState, useEffect } from "react";
import { useRouter } from "next/router";
import { UserDataManager } from "../lib/userData";

export default function OnboardingLogoutButton() {
  const [showButton, setShowButton] = useState(false);
  const [onboardingData, setOnboardingData] = useState(null);
  const router = useRouter();

  useEffect(() => {
    const checkOnboardingStatus = () => {
      const hasOnboarded = localStorage.getItem("hasOnboarded");
      const userToken = localStorage.getItem("userToken");
      const authenticatedUserData = localStorage.getItem(
        "authenticatedUserData"
      );
      const onboardingDataStr = localStorage.getItem("userOnboardingData");

      // Show button only if onboarded but not logged in
      const isOnboarded = hasOnboarded === "true";
      const isLoggedIn = !!(userToken && authenticatedUserData);

      setShowButton(isOnboarded && !isLoggedIn);

      // Parse onboarding data for display
      if (onboardingDataStr) {
        try {
          setOnboardingData(JSON.parse(onboardingDataStr));
        } catch (e) {
          setOnboardingData(null);
        }
      }
    };

    checkOnboardingStatus();
    const handleStorageChange = () => checkOnboardingStatus();
    window.addEventListener("storage", handleStorageChange);
    const interval = setInterval(checkOnboardingStatus, 1000);

    return () => {
      window.removeEventListener("storage", handleStorageChange);
      clearInterval(interval);
    };
  }, []);

  const handleClearOnboarding = () => {
    const message = onboardingData?.name
      ? `Clear data for "${onboardingData.name}" and start fresh?`
      : "Clear onboarding data and start fresh?";

    if (window.confirm(message)) {
      // Clear onboarding specific data
      localStorage.removeItem("hasOnboarded");
      localStorage.removeItem("userOnboardingData");
      localStorage.removeItem("userPrefillData");

      alert("✅ Onboarding data cleared! You can now start fresh.");
      router.push("/onboarding");
    }
  };

  if (!showButton) return null;

  return (
    <div>
      <div className="bg-white rounded-md shadow-lg border border-gray-200 p-8 max-w-xs">
        {onboardingData && (
          <div className="text-xs text-gray-600 mb-2">
            user:
            <span className="font-semibold text-gray-800">
              {onboardingData.name}
            </span>
          </div>
        )}
        <button
          onClick={handleClearOnboarding}
          className="w-full bg-red-500 hover:bg-red-600 text-white px-3 py-2 rounded-md text-sm font-medium transition-all duration-200 flex items-center justify-center gap-2"
        >
          🗑️ Clear
        </button>
      </div>
    </div>
  );
}
</file>

<file path="src/components/RetryButton.js">
import { useState } from "react";
import useNetworkStatus from "../hooks/useNetworkStatus";

export default function RetryButton({ onRetry, disabled = false }) {
  const { isOnline } = useNetworkStatus();
  const [isRetrying, setIsRetrying] = useState(false);

  const handleRetry = async () => {
    if (!isOnline || disabled) return;

    setIsRetrying(true);
    try {
      await onRetry();
    } finally {
      setIsRetrying(false);
    }
  };

  return (
    <button
      onClick={handleRetry}
      disabled={!isOnline || disabled || isRetrying}
      className={`px-4 py-2 rounded-lg font-medium transition-all duration-200 ${
        !isOnline || disabled
          ? "bg-gray-300 text-gray-500 cursor-not-allowed"
          : "bg-blue-500 hover:bg-blue-600 text-white active:scale-95"
      }`}
    >
      {isRetrying ? (
        <span className="flex items-center gap-2">
          <div className="animate-spin w-4 h-4 border-2 border-white border-t-transparent rounded-full"></div>
          Retrying...
        </span>
      ) : !isOnline ? (
        "📡 Offline"
      ) : (
        "🔄 Retry"
      )}
    </button>
  );
}
</file>

<file path="src/components/Salon/ReviewSection.js">
import { useState, useEffect } from "react";
import styles from "../../styles/ReviewsSection.module.css";

export default function ReviewsSection({ salonId }) {
  const [reviews, setReviews] = useState([]);
  const [stats, setStats] = useState(null);
  const [loading, setLoading] = useState(true);
  const [filter, setFilter] = useState("all");
  const [sortBy, setSortBy] = useState("relevant"); // 'relevant' or 'recent'
  const [displayCount, setDisplayCount] = useState(9); // Show 6 reviews initially
  const REVIEWS_PER_PAGE = 9;

  useEffect(() => {
    const fetchReviews = async () => {
      try {
        const response = await fetch(`/api/salons/${salonId}/reviews-detailed`);
        if (response.ok) {
          const data = await response.json();
          setReviews(data.reviews);
          setStats(data.stats);
        }
      } catch (error) {
        console.error("Error fetching reviews:", error);
      } finally {
        setLoading(false);
      }
    };
    fetchReviews();
  }, [salonId]);

  const getRatingCategory = (rating) => {
    if (rating >= 4) return "positive";
    if (rating >= 3) return "medium";
    return "critical";
  };

  const calculateRelevanceScore = (review) => {
    let score = 0;

    // Rating weight (40%)
    score += review.rating * 8;

    // Comment length weight (30%)
    const commentLength = review.comment?.length || 0;
    score += Math.min(commentLength / 10, 30);

    // Recency weight (30%)
    const daysSinceReview =
      (Date.now() - new Date(review.submittedAt)) / (1000 * 60 * 60 * 24);
    const recencyBonus = Math.max(0, 30 - daysSinceReview / 3);
    score += recencyBonus;

    // Detailed ratings bonus (10%)
    const ratingsCount = Object.values(review.ratings || {}).filter(
      (r) => r > 0
    ).length;
    score += ratingsCount * 2.5;

    return score;
  };

  // Sort reviews based on selected option
  const getSortedReviews = () => {
    let sorted = [...reviews];

    if (sortBy === "recent") {
      // Sort by submission date (newest first)
      sorted.sort((a, b) => new Date(b.submittedAt) - new Date(a.submittedAt));
    } else {
      // Sort by relevance score (highest first)
      sorted.sort(
        (a, b) => calculateRelevanceScore(b) - calculateRelevanceScore(a)
      );
    }

    return sorted;
  };

  const sortedReviews = getSortedReviews();

  const filteredReviews =
    filter === "all"
      ? sortedReviews
      : sortedReviews.filter((r) => getRatingCategory(r.rating) === filter);

  const displayedReviews = filteredReviews.slice(0, displayCount);
  const hasMore = displayCount < filteredReviews.length;

  const handleShowMore = () => {
    setDisplayCount((prev) => prev + REVIEWS_PER_PAGE);
  };

  const handleFilterChange = (newFilter) => {
    setFilter(newFilter);
    setDisplayCount(REVIEWS_PER_PAGE);
  };

  const handleSortChange = (newSort) => {
    setSortBy(newSort);
    setDisplayCount(REVIEWS_PER_PAGE);
  };

  if (loading) {
    return <div className={styles.loading}>Loading reviews...</div>;
  }

  if (!stats || reviews.length === 0) {
    return (
      <div className={styles.noReviews}>
        <p>No reviews yet. Be the first to review!</p>
      </div>
    );
  }

  return (
    <div className={styles.reviewsSection}>
      <h2 className={styles.mainTitle}>Customer Reviews & Ratings</h2>
      <div className={styles.reviewsContainer}>
        <div className={styles.reviewsContainerleft}>
          {/* Compact Stats Header */}
          <div className={styles.statsHeader}>
            {/* Overall Rating */}
            <div className={styles.overallBox}>
              <div className={styles.bigRating}>
                {stats.averageRating.toFixed(1)}
              </div>
              <div className={styles.stars}>
                {"⭐".repeat(Math.round(stats.averageRating))}
              </div>
              <div className={styles.reviewCount}>
                {stats.totalReviews} reviews
              </div>
            </div>

            {/* Compact Breakdown */}
            <div className={styles.breakdown}>
              <div className={styles.breakdownRow}>
                <span className={styles.label}>😊 Positive</span>
                <div className={styles.bar}>
                  <div
                    className={`${styles.fill} ${styles.positive}`}
                    style={{ width: `${stats.positivePercentage}%` }}
                  />
                </div>
                <span className={styles.percent}>
                  {stats.positivePercentage}%
                </span>
                <span className={styles.count}>({stats.positiveCount})</span>
              </div>

              <div className={styles.breakdownRow}>
                <span className={styles.label}>😐 Average</span>
                <div className={styles.bar}>
                  <div
                    className={`${styles.fill} ${styles.medium}`}
                    style={{ width: `${stats.mediumPercentage}%` }}
                  />
                </div>
                <span className={styles.percent}>
                  {stats.mediumPercentage}%
                </span>
                <span className={styles.count}>({stats.mediumCount})</span>
              </div>

              <div className={styles.breakdownRow}>
                <span className={styles.label}>😟 Critical</span>
                <div className={styles.bar}>
                  <div
                    className={`${styles.fill} ${styles.critical}`}
                    style={{ width: `${stats.criticalPercentage}%` }}
                  />
                </div>
                <span className={styles.percent}>
                  {stats.criticalPercentage}%
                </span>
                <span className={styles.count}>({stats.criticalCount})</span>
              </div>
            </div>
          </div>

          <div className={styles.controls}>
            {/* Category Filter Pills */}
            <div className={styles.filterPills}>
              <button
                className={`${styles.pill} ${
                  filter === "all" ? styles.active : ""
                }`}
                onClick={() => handleFilterChange("all")}
              >
                All ({reviews.length})
              </button>
              <button
                className={`${styles.pill} ${
                  filter === "positive" ? styles.active : ""
                }`}
                onClick={() => handleFilterChange("positive")}
              >
                Positive ({stats.positiveCount})
              </button>
              <button
                className={`${styles.pill} ${
                  filter === "medium" ? styles.active : ""
                }`}
                onClick={() => handleFilterChange("medium")}
              >
                Average ({stats.mediumCount})
              </button>
              <button
                className={`${styles.pill} ${
                  filter === "critical" ? styles.active : ""
                }`}
                onClick={() => handleFilterChange("critical")}
              >
                Critical ({stats.criticalCount})
              </button>
            </div>

            {/* Sort Dropdown */}
            <div className={styles.sortDropdown}>
              <label htmlFor="sort">Sort by:</label>
              <select
                id="sort"
                value={sortBy}
                onChange={(e) => handleSortChange(e.target.value)}
              >
                <option value="relevant">Most Relevant</option>
                <option value="recent">Most Recent</option>
              </select>
            </div>
          </div>
        </div>
        <div className={styles.reviewsContainerright}>
          {/* Reviews Grid - 3 Columns */}
          <div className={styles.reviewsGrid}>
            {displayedReviews.map((review) => (
              <div key={review._id} className={styles.reviewCard}>
                <div className={styles.cardHeader}>
                  <div className={styles.user}>
                    <div className={styles.avatar}>
                      {review.customerName.charAt(0).toUpperCase()}
                    </div>
                    <div>
                      <div className={styles.name}>{review.customerName}</div>
                      <div className={styles.service}>{review.service}</div>
                    </div>
                  </div>
                  <div className={styles.badge}>{review.rating}⭐</div>
                </div>

                {review.comment && (
                  <p className={styles.comment}>&quot;{review.comment}&quot;</p>
                )}

                <div className={styles.meta}>
                  <span className={styles.date}>
                    {new Date(review.serviceDate).toLocaleDateString("en-IN", {
                      day: "numeric",
                      month: "short",
                    })}
                  </span>
                </div>
              </div>
            ))}
          </div>

          {/* Show More */}
          {hasMore && (
            <div className={styles.showMore}>
              <button onClick={handleShowMore}>
                Show More ({filteredReviews.length - displayCount} remaining)
              </button>
            </div>
          )}
        </div>

        {displayedReviews.length === 0 && (
          <div className={styles.noResults}>
            No reviews found for this filter
          </div>
        )}
      </div>
    </div>
  );
}
</file>

<file path="src/components/Salon/SalonDashboard.js">
// components/salons/SalonDashboard.js
import React, { useEffect, useState } from "react";
import BookingList from "./dashboard/BookingList";
import BookingForm from "./dashboard/BookingForm";
import StaffList from "./dashboard/StaffList";
import ServiceList from "./dashboard/ServiceList";

/**
 * NOTE: Replace this salonId with actual salonId from your auth/session.
 * For testing, you can hardcode a salonId string (ObjectId) from your DB.
 */
const DEFAULT_SALON_ID = process.env.NEXT_PUBLIC_SALON_ID || "";

export default function SalonDashboard() {
  const [salonId] = useState(DEFAULT_SALON_ID);

  if (!salonId) {
    return (
      <div className="p-8">
        <h2 className="text-xl font-semibold">Salon Dashboard</h2>
        <p className="mt-4 text-red-600">
          No salonId configured. Set NEXT_PUBLIC_SALON_ID or connect to auth
          session.
        </p>
      </div>
    );
  }

  return (
    <main className="p-6 space-y-6">
      <header className="flex items-center justify-between">
        <h1 className="text-2xl font-bold">Salon Owner Dashboard</h1>
        <div>
          Salon ID: <code className="bg-gray-100 p-1 rounded">{salonId}</code>
        </div>
      </header>

      <section className="grid md:grid-cols-3 gap-4">
        <div className="md:col-span-2 bg-white p-4 rounded shadow">
          <h2 className="font-semibold mb-2">Today&#39;s Bookings</h2>
          <BookingList salonId={salonId} />
        </div>

        <div className="bg-white p-4 rounded shadow">
          <h2 className="font-semibold mb-2">Create Booking</h2>
          <BookingForm salonId={salonId} />
        </div>
      </section>

      <section className="grid md:grid-cols-2 gap-4">
        <div className="bg-white p-4 rounded shadow">
          <h2 className="font-semibold mb-2">Staff</h2>
          <StaffList salonId={salonId} />
        </div>

        <div className="bg-white p-4 rounded shadow">
          <h2 className="font-semibold mb-2">Services</h2>
          <ServiceList salonId={salonId} />
        </div>
      </section>
    </main>
  );
}
</file>

<file path="src/components/TextMorph.jsx">
// components/TextMorph.js
import React, { useEffect, useRef } from "react";

const texts = ["Why", "is", "this", "so", "satisfying", "to", "watch?"];

const morphTime = 1;
const cooldownTime = 0.25;

const TextMorph = () => {
  const text1Ref = useRef(null);
  const text2Ref = useRef(null);

  const textIndexRef = useRef(texts.length - 1);
  const morphRef = useRef(0);
  const cooldownRef = useRef(cooldownTime);
  const timeRef = useRef(new Date());

  useEffect(() => {
    const elts = {
      text1: text1Ref.current,
      text2: text2Ref.current,
    };

    elts.text1.textContent = texts[textIndexRef.current % texts.length];
    elts.text2.textContent = texts[(textIndexRef.current + 1) % texts.length];

    function setMorph(fraction) {
      elts.text2.style.filter = `blur(${Math.min(8 / fraction - 8, 100)}px)`;
      elts.text2.style.opacity = `${Math.pow(fraction, 0.4) * 100}%`;

      fraction = 1 - fraction;
      elts.text1.style.filter = `blur(${Math.min(8 / fraction - 8, 100)}px)`;
      elts.text1.style.opacity = `${Math.pow(fraction, 0.4) * 100}%`;

      elts.text1.textContent = texts[textIndexRef.current % texts.length];
      elts.text2.textContent = texts[(textIndexRef.current + 1) % texts.length];
    }

    function doMorph() {
      morphRef.current -= cooldownRef.current;
      cooldownRef.current = 0;

      let fraction = morphRef.current / morphTime;

      if (fraction > 1) {
        cooldownRef.current = cooldownTime;
        fraction = 1;
      }

      setMorph(fraction);
    }

    function doCooldown() {
      morphRef.current = 0;
      elts.text2.style.filter = "";
      elts.text2.style.opacity = "100%";
      elts.text1.style.filter = "";
      elts.text1.style.opacity = "0%";
    }

    function animate() {
      requestAnimationFrame(animate);
      const newTime = new Date();
      const dt = (newTime - timeRef.current) / 1000;
      timeRef.current = newTime;

      if (cooldownRef.current > 0) {
        cooldownRef.current -= dt;
        if (cooldownRef.current <= 0) {
          textIndexRef.current++;
          doMorph();
        } else {
          doCooldown();
        }
      } else {
        morphRef.current += dt;
        doMorph();
      }
    }

    animate();

    return () => {
      // Cleanup: nothing special needed because animate uses requestAnimationFrame loop
      // If wanted, could implement cancelation logic here.
    };
  }, []);

  return (
    <>
      <div id="container">
        <span id="text1" ref={text1Ref} />
        <span id="text2" ref={text2Ref} />
      </div>
      <style jsx>{`
        @import url("https://fonts.googleapis.com/css?family=Raleway:900&display=swap");

        text #container {
          position: absolute;
          margin: auto;
          width: 100vw;
          height: 80pt;
          top: 0;
          bottom: 0;
          filter: url(#threshold) blur(0.6px);
        }

        #text1,
        #text2 {
          position: absolute;
          width: 100%;
          display: inline-block;
          font-family: "Raleway", sans-serif;
          font-size: 80pt;
          text-align: center;
          user-select: none;
          left: 0;
          right: 0;
          margin: auto;
        }
      `}</style>

      {/* SVG filter referenced by CSS filter property */}
      <svg
        style={{ position: "absolute", width: 0, height: 0 }}
        aria-hidden="true"
      >
        <defs>
          <filter id="threshold" colorInterpolationFilters="sRGB">
            <feColorMatrix
              type="matrix"
              values="1 0 0 0 0
                  0 1 0 0 0
                  0 0 1 0 0
                  0 0 0 255 -140"
            />
          </filter>
        </defs>
      </svg>
    </>
  );
};

export default TextMorph;
</file>

<file path="src/hooks/useNetworkStatus.js">
import { useState, useEffect } from "react";

export default function useNetworkStatus() {
  const [isOnline, setIsOnline] = useState(true);
  const [isSlowConnection, setIsSlowConnection] = useState(false);
  const [connectionType, setConnectionType] = useState("unknown");

  useEffect(() => {
    // Check initial online status
    setIsOnline(navigator.onLine);

    // Get connection info if available
    const connection =
      navigator.connection ||
      navigator.mozConnection ||
      navigator.webkitConnection;

    const updateConnectionInfo = () => {
      if (connection) {
        setConnectionType(connection.effectiveType || "unknown");
        // Consider 2g and slow-2g as slow connections
        setIsSlowConnection(
          connection.effectiveType === "2g" ||
            connection.effectiveType === "slow-2g" ||
            connection.downlink < 1.5 // Less than 1.5 Mbps
        );
      }
    };

    // Test connection speed
    const testConnectionSpeed = async () => {
      if (!navigator.onLine) return;

      try {
        const startTime = Date.now();
        const response = await fetch("/api/ping", {
          method: "HEAD",
          cache: "no-cache",
        });
        const endTime = Date.now();
        const latency = endTime - startTime;

        // Consider connection slow if latency > 3 seconds or request fails
        setIsSlowConnection(latency > 3000 || !response.ok);
      } catch (error) {
        setIsSlowConnection(true);
      }
    };

    // Event listeners
    const handleOnline = () => {
      setIsOnline(true);
      testConnectionSpeed();
    };

    const handleOffline = () => {
      setIsOnline(false);
      setIsSlowConnection(false);
    };

    const handleConnectionChange = () => updateConnectionInfo();

    // Add event listeners
    window.addEventListener("online", handleOnline);
    window.addEventListener("offline", handleOffline);

    if (connection) {
      connection.addEventListener("change", handleConnectionChange);
    }

    // Initial checks
    updateConnectionInfo();
    if (navigator.onLine) {
      testConnectionSpeed();
    }

    // Periodic speed test (every 30 seconds when online)
    const speedTestInterval = setInterval(() => {
      if (navigator.onLine) {
        testConnectionSpeed();
      }
    }, 30000);

    // Cleanup
    return () => {
      window.removeEventListener("online", handleOnline);
      window.removeEventListener("offline", handleOffline);
      if (connection) {
        connection.removeEventListener("change", handleConnectionChange);
      }
      clearInterval(speedTestInterval);
    };
  }, []);

  return { isOnline, isSlowConnection, connectionType };
}
</file>

<file path="src/lib/adminAuth.js">
import jwt from "jsonwebtoken";

export function verifyAdminToken(req) {
  try {
    const token = req.headers.authorization?.replace("Bearer ", "");

    if (!token) {
      return null;
    }

    const decoded = jwt.verify(token, process.env.JWT_SECRET);

    if (decoded.role !== "admin") {
      return null;
    }

    return decoded;
  } catch (error) {
    console.error("Token verification failed:", error.message);
    return null;
  }
}
</file>

<file path="src/lib/config.js">
export const getBaseUrl = () => {
  if (typeof window !== "undefined") {
    return window.location.origin;
  }
  return process.env.NEXT_PUBLIC_BASE_URL || "http://localhost:3000";
};

export const getSalonUrl = (salonId) => {
  return `${getBaseUrl()}/salons/${salonId}`;
};

export const getBookingUrl = (bookingId) => {
  return `${getBaseUrl()}/bookings/${bookingId}`;
};
</file>

<file path="src/lib/constants.js">
export const USER_ROLES = {
  USER: "user",
  SALON_OWNER: "salon_owner",
  ADMIN: "admin",
  SUPER_ADMIN: "super_admin",
};

export const BOOKING_STATUS = {
  CONFIRMED: "confirmed",
  COMPLETED: "completed",
  CANCELLED: "cancelled",
  NO_SHOW: "no_show",
};

export const PAYMENT_STATUS = {
  PENDING: "pending",
  PAID: "paid",
  FAILED: "failed",
  REFUNDED: "refunded",
};

export const GENDER_OPTIONS = [
  { value: "male", label: "Male" },
  { value: "female", label: "Female" },
  { value: "other", label: "Other" },
];

export const SERVICE_CATEGORIES = {
  HAIR: "hair",
  BEARD: "beard",
  SKIN: "skin",
  NAIL: "nail",
  MASSAGE: "massage",
};

export const RATING_CATEGORIES = [
  { key: "serviceQuality", label: "Service Quality" },
  { key: "timing", label: "Timing/Punctuality" },
  { key: "barberPerformance", label: "Staff Performance" },
  { key: "salonAmbience", label: "Salon Ambience" },
  { key: "overall", label: "Overall Experience" },
];

export const TIME_SLOTS = [
  "09:00",
  "09:30",
  "10:00",
  "10:30",
  "11:00",
  "11:30",
  "12:00",
  "12:30",
  "13:00",
  "13:30",
  "14:00",
  "14:30",
  "15:00",
  "15:30",
  "16:00",
  "16:30",
  "17:00",
  "17:30",
  "18:00",
  "18:30",
  "19:00",
  "19:30",
  "20:00",
  "20:30",
];

export const SEARCH_RADIUS = 5000; // 5km in meters for nearby salon search

export const DEFAULT_SALON_IMAGE = "/images/salon-placeholder.jpg";
export const DEFAULT_BARBER_IMAGE = "/images/barber-placeholder.jpg";
</file>

<file path="src/lib/fetchWithRetry.js">
export async function fetchWithRetry(url, options = {}, maxRetries = 3) {
  let lastError;

  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    try {
      // Check if online before attempting
      if (!navigator.onLine) {
        throw new Error(
          "You are offline. Please check your internet connection."
        );
      }

      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), 15000); // 15s timeout

      const response = await fetch(url, {
        ...options,
        signal: controller.signal,
      });

      clearTimeout(timeoutId);

      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }

      return response;
    } catch (error) {
      lastError = error;

      // Don't retry if offline or on last attempt
      if (!navigator.onLine || attempt === maxRetries) {
        break;
      }

      // Exponential backoff: wait 1s, 2s, 4s...
      await new Promise((resolve) =>
        setTimeout(resolve, 1000 * Math.pow(2, attempt - 1))
      );
    }
  }

  throw lastError;
}

// Usage example in your components
export async function apiCall(endpoint, data) {
  try {
    const response = await fetchWithRetry(`/api/${endpoint}`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(data),
    });
    return await response.json();
  } catch (error) {
    if (!navigator.onLine) {
      alert(
        "📡 You are offline. Please check your internet connection and try again."
      );
    } else {
      alert(`❌ Request failed: ${error.message}`);
    }
    throw error;
  }
}
</file>

<file path="src/lib/maps.js">
// src/lib/maps.js (only the reverseGeocode part shown)
export const geocodeAddress = async (address) => {
  try {
    const res = await fetch("/api/maps/geocode", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ address }),
    });

    if (!res.ok) {
      const err = await res.json().catch(() => ({}));
      throw new Error(err.error || "Geocoding failed");
    }

    const data = await res.json();
    return data; // { coordinates: [lng, lat], formattedAddress: string }
  } catch (error) {
    console.error("Geocoding error:", error);
    throw error;
  }
};

export const reverseGeocode = async (lat, lng) => {
  try {
    const res = await fetch("/api/maps/reverse", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ lat, lng }),
    });

    if (!res.ok) {
      const err = await res.json().catch(() => ({}));
      throw new Error(err.error || "Reverse geocoding failed");
    }

    const data = await res.json();
    return data.address; // string or null
  } catch (error) {
    console.error("Reverse geocoding error:", error);
    throw error;
  }
};
</file>

<file path="src/lib/middleware/requireRole.js">
// lib/middleware/requireRole.js
const jwt = require('jsonwebtoken');
function requireRole(handler, allowedRoles = []) {
  return async (req, res) => {
    try {
      const auth = req.headers.authorization || '';
      const token = auth.replace('Bearer ', '');
      if (!token) return res.status(401).json({ message: 'Token required' });
      const payload = jwt.verify(token, process.env.JWT_SECRET || 'dev_jwt_secret');
      if (!allowedRoles.includes(payload.role)) {
        return res.status(403).json({ message: 'Insufficient privileges' });
      }
      req.user = payload;
      return handler(req, res);
    } catch (err) {
      return res.status(401).json({ message: 'Invalid or missing token', error: String(err) });
    }
  };
}
module.exports = { requireRole };
</file>

<file path="src/lib/qrcode.js">
import QRCode from "qrcode";

export async function generateQRCode(bookingCode) {
  try {
    const qrCodeDataUrl = await QRCode.toDataURL(bookingCode, {
      width: 300,
      margin: 2,
      color: {
        dark: "#000000",
        light: "#FFFFFF",
      },
    });

    return qrCodeDataUrl;
  } catch (error) {
    console.error("QR code generation error:", error);
    return null;
  }
}

export function generateBookingCode() {
  const prefix = "TT";
  const timestamp = Date.now().toString(36).toUpperCase();
  const random = Math.random().toString(36).substring(2, 6).toUpperCase();
  return `${prefix}-${timestamp}${random}`;
}
</file>

<file path="src/lib/rateLimit.js">
// In-memory store for rate limiting (use Redis in large-scale production)
const rateLimit = new Map();

export function checkRateLimit(
  identifier,
  maxAttempts = 3,
  windowMs = 60 * 60 * 1000
) {
  const now = Date.now();
  const key = `reset_${identifier}`;

  // Get existing attempts
  const attempts = rateLimit.get(key) || [];

  // Filter out expired attempts
  const validAttempts = attempts.filter(
    (timestamp) => now - timestamp < windowMs
  );

  // Check if limit exceeded
  if (validAttempts.length >= maxAttempts) {
    const oldestAttempt = Math.min(...validAttempts);
    const timeUntilReset = Math.ceil(
      (windowMs - (now - oldestAttempt)) / 1000 / 60
    );
    return {
      allowed: false,
      remaining: 0,
      resetIn: timeUntilReset,
    };
  }

  // Add current attempt
  validAttempts.push(now);
  rateLimit.set(key, validAttempts);

  // Cleanup old entries periodically
  if (Math.random() < 0.01) {
    cleanupRateLimit(windowMs);
  }

  return {
    allowed: true,
    remaining: maxAttempts - validAttempts.length,
    resetIn: null,
  };
}

function cleanupRateLimit(windowMs) {
  const now = Date.now();
  for (const [key, attempts] of rateLimit.entries()) {
    const validAttempts = attempts.filter(
      (timestamp) => now - timestamp < windowMs
    );
    if (validAttempts.length === 0) {
      rateLimit.delete(key);
    } else {
      rateLimit.set(key, validAttempts);
    }
  }
}
</file>

<file path="src/lib/resetToken.js">
import jwt from "jsonwebtoken";
import crypto from "crypto";

const JWT_SECRET =
  process.env.JWT_SECRET ||
  "your-super-secret-jwt-key-change-this-in-production";
const RESET_TOKEN_EXPIRY = "1h"; // 1 hour

/**
 * Generate JWT-based password reset token
 * Stateless - no DB storage needed
 */
export function generateResetToken(userId, email, currentPasswordHash) {
  // Include password hash in payload so token becomes invalid if password changes
  const payload = {
    userId: userId.toString(),
    email: email.toLowerCase(),
    passwordHash: crypto
      .createHash("sha256")
      .update(currentPasswordHash)
      .digest("hex")
      .substring(0, 16), // First 16 chars of hash
    type: "password_reset",
    iat: Math.floor(Date.now() / 1000),
  };

  const token = jwt.sign(payload, JWT_SECRET, {
    expiresIn: RESET_TOKEN_EXPIRY,
    issuer: "techtrims-auth",
    audience: "password-reset",
  });

  return token;
}

/**
 * Verify and decode reset token
 */
export function verifyResetToken(token, currentPasswordHash) {
  try {
    const decoded = jwt.verify(token, JWT_SECRET, {
      issuer: "techtrims-auth",
      audience: "password-reset",
    });

    // Verify password hasn't changed since token was issued
    const currentHashPrefix = crypto
      .createHash("sha256")
      .update(currentPasswordHash)
      .digest("hex")
      .substring(0, 16);

    if (decoded.passwordHash !== currentHashPrefix) {
      return {
        valid: false,
        error: "Token is no longer valid. Password may have been changed.",
      };
    }

    return {
      valid: true,
      userId: decoded.userId,
      email: decoded.email,
    };
  } catch (error) {
    if (error.name === "TokenExpiredError") {
      return {
        valid: false,
        error: "Reset link has expired. Please request a new one.",
      };
    }
    return {
      valid: false,
      error: "Invalid reset token.",
    };
  }
}
</file>

<file path="src/lib/statsHelper.js">
import clientPromise from "./mongodb";
import { ObjectId } from "mongodb";

// Update salon stats in real-time
export async function updateSalonStats(salonId) {
  try {
    const client = await clientPromise;
    const db = client.db("techtrims");

    const salonObjectId =
      typeof salonId === "string" ? new ObjectId(salonId) : salonId;
    const salonIdStr = salonObjectId.toString();

    // Get all bookings for this salon
    const allBookings = await db
      .collection("bookings")
      .find({
        salonId: { $in: [salonIdStr, salonObjectId] },
      })
      .toArray();

    const completed = allBookings.filter((b) => b.status === "completed");

    // Calculate repeat customers
    const userBookings = {};
    completed.forEach((b) => {
      if (b.userId) {
        const userId =
          typeof b.userId === "string" ? b.userId : b.userId.toString();
        userBookings[userId] = (userBookings[userId] || 0) + 1;
      }
    });
    const repeatCustomers = Object.values(userBookings).filter(
      (count) => count > 1
    ).length;

    // Calculate average wait time
    const waitTimes = completed
      .filter((b) => b.completedAt && b.createdAt)
      .map((b) => {
        const created = new Date(b.createdAt);
        const completedTime = new Date(b.completedAt);
        return (completedTime - created) / (1000 * 60); // minutes
      });
    const averageWaitTime =
      waitTimes.length > 0
        ? Math.round(waitTimes.reduce((a, b) => a + b, 0) / waitTimes.length)
        : 0;

    // Update salon
    await db.collection("salons").updateOne(
      { _id: salonObjectId },
      {
        $set: {
          "stats.totalBookings": allBookings.length,
          "stats.completedBookings": completed.length,
          "stats.repeatCustomers": repeatCustomers,
          "stats.averageWaitTime": averageWaitTime,
          updatedAt: new Date(),
        },
      }
    );

    console.log(`✅ Updated stats for salon ${salonIdStr}`);
    return true;
  } catch (error) {
    console.error("Error updating salon stats:", error);
    return false;
  }
}

// Update salon ratings in real-time
export async function updateSalonRatings(salonId) {
  try {
    const client = await clientPromise;
    const db = client.db("techtrims");

    const salonObjectId =
      typeof salonId === "string" ? new ObjectId(salonId) : salonId;
    const salonIdStr = salonObjectId.toString();

    // Get all feedback bookings
    const feedbackBookings = await db
      .collection("bookings")
      .find({
        salonId: { $in: [salonIdStr, salonObjectId] },
        "feedback.submitted": true,
      })
      .toArray();

    const ratings = {
      overall: 0,
      serviceQuality: 0,
      timing: 0,
      ambience: 0,
      cleanliness: 0,
      totalReviews: feedbackBookings.length,
    };

    if (feedbackBookings.length > 0) {
      [
        "overall",
        "serviceQuality",
        "timing",
        "ambience",
        "cleanliness",
      ].forEach((key) => {
        const sum = feedbackBookings.reduce(
          (acc, b) => acc + (b.feedback.ratings?.[key] || 0),
          0
        );
        ratings[key] = parseFloat((sum / feedbackBookings.length).toFixed(1));
      });
    }

    await db.collection("salons").updateOne(
      { _id: salonObjectId },
      {
        $set: {
          ratings: ratings,
          updatedAt: new Date(),
        },
      }
    );

    console.log(`✅ Updated ratings for salon ${salonIdStr}`);
    return true;
  } catch (error) {
    console.error("Error updating salon ratings:", error);
    return false;
  }
}

// Update barber stats in real-time
export async function updateBarberStats(barberId, barberName, salonId) {
  try {
    const client = await clientPromise;
    const db = client.db("techtrims");

    const barberObjectId =
      typeof barberId === "string" ? new ObjectId(barberId) : barberId;

    // Get all completed bookings for this barber
    const barberBookings = await db
      .collection("bookings")
      .find({
        barber: barberName,
        status: "completed",
      })
      .toArray();

    const totalBookings = barberBookings.length;
    const earnings = barberBookings.reduce((sum, b) => sum + (b.price || 0), 0);

    const ratingsData = barberBookings
      .filter(
        (b) => b.feedback?.submitted && b.feedback.ratings?.barberPerformance
      )
      .map((b) => b.feedback.ratings.barberPerformance);

    const rating =
      ratingsData.length > 0
        ? parseFloat(
            (
              ratingsData.reduce((a, b) => a + b, 0) / ratingsData.length
            ).toFixed(1)
          )
        : 5.0;

    await db.collection("barbers").updateOne(
      { _id: barberObjectId },
      {
        $set: {
          totalBookings,
          earnings,
          rating,
          updatedAt: new Date(),
        },
      }
    );

    console.log(
      `✅ Updated stats for barber ${barberName}: ${totalBookings} bookings, ₹${earnings}`
    );
    return true;
  } catch (error) {
    console.error("Error updating barber stats:", error);
    return false;
  }
}
</file>

<file path="src/lib/utils.js">
export const formatPrice = (price) => {
  return `₹${price.toLocaleString("en-IN")}`;
};

export const formatTime = (time) => {
  return new Date(`2000-01-01 ${time}`).toLocaleString("en-US", {
    hour: "numeric",
    minute: "2-digit",
    hour12: true,
  });
};

export const formatDate = (date) => {
  return new Date(date).toLocaleDateString("en-IN", {
    weekday: "long",
    year: "numeric",
    month: "long",
    day: "numeric",
  });
};

export const calculateDistance = (lat1, lon1, lat2, lon2) => {
  const R = 6371; // Radius of the Earth in kilometers
  const dLat = ((lat2 - lat1) * Math.PI) / 180;
  const dLon = ((lon2 - lon1) * Math.PI) / 180;
  const a =
    Math.sin(dLat / 2) * Math.sin(dLat / 2) +
    Math.cos((lat1 * Math.PI) / 180) *
      Math.cos((lat2 * Math.PI) / 180) *
      Math.sin(dLon / 2) *
      Math.sin(dLon / 2);
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
  const distance = R * c; // Distance in kilometers
  return distance;
};

export const generateUniqueId = () => {
  return Date.now().toString(36) + Math.random().toString(36).substr(2);
};

export const debounce = (func, wait) => {
  let timeout;
  return function executedFunction(...args) {
    const later = () => {
      clearTimeout(timeout);
      func(...args);
    };
    clearTimeout(timeout);
    timeout = setTimeout(later, wait);
  };
};
</file>

<file path="src/lib/validators.js">
export const validateEmail = (email) => {
  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  return emailRegex.test(email);
};

export const validateMobile = (mobile) => {
  const mobileRegex = /^(\+91[\-\s]?)?[0]?(91)?[6789]\d{9}$/;
  return mobileRegex.test(mobile);
};

export const validatePassword = (password) => {
  return password && password.length >= 6;
};

export const validateSalonRegistration = (data) => {
  const errors = {};

  // Owner Details Validation
  if (!data.fullName || data.fullName.trim().length < 2) {
    errors.fullName = "Full name must be at least 2 characters";
  }

  if (!validateMobile(data.mobileNumber)) {
    errors.mobileNumber = "Invalid mobile number format";
  }

  if (!validateEmail(data.email)) {
    errors.email = "Invalid email format";
  }

  if (!validatePassword(data.password)) {
    errors.password = "Password must be at least 6 characters";
  }

  // Salon Details Validation
  if (!data.salonName || data.salonName.trim().length < 2) {
    errors.salonName = "Salon name must be at least 2 characters";
  }

  if (!data.address || data.address.trim().length < 10) {
    errors.address = "Address must be at least 10 characters";
  }

  // Services Validation
  const enabledServices = Object.entries(data.services || {})
    .filter(([_, service]) => service.enabled)
    .map(([key, service]) => ({ key, ...service }));

  if (enabledServices.length === 0) {
    errors.services = "At least one service must be enabled";
  }

  enabledServices.forEach((service) => {
    if (!service.price || service.price < 1) {
      errors[`service_${service.key}`] = "Service price must be greater than 0";
    }
  });

  return {
    isValid: Object.keys(errors).length === 0,
    errors,
  };
};

export const validateBooking = (data) => {
  const errors = {};

  if (!data.salonId) {
    errors.salonId = "Salon selection is required";
  }

  if (!data.barberName) {
    errors.barberName = "Barber selection is required";
  }

  if (!data.service) {
    errors.service = "Service selection is required";
  }
  if (!data.scheduledTime && !data.timeSlot) {
    errors.scheduledTime = "Time slot selection is required";
  } else if (!data.scheduledTime && data.timeSlot) {
    // normalize: if client sent timeSlot, map it to scheduledTime for downstream code
    data.scheduledTime = data.timeSlot;
  }

  if (!data.userDetails?.name) {
    errors.userName = "Name is required";
  }

  if (!validateMobile(data.userDetails?.mobile)) {
    errors.userMobile = "Valid mobile number is required";
  }

  return {
    isValid: Object.keys(errors).length === 0,
    errors,
  };
};
</file>

<file path="src/lib/walkinHelpers.js">
import { ObjectId } from "mongodb";

export async function calculateWaitTime(db, barberId) {
  try {
    // Get barber's current service time left
    const barber = await db.collection("barbers").findOne({
      _id: new ObjectId(barberId),
    });

    if (!barber) return 0;

    let timeLeft = 0;

    // If barber is currently serving someone
    if (
      barber.currentBookingId &&
      barber.currentServiceStartTime &&
      barber.currentServiceEndTime
    ) {
      const now = new Date();
      const endTime = new Date(barber.currentServiceEndTime);
      timeLeft = Math.max(0, Math.ceil((endTime - now) / 1000 / 60)); // minutes
    }

    // Get queue count
    const queueCount = await db.collection("walkinbookings").countDocuments({
      barberId: new ObjectId(barberId),
      queueStatus: "ORANGE",
      isExpired: false,
    });

    // Estimated wait = time left + (queue * 45 mins average)
    const estimatedWait = timeLeft + queueCount * 45;

    return estimatedWait;
  } catch (error) {
    console.error("Calculate wait time error:", error);
    return 0;
  }
}

export async function updateBarberStatus(db, barberId) {
  try {
    const barber = await db.collection("barbers").findOne({
      _id: new ObjectId(barberId),
    });

    if (!barber) return;

    // Check if current service has ended
    if (barber.currentServiceEndTime) {
      const now = new Date();
      const endTime = new Date(barber.currentServiceEndTime);

      if (now >= endTime) {
        // Service should be done, auto-complete it
        if (barber.currentBookingId) {
          await db.collection("walkinbookings").updateOne(
            { _id: barber.currentBookingId },
            {
              $set: {
                queueStatus: "COMPLETED",
                serviceEndedAt: now,
              },
            }
          );
        }

        // Reset barber to available
        await db.collection("barbers").updateOne(
          { _id: new ObjectId(barberId) },
          {
            $set: {
              currentStatus: "AVAILABLE",
              currentBookingId: null,
              currentServiceStartTime: null,
              currentServiceEndTime: null,
            },
          }
        );
      }
    }
  } catch (error) {
    console.error("Update barber status error:", error);
  }
}
</file>

<file path="src/models/Feedback.js">
// models/Feedback.js
export class Feedback {
  constructor(data) {
    this.bookingId = data.bookingId;
    this.userId = data.userId;
    this.salonId = data.salonId;
    this.ratings = {
      serviceQuality: data.ratings.serviceQuality,
      timing: data.ratings.timing,
      barberPerformance: data.ratings.barberPerformance,
      salonAmbience: data.ratings.salonAmbience,
      overall: data.ratings.overall,
    };
    this.comment = data.comment || "";
    this.isPublic = data.isPublic !== undefined ? data.isPublic : true;
    this.createdAt = new Date();
  }

  static async create(feedbackData) {
    const { db } = await connectToDatabase();
    const feedback = new Feedback(feedbackData);
    const result = await db.collection("feedback").insertOne(feedback);
    return { ...feedback, _id: result.insertedId };
  }

  static async findBySalonId(salonId, options = {}) {
    const { db } = await connectToDatabase();
    const query = {
      salonId,
      isPublic: true,
    };

    let cursor = db.collection("feedback").find(query);

    if (options.sort) {
      cursor = cursor.sort(options.sort);
    } else {
      cursor = cursor.sort({ createdAt: -1 });
    }

    if (options.limit) {
      cursor = cursor.limit(options.limit);
    }

    return await cursor.toArray();
  }

  static async getSalonAverageRatings(salonId) {
    const { db } = await connectToDatabase();

    const pipeline = [
      {
        $match: {
          salonId,
          isPublic: true,
        },
      },
      {
        $group: {
          _id: null,
          avgServiceQuality: { $avg: "$ratings.serviceQuality" },
          avgTiming: { $avg: "$ratings.timing" },
          avgBarberPerformance: { $avg: "$ratings.barberPerformance" },
          avgSalonAmbience: { $avg: "$ratings.salonAmbience" },
          avgOverall: { $avg: "$ratings.overall" },
          totalReviews: { $sum: 1 },
        },
      },
    ];

    const result = await db
      .collection("feedback")
      .aggregate(pipeline)
      .toArray();
    return result[0] || null;
  }
}
</file>

<file path="src/models/Salon.js">
// models/Salon.js
export class Salon {
  constructor(data) {
    this.ownerDetails = {
      name: data.ownerDetails.name,
      mobile: data.ownerDetails.mobile,
      email: data.ownerDetails.email,
      password: data.ownerDetails.password, // Should be hashed
    };
    this.salonDetails = {
      name: data.salonDetails.name,
      address: data.salonDetails.address,
      location: data.salonDetails.location || {
        type: "Point",
        coordinates: [0, 0],
      },
      openingHours: data.salonDetails.openingHours || {
        open: "09:00",
        close: "21:00",
      },
      images: data.salonDetails.images || [],
      description: data.salonDetails.description || "",
    };
    this.services = data.services || [];
    this.barbers = data.barbers || [];
    this.ratings = data.ratings || {
      overall: 5.0,
      totalReviews: 0,
      serviceQuality: 5.0,
      timing: 5.0,
      cleanliness: 5.0,
      ambience: 5.0,
    };
    this.stats = data.stats || {
      totalBookings: 0,
      repeatCustomers: 0,
      averageWaitTime: 10,
    };
    this.isActive = data.isActive !== undefined ? data.isActive : true;
    this.createdAt = new Date();
    this.updatedAt = new Date();
  }

  static async create(salonData) {
    const { db } = await connectToDatabase();
    const salon = new Salon(salonData);

    // Create geospatial index for location-based queries
    await db
      .collection("salons")
      .createIndex({ "salonDetails.location": "2dsphere" });

    const result = await db.collection("salons").insertOne(salon);
    return { ...salon, _id: result.insertedId };
  }

  static async findById(id) {
    const { db } = await connectToDatabase();
    return await db.collection("salons").findOne({ _id: new ObjectId(id) });
  }

  static async findByOwnerEmail(email) {
    const { db } = await connectToDatabase();
    return await db
      .collection("salons")
      .findOne({ "ownerDetails.email": email });
  }

  static async findNearby(coordinates, radius = 5000, options = {}) {
    const { db } = await connectToDatabase();

    const pipeline = [
      {
        $geoNear: {
          near: {
            type: "Point",
            coordinates: coordinates, // [longitude, latitude]
          },
          distanceField: "distance",
          maxDistance: radius,
          spherical: true,
        },
      },
      {
        $match: { isActive: true },
      },
    ];

    // Add gender-based service filtering if specified
    if (options.gender) {
      pipeline.push({
        $addFields: {
          relevantServices: {
            $filter: {
              input: "$services",
              cond: {
                $or: [
                  { $eq: ["$$this.genderSpecific", "unisex"] },
                  { $eq: ["$$this.genderSpecific", options.gender] },
                ],
              },
            },
          },
        },
      });
    }

    pipeline.push(
      {
        $addFields: {
          topServices: { $slice: ["$relevantServices", 4] },
          distanceKm: { $round: [{ $divide: ["$distance", 1000] }, 1] },
        },
      },
      {
        $project: {
          "ownerDetails.password": 0,
        },
      },
      { $limit: options.limit || 20 }
    );

    return await db.collection("salons").aggregate(pipeline).toArray();
  }

  static async updateById(id, updateData) {
    const { db } = await connectToDatabase();
    const result = await db.collection("salons").updateOne(
      { _id: new ObjectId(id) },
      {
        $set: {
          ...updateData,
          updatedAt: new Date(),
        },
      }
    );
    return result.modifiedCount > 0;
  }

  static async incrementBookingCount(id) {
    const { db } = await connectToDatabase();
    return await db.collection("salons").updateOne(
      { _id: new ObjectId(id) },
      {
        $inc: { "stats.totalBookings": 1 },
        $set: { updatedAt: new Date() },
      }
    );
  }

  static async updateRatings(id, newRatings) {
    const { db } = await connectToDatabase();
    return await db.collection("salons").updateOne(
      { _id: new ObjectId(id) },
      {
        $set: {
          "ratings.overall": newRatings.overall,
          "ratings.serviceQuality": newRatings.serviceQuality,
          "ratings.timing": newRatings.timing,
          "ratings.cleanliness": newRatings.cleanliness,
          "ratings.ambience": newRatings.ambience,
          "ratings.totalReviews": newRatings.totalReviews,
          updatedAt: new Date(),
        },
      }
    );
  }
}
</file>

<file path="src/models/Service.js">
// models/Service.js
import mongoose from "mongoose";

const ServiceSchema = new mongoose.Schema(
  {
    salonId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "Salon",
      required: true,
      index: true,
    },
    title: { type: String, required: true },
    description: { type: String, default: "" },
    durationMinutes: { type: Number, default: 30 },
    price: { type: Number, required: true },
    isActive: { type: Boolean, default: true },
    createdAt: { type: Date, default: Date.now },
  },
  { timestamps: true }
);

export default mongoose.models.Service ||
  mongoose.model("Service", ServiceSchema);
</file>

<file path="src/models/Staff.js">
// models/Staff.js
import mongoose from "mongoose";

const StaffSchema = new mongoose.Schema(
  {
    salonId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "Salon",
      required: true,
      index: true,
    },
    name: { type: String, required: true },
    skills: [{ type: String }],
    workingHours: {
      start: { type: String, default: "09:00" },
      end: { type: String, default: "21:00" },
    },
    photo: { type: String, default: "" },
    bio: { type: String, default: "" },
    isAvailable: { type: Boolean, default: true },
    earnings: { type: Number, default: 0 },
  },
  { timestamps: true }
);

export default mongoose.models.Staff || mongoose.model("Staff", StaffSchema);
</file>

<file path="src/models/User.js">
// models/User.js
import { connectToDatabase } from "../lib/mongodb";
import { ObjectId } from "mongodb";

export class User {
  constructor(data) {
    this.name = data.name;
    this.mobile = data.mobile;
    this.email = data.email || null;
    this.gender = data.gender || "male";
    this.location = data.location || null;
    this.preferences = data.preferences || {
      favoriteServices: [],
      preferredPriceRange: { min: 0, max: 2000 },
    };
    this.bookingHistory = data.bookingHistory || [];
    this.createdAt = new Date();
    this.updatedAt = new Date();
  }

  static async create(userData) {
    const { db } = await connectToDatabase();
    const user = new User(userData);
    const result = await db.collection("users").insertOne(user);
    return { ...user, _id: result.insertedId };
  }

  static async findById(id) {
    const { db } = await connectToDatabase();
    return await db.collection("users").findOne({ _id: new ObjectId(id) });
  }

  static async findByMobile(mobile) {
    const { db } = await connectToDatabase();
    return await db.collection("users").findOne({ mobile });
  }

  static async findByEmail(email) {
    const { db } = await connectToDatabase();
    return await db.collection("users").findOne({ email });
  }

  static async updateById(id, updateData) {
    const { db } = await connectToDatabase();
    const result = await db.collection("users").updateOne(
      { _id: new ObjectId(id) },
      {
        $set: {
          ...updateData,
          updatedAt: new Date(),
        },
      }
    );
    return result.modifiedCount > 0;
  }

  static async addBookingToHistory(userId, bookingId) {
    const { db } = await connectToDatabase();
    return await db.collection("users").updateOne(
      { _id: new ObjectId(userId) },
      {
        $push: { bookingHistory: bookingId },
        $set: { updatedAt: new Date() },
      }
    );
  }
}
</file>

<file path="src/models/WalkinBooking.js">
import mongoose from "mongoose";

const WalkinBookingSchema = new mongoose.Schema(
  {
    salonId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "Salon",
      required: true,
      index: true,
    },

    barberId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "Barber",
      required: true,
      index: true,
    },

    // Customer Info
    customerName: {
      type: String,
      required: true,
    },

    customerPhone: {
      type: String,
      required: true,
    },

    // Service
    service: {
      type: String,
      required: true,
    },

    // Unique Booking Identifier
    bookingCode: {
      type: String,
      unique: true,
      required: true,
      index: true,
    },

    qrCodeData: {
      type: String, // Base64 encoded QR code
    },

    // Queue Status: RED → ORANGE → GREEN → COMPLETED
    queueStatus: {
      type: String,
      enum: ["RED", "ORANGE", "GREEN", "COMPLETED", "EXPIRED"],
      default: "RED",
      index: true,
    },

    // Timestamps
    expiresAt: {
      type: Date,
      required: true, // 45 minutes from creation
    },

    arrivedAt: {
      type: Date,
      default: null,
    },

    serviceStartedAt: {
      type: Date,
      default: null,
    },

    serviceEndedAt: {
      type: Date,
      default: null,
    },

    // Duration (in minutes)
    estimatedDuration: {
      type: Number,
      required: true,
    },

    selectedDuration: {
      type: Number, // Barber selects this when starting
      default: null,
    },

    actualDuration: {
      type: Number,
      default: null,
    },

    isExpired: {
      type: Boolean,
      default: false,
    },
  },
  { timestamps: true }
);

export default mongoose.models.WalkinBooking ||
  mongoose.model("WalkinBooking", WalkinBookingSchema);
</file>

<file path="src/pages/admin/analytics.js">
import { useState, useEffect } from "react";
import { useRouter } from "next/router";
import AdminLayout from "../../components/Admin/AdminLayout";
import styles from "../../styles/Admin/AdminAnalytics.module.css";

export default function AdminAnalytics() {
  const router = useRouter();
  const [analytics, setAnalytics] = useState(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    const token = localStorage.getItem("adminToken");
    if (!token) {
      router.push("/admin/login");
      return;
    }
    fetchAnalytics();
  }, [router]);

  const fetchAnalytics = async () => {
    try {
      const token = localStorage.getItem("adminToken");
      const response = await fetch("/api/admin/analytics", {
        headers: { Authorization: `Bearer ${token}` },
      });
      const data = await response.json();
      setAnalytics(data);
    } catch (error) {
      console.error("Error fetching analytics:", error);
    } finally {
      setLoading(false);
    }
  };

  if (loading) {
    return (
      <AdminLayout>
        <div className={styles.loading}>Loading analytics...</div>
      </AdminLayout>
    );
  }

  return (
    <AdminLayout>
      <div className={styles.container}>
        <h1 className={styles.title}>Analytics & Insights</h1>

        {/* Trends Section */}
        <div className={styles.section}>
          <h2>Customer Behavior Trends</h2>
          <div className={styles.trendsGrid}>
            <div className={styles.trendCard}>
              <h3>Peak Booking Hours</h3>
              <ul>
                {analytics?.peakHours?.map((hour) => (
                  <li key={hour.hour}>
                    <strong>{hour.hour}</strong> - {hour.count} bookings
                  </li>
                ))}
              </ul>
            </div>

            <div className={styles.trendCard}>
              <h3>Popular Services</h3>
              <ul>
                {analytics?.popularServices?.map((service) => (
                  <li key={service.name}>
                    <strong>{service.name}</strong> - {service.count} bookings
                  </li>
                ))}
              </ul>
            </div>

            <div className={styles.trendCard}>
              <h3>Day-wise Trends</h3>
              <ul>
                {analytics?.dayTrends?.map((day) => (
                  <li key={day.day}>
                    <strong>{day.day}</strong> - {day.bookings} bookings
                  </li>
                ))}
              </ul>
            </div>
          </div>
        </div>

        {/* Top Salons Section */}
        <div className={styles.section}>
          <h2>Top Performing Salons</h2>
          <div className={styles.topSalons}>
            {analytics?.topSalons?.map((salon, index) => (
              <div key={salon._id} className={styles.salonRankCard}>
                <div className={styles.rank}>#{index + 1}</div>
                <div className={styles.salonInfo}>
                  <h3>{salon.salonName}</h3>
                  <p>📅 {salon.totalBookings} bookings</p>
                  <p>⭐ {salon.rating.toFixed(1)} rating</p>
                  <p>📍 {salon.location?.address || "Location not set"}</p>
                </div>
              </div>
            ))}
          </div>
        </div>

        {/* Customer Insights */}
        <div className={styles.section}>
          <h2>Customer Insights</h2>
          <div className={styles.insights}>
            <div className={styles.insightCard}>
              <h3>Repeat Customer Rate</h3>
              <p className={styles.percentage}>{analytics?.repeatRate}%</p>
            </div>
            <div className={styles.insightCard}>
              <h3>Average Booking Value</h3>
              <p className={styles.amount}>₹{analytics?.avgBookingValue}</p>
            </div>
            <div className={styles.insightCard}>
              <h3>Customer Satisfaction</h3>
              <p className={styles.rating}>⭐ {analytics?.avgRating}/5</p>
            </div>
          </div>
        </div>
      </div>
    </AdminLayout>
  );
}
</file>

<file path="src/pages/admin/dashboard.js">
import { useState, useEffect } from "react";
import { useRouter } from "next/router";
import AdminLayout from "../../components/Admin/AdminLayout";
import StatsCards from "../../components/Admin/StatsCards";
import styles from "../../styles/Admin/AdminDashboard.module.css";

export default function AdminDashboard() {
  const router = useRouter();
  const [stats, setStats] = useState(null);
  const [loading, setLoading] = useState(true);
  const [adminData, setAdminData] = useState(null);

  useEffect(() => {
    const token = localStorage.getItem("adminToken");
    const admin = localStorage.getItem("adminData");

    if (!token) {
      router.push("/admin/login");
      return;
    }

    setAdminData(JSON.parse(admin));
    fetchDashboardStats();
  }, []);

  const fetchDashboardStats = async () => {
    try {
      const token = localStorage.getItem("adminToken");
      const response = await fetch("/api/admin/dashboard/stats", {
        headers: { Authorization: `Bearer ${token}` },
      });

      const data = await response.json();
      setStats(data);
    } catch (error) {
      console.error("Error fetching stats:", error);
    } finally {
      setLoading(false);
    }
  };

  if (loading) {
    return (
      <AdminLayout>
        <div className={styles.loading}>Loading dashboard...</div>
      </AdminLayout>
    );
  }

  return (
    <AdminLayout>
      <div className={styles.dashboard}>
        <div className={styles.header}>
          <h1 className={styles.title}>
            Welcome back, {adminData?.name || "Admin"}
          </h1>
          <p className={styles.subtitle}>
            Here&#39;s what&#39;s happening with TechTrims today
          </p>
        </div>

        <StatsCards stats={stats} />

        {/* Quick Actions */}
        <div className={styles.quickActions}>
          <h2>Quick Actions</h2>
          <div className={styles.actionsGrid}>
            <button
              onClick={() => router.push("/admin/salons")}
              className={styles.actionCard}
            >
              <span className={styles.actionIcon}>🏢</span>
              <span>Manage Salons</span>
            </button>
            <button
              onClick={() => router.push("/admin/users")}
              className={styles.actionCard}
            >
              <span className={styles.actionIcon}>👥</span>
              <span>View Users</span>
            </button>
            <button
              onClick={() => router.push("/admin/revenue")}
              className={styles.actionCard}
            >
              <span className={styles.actionIcon}>💰</span>
              <span>Revenue</span>
            </button>
            <button
              onClick={() => router.push("/admin/reports")}
              className={styles.actionCard}
            >
              <span className={styles.actionIcon}>📊</span>
              <span>Generate Report</span>
            </button>
          </div>
        </div>

        {/* Recent Activity */}
        <div className={styles.recentActivity}>
          <h2>Recent Activity</h2>
          <div className={styles.activityList}>
            {stats?.recentBookings?.slice(0, 5).map((booking) => (
              <div key={booking._id} className={styles.activityItem}>
                <span className={styles.activityIcon}>📅</span>
                <div className={styles.activityDetails}>
                  <p className={styles.activityText}>
                    <strong>{booking.customerName}</strong> booked{" "}
                    {booking.service}
                  </p>
                  <p className={styles.activityTime}>
                    {new Date(booking.createdAt).toLocaleString()}
                  </p>
                </div>
              </div>
            ))}
          </div>
        </div>
      </div>
    </AdminLayout>
  );
}
</file>

<file path="src/pages/admin/login.js">
import { useState } from "react";
import { useRouter } from "next/router";
import styles from "../../styles/Admin/AdminLogin.module.css";

export default function AdminLoginPage() {
  const router = useRouter();
  const [credentials, setCredentials] = useState({
    username: "",
    password: "",
  });
  const [error, setError] = useState("");
  const [isLoading, setIsLoading] = useState(false);

  const handleSubmit = async (e) => {
    e.preventDefault();
    setIsLoading(true);
    setError("");

    try {
      const response = await fetch("/api/auth/admin/login", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(credentials),
      });

      const data = await response.json();

      if (response.ok) {
        localStorage.setItem("adminToken", data.token);
        localStorage.setItem("adminData", JSON.stringify(data.admin));
        router.push("/admin/dashboard");
      } else {
        setError(data.message || "Login failed");
      }
    } catch (error) {
      setError("Network error. Please try again.");
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <div className={styles.container}>
      <div className={styles.loginCard}>
        <div className={styles.header}>
          <h1 className={styles.title}>🔐 Admin Portal</h1>
          <p className={styles.subtitle}>TechTrims Management Dashboard</p>
        </div>

        {error && <div className={styles.error}>{error}</div>}

        <form onSubmit={handleSubmit} className={styles.form}>
          <div className={styles.formGroup}>
            <label htmlFor="username">Admin Username</label>
            <input
              id="username"
              type="text"
              placeholder="Enter admin username"
              value={credentials.username}
              onChange={(e) =>
                setCredentials({ ...credentials, username: e.target.value })
              }
              required
            />
          </div>

          <div className={styles.formGroup}>
            <label htmlFor="password">Password</label>
            <input
              id="password"
              type="password"
              placeholder="Enter password"
              value={credentials.password}
              onChange={(e) =>
                setCredentials({ ...credentials, password: e.target.value })
              }
              required
            />
          </div>

          <button
            type="submit"
            className={styles.submitButton}
            disabled={isLoading}
          >
            {isLoading ? "Logging in..." : "Login to Dashboard"}
          </button>
        </form>
      </div>
    </div>
  );
}
</file>

<file path="src/pages/admin/reports.js">
import { useState, useEffect } from "react";
import { useRouter } from "next/router";
import AdminLayout from "../../components/Admin/AdminLayout";
import styles from "../../styles/Admin/AdminReports.module.css";

export default function AdminReports() {
  const router = useRouter();
  const [loading, setLoading] = useState(false);
  const [reportType, setReportType] = useState("comprehensive");
  const [dateRange, setDateRange] = useState({ start: "", end: "" });

  useEffect(() => {
    const token = localStorage.getItem("adminToken");
    if (!token) {
      router.push("/admin/login");
      return;
    }
  }, []);

  const generateReport = async () => {
    setLoading(true);
    try {
      const token = localStorage.getItem("adminToken");
      const response = await fetch("/api/admin/reports/generate", {
        method: "POST",
        headers: {
          Authorization: `Bearer ${token}`,
          "Content-Type": "application/json",
        },
        body: JSON.stringify({ reportType, dateRange }),
      });

      const blob = await response.blob();
      const url = window.URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = `TechTrims_Report_${reportType}_${Date.now()}.pdf`;
      document.body.appendChild(a);
      a.click();
      window.URL.revokeObjectURL(url);
      document.body.removeChild(a);

      alert("Report generated successfully!");
    } catch (error) {
      console.error("Error generating report:", error);
      alert("Failed to generate report");
    } finally {
      setLoading(false);
    }
  };

  return (
    <AdminLayout>
      <div className={styles.container}>
        <h1>Report Generation</h1>
        <p className={styles.subtitle}>
          Generate comprehensive PDF reports for all data
        </p>

        <div className={styles.reportForm}>
          <div className={styles.formGroup}>
            <label>Report Type</label>
            <select
              value={reportType}
              onChange={(e) => setReportType(e.target.value)}
            >
              <option value="comprehensive">
                Comprehensive Report (All Data)
              </option>
              <option value="salons">Salons Report</option>
              <option value="users">Users Report</option>
              <option value="bookings">Bookings Report</option>
              <option value="revenue">Revenue Report</option>
              <option value="analytics">Analytics Report</option>
            </select>
          </div>

          <div className={styles.formGroup}>
            <label>Date Range (Optional)</label>
            <div className={styles.dateRange}>
              <input
                type="date"
                value={dateRange.start}
                onChange={(e) =>
                  setDateRange({ ...dateRange, start: e.target.value })
                }
              />
              <span>to</span>
              <input
                type="date"
                value={dateRange.end}
                onChange={(e) =>
                  setDateRange({ ...dateRange, end: e.target.value })
                }
              />
            </div>
          </div>

          <button
            className={styles.generateBtn}
            onClick={generateReport}
            disabled={loading}
          >
            {loading ? "Generating PDF..." : "📄 Generate Report"}
          </button>
        </div>

        <div className={styles.reportInfo}>
          <h3>Report Contents</h3>
          <ul>
            <li>✅ All registered salons with complete details</li>
            <li>✅ User statistics and demographics</li>
            <li>✅ Booking trends and analytics</li>
            <li>✅ Revenue breakdown and payments</li>
            <li>✅ Performance metrics and insights</li>
            <li>✅ Charts and visualizations</li>
          </ul>
        </div>
      </div>
    </AdminLayout>
  );
}
</file>

<file path="src/pages/admin/revenue.js">
import { useState, useEffect } from "react";
import { useRouter } from "next/router";
import AdminLayout from "../../components/Admin/AdminLayout";
import styles from "../../styles/Admin/AdminRevenue.module.css";

export default function AdminRevenue() {
  const router = useRouter();
  const [revenueData, setRevenueData] = useState(null);
  const [salons, setSalons] = useState([]);
  const [loading, setLoading] = useState(true);
  const [filterMonth, setFilterMonth] = useState("all");

  useEffect(() => {
    const token = localStorage.getItem("adminToken");
    if (!token) {
      router.push("/admin/login");
      return;
    }
    fetchRevenueData();
  }, [filterMonth]);

  const fetchRevenueData = async () => {
    try {
      const token = localStorage.getItem("adminToken");
      const response = await fetch(`/api/admin/revenue?month=${filterMonth}`, {
        headers: { Authorization: `Bearer ${token}` },
      });
      const data = await response.json();
      setRevenueData(data.summary);
      setSalons(data.salons || []);
    } catch (error) {
      console.error("Error fetching revenue:", error);
    } finally {
      setLoading(false);
    }
  };

  if (loading) {
    return (
      <AdminLayout>
        <div className={styles.loading}>Loading revenue data...</div>
      </AdminLayout>
    );
  }

  return (
    <AdminLayout>
      <div className={styles.container}>
        <div className={styles.header}>
          <h1>Revenue Management</h1>
          <p className={styles.subtitle}>
            Track payments and earnings from all salons
          </p>
        </div>

        {/* Filter */}
        <div className={styles.filters}>
          <select
            value={filterMonth}
            onChange={(e) => setFilterMonth(e.target.value)}
          >
            <option value="all">All Time</option>
            <option value="current">Current Month</option>
            <option value="last">Last Month</option>
          </select>
        </div>

        {/* Summary Cards */}
        <div className={styles.summaryCards}>
          <div className={styles.card}>
            <h3>Total Revenue</h3>
            <p className={styles.amount}>₹{revenueData?.totalRevenue || 0}</p>
          </div>
          <div className={styles.card}>
            <h3>Collected</h3>
            <p className={styles.amount}>₹{revenueData?.collected || 0}</p>
          </div>
          <div className={styles.card}>
            <h3>Pending</h3>
            <p className={styles.amount}>₹{revenueData?.pending || 0}</p>
          </div>
          <div className={styles.card}>
            <h3>Salon Count</h3>
            <p className={styles.count}>{salons.length}</p>
          </div>
        </div>

        {/* Salons Revenue Table */}
        <div className={styles.tableContainer}>
          <h2>Salon-wise Revenue Breakdown</h2>
          <table className={styles.table}>
            <thead>
              <tr>
                <th>Salon Name</th>
                <th>Owner</th>
                <th>Total Bookings</th>
                <th>Total Revenue</th>
                <th>Commission (15%)</th>
                <th>Paid</th>
                <th>Balance</th>
                <th>Registered</th>
                <th>Actions</th>
              </tr>
            </thead>
            <tbody>
              {salons.map((salon) => (
                <tr key={salon._id}>
                  <td className={styles.salonName}>{salon.salonName}</td>
                  <td>{salon.ownerName}</td>
                  <td>{salon.totalBookings}</td>
                  <td>₹{salon.totalRevenue}</td>
                  <td>₹{salon.commission}</td>
                  <td className={styles.paid}>₹{salon.paid}</td>
                  <td className={styles.balance}>₹{salon.balance}</td>
                  <td>{new Date(salon.createdAt).toLocaleDateString()}</td>
                  <td>
                    <button className={styles.viewBtn}>Details</button>
                  </td>
                </tr>
              ))}
            </tbody>
          </table>
        </div>
      </div>
    </AdminLayout>
  );
}
</file>

<file path="src/pages/admin/salons.js">
import { useState, useEffect, useCallback } from "react";
import { useRouter } from "next/router";
import AdminLayout from "../../components/Admin/AdminLayout";
import SalonDetailsModal from "../../components/Admin/SalonDetailsModal";
import styles from "../../styles/Admin/AdminSalons.module.css";

export default function AdminSalons() {
  const router = useRouter();
  const [salons, setSalons] = useState([]);
  const [filteredSalons, setFilteredSalons] = useState([]);
  const [selectedSalon, setSelectedSalon] = useState(null);
  const [loading, setLoading] = useState(true);
  const [searchTerm, setSearchTerm] = useState("");
  const [filterStatus, setFilterStatus] = useState("all");

  useEffect(() => {
    const token = localStorage.getItem("adminToken");
    if (!token) {
      router.push("/admin/login");
      return;
    }
    fetchSalons();
  }, [router]);

  const filterSalonsList = useCallback(() => {
    let filtered = salons;

    if (searchTerm) {
      filtered = filtered.filter(
        (salon) =>
          salon.salonName?.toLowerCase().includes(searchTerm.toLowerCase()) ||
          salon.ownerName?.toLowerCase().includes(searchTerm.toLowerCase()) ||
          salon.email?.toLowerCase().includes(searchTerm.toLowerCase())
      );
    }

    if (filterStatus !== "all") {
      filtered = filtered.filter((salon) =>
        filterStatus === "active" ? salon.isActive : !salon.isActive
      );
    }

    setFilteredSalons(filtered);
  }, [searchTerm, filterStatus, salons]);

  useEffect(() => {
    filterSalonsList();
  }, [filterSalonsList]);

  const fetchSalons = async () => {
    try {
      const token = localStorage.getItem("adminToken");
      const response = await fetch("/api/admin/salons", {
        headers: { Authorization: `Bearer ${token}` },
      });
      const data = await response.json();
      setSalons(data.salons || []);
    } catch (error) {
      console.error("Error fetching salons:", error);
    } finally {
      setLoading(false);
    }
  };

  const toggleSalonStatus = async (salonId, currentStatus) => {
    try {
      const token = localStorage.getItem("adminToken");
      const response = await fetch(
        `/api/admin/salons/${salonId}/toggle-status`,
        {
          method: "PUT",
          headers: {
            Authorization: `Bearer ${token}`,
            "Content-Type": "application/json",
          },
          body: JSON.stringify({ isActive: !currentStatus }),
        }
      );

      if (response.ok) {
        fetchSalons();
        alert(
          `Salon ${!currentStatus ? "activated" : "deactivated"} successfully`
        );
      }
    } catch (error) {
      console.error("Error toggling salon status:", error);
    }
  };

  if (loading) {
    return (
      <AdminLayout>
        <div className={styles.loading}>Loading salons...</div>
      </AdminLayout>
    );
  }

  return (
    <AdminLayout>
      <div className={styles.container}>
        <div className={styles.header}>
          <h1>Salon Management</h1>
          <p className={styles.subtitle}>Total Salons: {salons.length}</p>
        </div>

        {/* Filters */}
        <div className={styles.filters}>
          <div className={styles.searchBox}>
            <input
              type="text"
              placeholder="Search by name, owner, or email..."
              value={searchTerm}
              onChange={(e) => setSearchTerm(e.target.value)}
            />
          </div>

          <div className={styles.statusFilter}>
            <select
              value={filterStatus}
              onChange={(e) => setFilterStatus(e.target.value)}
            >
              <option value="all">All Status</option>
              <option value="active">Active</option>
              <option value="inactive">Inactive</option>
            </select>
          </div>
        </div>

        {/* Salons Table */}
        <div className={styles.tableContainer}>
          <table className={styles.table}>
            <thead>
              <tr>
                <th>Salon Name</th>
                <th>Owner</th>
                <th>Email</th>
                <th>Phone</th>
                <th>Bookings</th>
                <th>Rating</th>
                <th>Status</th>
                <th>Registered</th>
                <th>Actions</th>
              </tr>
            </thead>
            <tbody>
              {filteredSalons.map((salon) => (
                <tr key={salon._id}>
                  <td className={styles.salonName}>{salon.salonName}</td>
                  <td>{salon.ownerName}</td>
                  <td>{salon.email}</td>
                  <td>{salon.phone}</td>
                  <td>{salon.stats?.totalBookings || 0}</td>
                  <td>
                    <span className={styles.rating}>
                      ⭐ {(salon.ratings?.overall || 5.0).toFixed(1)}
                    </span>
                  </td>
                  <td>
                    <span
                      className={`${styles.status} ${
                        salon.isActive ? styles.active : styles.inactive
                      }`}
                    >
                      {salon.isActive ? "Active" : "Inactive"}
                    </span>
                  </td>
                  <td>{new Date(salon.createdAt).toLocaleDateString()}</td>
                  <td>
                    <div className={styles.actions}>
                      <button
                        className={styles.viewBtn}
                        onClick={() => setSelectedSalon(salon)}
                      >
                        View
                      </button>
                      <button
                        className={styles.toggleBtn}
                        onClick={() =>
                          toggleSalonStatus(salon._id, salon.isActive)
                        }
                      >
                        {salon.isActive ? "Deactivate" : "Activate"}
                      </button>
                    </div>
                  </td>
                </tr>
              ))}
            </tbody>
          </table>

          {filteredSalons.length === 0 && (
            <div className={styles.noData}>No salons found</div>
          )}
        </div>
      </div>

      {selectedSalon && (
        <SalonDetailsModal
          salon={selectedSalon}
          onClose={() => setSelectedSalon(null)}
        />
      )}
    </AdminLayout>
  );
}
</file>

<file path="src/pages/admin/users.js">
import { useState, useEffect } from "react";
import { useRouter } from "next/router";
import AdminLayout from "../../components/Admin/AdminLayout";
import UserDetailsModal from "../../components/Admin/UserDetailsModal";
import styles from "../../styles/Admin/AdminUsers.module.css";

export default function AdminUsers() {
  const router = useRouter();
  const [users, setUsers] = useState([]);
  const [filteredUsers, setFilteredUsers] = useState([]);
  const [selectedUser, setSelectedUser] = useState(null);
  const [loading, setLoading] = useState(true);
  const [searchTerm, setSearchTerm] = useState("");

  useEffect(() => {
    const token = localStorage.getItem("adminToken");
    if (!token) {
      router.push("/admin/login");
      return;
    }
    fetchUsers();
  }, []);

  useEffect(() => {
    filterUsersList();
  }, [searchTerm, users]);

  const fetchUsers = async () => {
    try {
      const token = localStorage.getItem("adminToken");
      const response = await fetch("/api/admin/users", {
        headers: { Authorization: `Bearer ${token}` },
      });
      const data = await response.json();
      setUsers(data.users || []);
    } catch (error) {
      console.error("Error fetching users:", error);
    } finally {
      setLoading(false);
    }
  };

  const filterUsersList = () => {
    if (!searchTerm) {
      setFilteredUsers(users);
      return;
    }

    const filtered = users.filter(
      (user) =>
        user.name?.toLowerCase().includes(searchTerm.toLowerCase()) ||
        user.email?.toLowerCase().includes(searchTerm.toLowerCase()) ||
        user.phone?.includes(searchTerm)
    );

    setFilteredUsers(filtered);
  };

  if (loading) {
    return (
      <AdminLayout>
        <div className={styles.loading}>Loading users...</div>
      </AdminLayout>
    );
  }

  return (
    <AdminLayout>
      <div className={styles.container}>
        <div className={styles.header}>
          <h1>User Management</h1>
          <p className={styles.subtitle}>Total Users: {users.length}</p>
        </div>

        {/* Search */}
        <div className={styles.searchBox}>
          <input
            type="text"
            placeholder="Search by name, email, or phone..."
            value={searchTerm}
            onChange={(e) => setSearchTerm(e.target.value)}
          />
        </div>

        {/* Users Table */}
        <div className={styles.tableContainer}>
          <table className={styles.table}>
            <thead>
              <tr>
                <th>Name</th>
                <th>Email</th>
                <th>Phone</th>
                <th>Gender</th>
                <th>Bookings</th>
                <th>Status</th>
                <th>Joined</th>
                <th>Actions</th>
              </tr>
            </thead>
            <tbody>
              {filteredUsers.map((user) => (
                <tr key={user._id}>
                  <td className={styles.userName}>{user.name}</td>
                  <td>{user.email || "N/A"}</td>
                  <td>{user.phone}</td>
                  <td className={styles.gender}>{user.gender}</td>
                  <td>{user.bookingHistory?.length || 0}</td>
                  <td>
                    <span
                      className={`${styles.status} ${
                        user.isActive ? styles.active : styles.inactive
                      }`}
                    >
                      {user.isActive ? "Active" : "Inactive"}
                    </span>
                  </td>
                  <td>{new Date(user.createdAt).toLocaleDateString()}</td>
                  <td>
                    <button
                      className={styles.viewBtn}
                      onClick={() => setSelectedUser(user)}
                    >
                      View Details
                    </button>
                  </td>
                </tr>
              ))}
            </tbody>
          </table>

          {filteredUsers.length === 0 && (
            <div className={styles.noData}>No users found</div>
          )}
        </div>
      </div>

      {selectedUser && (
        <UserDetailsModal
          user={selectedUser}
          onClose={() => setSelectedUser(null)}
        />
      )}
    </AdminLayout>
  );
}
</file>

<file path="src/pages/api/admin/analytics/index.js">
import clientPromise from "../../../../lib/mongodb";
import { verifyAdminToken } from "../../../../lib/adminAuth";

export default async function handler(req, res) {
  if (req.method !== "GET") {
    return res.status(405).json({ message: "Method not allowed" });
  }

  try {
    const admin = verifyAdminToken(req);
    if (!admin) {
      return res.status(401).json({ message: "Unauthorized" });
    }

    const client = await clientPromise;
    const db = client.db("techtrims");

    // Peak hours
    const peakHours = await db
      .collection("bookings")
      .aggregate([
        { $match: { status: "completed" } },
        {
          $group: {
            _id: "$time",
            count: { $sum: 1 },
          },
        },
        { $sort: { count: -1 } },
        { $limit: 5 },
        { $project: { hour: "$_id", count: 1, _id: 0 } },
      ])
      .toArray();

    // Popular services
    const popularServices = await db
      .collection("bookings")
      .aggregate([
        { $match: { status: "completed" } },
        {
          $group: {
            _id: "$service",
            count: { $sum: 1 },
          },
        },
        { $sort: { count: -1 } },
        { $limit: 10 },
        { $project: { name: "$_id", count: 1, _id: 0 } },
      ])
      .toArray();

    // Day-wise trends (last 7 days)
    const days = [
      "Sunday",
      "Monday",
      "Tuesday",
      "Wednesday",
      "Thursday",
      "Friday",
      "Saturday",
    ];
    const dayTrends = days.map((day, index) => ({
      day,
      bookings: 0, // You can calculate this based on date
    }));

    // Top salons - FIXED to handle location properly
    const topSalons = await db
      .collection("salons")
      .aggregate([
        {
          $addFields: {
            totalBookings: { $ifNull: ["$stats.totalBookings", 0] },
            rating: { $ifNull: ["$ratings.overall", 5.0] },
          },
        },
        { $sort: { totalBookings: -1 } },
        { $limit: 10 },
        {
          $project: {
            salonName: 1,
            totalBookings: 1,
            rating: 1,
            location: "$location.address", // FIXED: Extract address properly
          },
        },
      ])
      .toArray();

    // Repeat customer rate
    const allUsers = await db.collection("users").countDocuments();
    const repeatUsers = await db.collection("users").countDocuments({
      $expr: { $gt: [{ $size: { $ifNull: ["$bookingHistory", []] } }, 1] },
    });
    const repeatRate =
      allUsers > 0 ? ((repeatUsers / allUsers) * 100).toFixed(1) : 0;

    // Average booking value
    const avgValue = await db
      .collection("bookings")
      .aggregate([
        { $match: { status: "completed" } },
        { $group: { _id: null, avg: { $avg: "$price" } } },
      ])
      .toArray();

    const avgBookingValue = Math.round(avgValue[0]?.avg || 0);

    // Average rating
    const avgRatingData = await db
      .collection("salons")
      .aggregate([{ $group: { _id: null, avg: { $avg: "$ratings.overall" } } }])
      .toArray();

    const avgRating = (avgRatingData[0]?.avg || 5.0).toFixed(1);

    res.status(200).json({
      peakHours:
        peakHours.length > 0 ? peakHours : [{ hour: "10:00", count: 0 }],
      popularServices:
        popularServices.length > 0
          ? popularServices
          : [{ name: "Haircut", count: 0 }],
      dayTrends,
      topSalons,
      repeatRate,
      avgBookingValue,
      avgRating,
    });
  } catch (error) {
    console.error("Analytics API error:", error);
    res.status(500).json({ message: "Internal server error" });
  }
}
</file>

<file path="src/pages/api/admin/dashboard/stats.js">
import clientPromise from "../../../../lib/mongodb";
import { verifyAdminToken } from "../../../../lib/adminAuth";

export default async function handler(req, res) {
  if (req.method !== "GET") {
    return res.status(405).json({ message: "Method not allowed" });
  }

  try {
    const admin = verifyAdminToken(req);
    if (!admin) {
      return res.status(401).json({ message: "Unauthorized" });
    }

    const client = await clientPromise;
    const db = client.db("techtrims");

    // Get counts
    const totalSalons = await db.collection("salons").countDocuments();
    const totalUsers = await db.collection("users").countDocuments();
    const totalBookings = await db.collection("bookings").countDocuments();

    // Active salons
    const activeSalons = await db
      .collection("salons")
      .countDocuments({ isActive: true });

    // Total revenue from bookings
    const revenueData = await db
      .collection("bookings")
      .aggregate([
        { $match: { status: "completed" } },
        { $group: { _id: null, total: { $sum: "$price" } } },
      ])
      .toArray();

    const totalRevenue = revenueData[0]?.total || 0;

    // Recent bookings
    const recentBookings = await db
      .collection("bookings")
      .find()
      .sort({ createdAt: -1 })
      .limit(10)
      .toArray();

    // Bookings this month
    const startOfMonth = new Date(
      new Date().getFullYear(),
      new Date().getMonth(),
      1
    );
    const bookingsThisMonth = await db.collection("bookings").countDocuments({
      createdAt: { $gte: startOfMonth },
    });

    // Average rating
    const ratings = await db
      .collection("salons")
      .aggregate([
        { $group: { _id: null, avgRating: { $avg: "$ratings.overall" } } },
      ])
      .toArray();

    const avgRating = ratings[0]?.avgRating || 5.0;

    res.status(200).json({
      totalSalons,
      totalUsers,
      totalBookings,
      activeSalons,
      totalRevenue,
      bookingsThisMonth,
      avgRating: avgRating.toFixed(1),
      recentBookings,
    });
  } catch (error) {
    console.error("Dashboard stats error:", error);
    res.status(500).json({ message: "Internal server error" });
  }
}
</file>

<file path="src/pages/api/admin/reports/generate.js">
import clientPromise from "../../../../lib/mongodb";
import { verifyAdminToken } from "../../../../lib/adminAuth";
import { jsPDF } from "jspdf";
import autoTable from "jspdf-autotable";

export default async function handler(req, res) {
  if (req.method !== "POST") {
    return res.status(405).json({ message: "Method not allowed" });
  }

  try {
    const admin = verifyAdminToken(req);
    if (!admin) {
      return res.status(401).json({ message: "Unauthorized" });
    }

    const { reportType } = req.body;

    const client = await clientPromise;
    const db = client.db("techtrims");

    // Fetch data
    const salons = await db.collection("salons").find({}).toArray();
    const users = await db.collection("users").find({}).toArray();
    const bookings = await db.collection("bookings").find({}).toArray();

    // Create PDF
    const doc = new jsPDF();

    // Title
    doc.setFontSize(20);
    doc.text("TechTrims Admin Report", 105, 20, { align: "center" });

    doc.setFontSize(12);
    doc.text(`Report Type: ${reportType}`, 105, 30, { align: "center" });
    doc.text(`Generated: ${new Date().toLocaleString()}`, 105, 38, {
      align: "center",
    });

    // Summary
    doc.setFontSize(16);
    doc.text("Summary", 14, 50);

    doc.setFontSize(12);
    doc.text(`Total Salons: ${salons.length}`, 14, 60);
    doc.text(`Total Users: ${users.length}`, 14, 68);
    doc.text(`Total Bookings: ${bookings.length}`, 14, 76);

    // Salons Table
    if (reportType === "comprehensive" || reportType === "salons") {
      doc.addPage();
      doc.setFontSize(16);
      doc.text("Salons Details", 14, 20);

      const salonData = salons.map((salon) => [
        salon.salonName || "N/A",
        salon.ownerName || "N/A",
        salon.phone || "N/A",
        salon.stats?.totalBookings || 0,
        (salon.ratings?.overall || 5.0).toFixed(1),
        salon.isActive ? "Active" : "Inactive",
      ]);

      autoTable(doc, {
        startY: 25,
        head: [
          ["Salon Name", "Owner", "Phone", "Bookings", "Rating", "Status"],
        ],
        body: salonData,
      });
    }

    // Users Table
    if (reportType === "comprehensive" || reportType === "users") {
      doc.addPage();
      doc.setFontSize(16);
      doc.text("Users Details", 14, 20);

      const userData = users.map((user) => [
        user.name || "N/A",
        user.phone || "N/A",
        user.email || "N/A",
        user.bookingHistory?.length || 0,
        new Date(user.createdAt).toLocaleDateString(),
      ]);

      autoTable(doc, {
        startY: 25,
        head: [["Name", "Phone", "Email", "Bookings", "Joined"]],
        body: userData,
      });
    }

    // Output PDF
    const pdfBuffer = Buffer.from(doc.output("arraybuffer"));

    res.setHeader("Content-Type", "application/pdf");
    res.setHeader(
      "Content-Disposition",
      `attachment; filename=TechTrims_Report_${reportType}_${Date.now()}.pdf`
    );
    res.send(pdfBuffer);
  } catch (error) {
    console.error("Report generation error:", error);
    res
      .status(500)
      .json({ message: "Internal server error", error: error.message });
  }
}
</file>

<file path="src/pages/api/admin/revenue/index.js">
import clientPromise from "../../../../lib/mongodb";
import { verifyAdminToken } from "../../../../lib/adminAuth";
import { ObjectId } from "mongodb";

export default async function handler(req, res) {
  if (req.method !== "GET") {
    return res.status(405).json({ message: "Method not allowed" });
  }

  try {
    const admin = verifyAdminToken(req);
    if (!admin) {
      return res.status(401).json({ message: "Unauthorized" });
    }

    const client = await clientPromise;
    const db = client.db("techtrims");

    // Get all salons
    const allSalons = await db.collection("salons").find({}).toArray();

    // Calculate revenue for each salon
    const salonsWithRevenue = await Promise.all(
      allSalons.map(async (salon) => {
        const salonIdStr = salon._id.toString();
        const salonIdObj = salon._id;

        // FIXED: Count bookings with 'confirmed' OR 'completed' status
        const revenueBookings = await db
          .collection("bookings")
          .find({
            $or: [{ salonId: salonIdStr }, { salonId: salonIdObj }],
            status: { $in: ["confirmed", "completed"] }, // Include BOTH statuses!
          })
          .toArray();

        const totalBookings = revenueBookings.length;
        const totalRevenue = revenueBookings.reduce(
          (sum, b) => sum + (b.price || 0),
          0
        );
        const commission = Math.round(totalRevenue * 0.15);

        return {
          _id: salon._id,
          salonName: salon.salonName,
          ownerName: salon.ownerName,
          email: salon.email,
          phone: salon.phone,
          totalBookings,
          totalRevenue,
          commission,
          paid: 0,
          balance: commission,
          createdAt: salon.createdAt,
        };
      })
    );

    // Calculate summary
    const summary = {
      totalRevenue: salonsWithRevenue.reduce(
        (sum, s) => sum + s.totalRevenue,
        0
      ),
      collected: 0,
      pending: salonsWithRevenue.reduce((sum, s) => sum + s.balance, 0),
    };

    res.status(200).json({ summary, salons: salonsWithRevenue });
  } catch (error) {
    console.error("Revenue API error:", error);
    res
      .status(500)
      .json({ message: "Internal server error", error: error.message });
  }
}
</file>

<file path="src/pages/api/admin/salons/[id]/barbers.js">
import clientPromise from "../../../../../lib/mongodb";
import { verifyAdminToken } from "../../../../../lib/adminAuth";
import { ObjectId } from "mongodb";

export default async function handler(req, res) {
  if (req.method !== "GET") {
    return res.status(405).json({ message: "Method not allowed" });
  }

  const { id } = req.query;

  try {
    const admin = verifyAdminToken(req);
    if (!admin) {
      return res.status(401).json({ message: "Unauthorized" });
    }

    const client = await clientPromise;
    const db = client.db("techtrims");

    // Match both string AND ObjectId
    let query = { salonId: id };
    if (ObjectId.isValid(id)) {
      query = {
        $or: [{ salonId: id }, { salonId: new ObjectId(id) }],
      };
    }

    const barbers = await db.collection("barbers").find(query).toArray();

    console.log(`Found ${barbers.length} barbers for salon ${id}`);

    return res.status(200).json({ barbers });
  } catch (error) {
    console.error("Barbers API error:", error.message);
    return res
      .status(500)
      .json({ message: "Internal server error", error: error.message });
  }
}
</file>

<file path="src/pages/api/admin/salons/[id]/bookings.js">
import clientPromise from "../../../../../lib/mongodb";
import { verifyAdminToken } from "../../../../../lib/adminAuth";
import { ObjectId } from "mongodb";

export default async function handler(req, res) {
  if (req.method !== "GET") {
    return res.status(405).json({ message: "Method not allowed" });
  }

  const { id } = req.query;

  try {
    const admin = verifyAdminToken(req);
    if (!admin) {
      return res.status(401).json({ message: "Unauthorized" });
    }

    const client = await clientPromise;
    const db = client.db("techtrims");

    // Try to match both string AND ObjectId format
    let query = { salonId: id };

    // If id is valid ObjectId format, also try matching as ObjectId
    if (ObjectId.isValid(id)) {
      query = {
        $or: [
          { salonId: id }, // String
          { salonId: new ObjectId(id) }, // ObjectId
        ],
      };
    }

    const bookings = await db
      .collection("bookings")
      .find(query)
      .sort({ createdAt: -1 })
      .limit(20)
      .toArray();

    console.log(`Query:`, query);
    console.log(`Found ${bookings.length} bookings for salon ${id}`);

    return res.status(200).json({ bookings });
  } catch (error) {
    console.error("Bookings API error:", error.message);
    return res
      .status(500)
      .json({ message: "Internal server error", error: error.message });
  }
}
</file>

<file path="src/pages/api/admin/salons/[id]/reviews.js">
import clientPromise from "../../../../../lib/mongodb";
import { verifyAdminToken } from "../../../../../lib/adminAuth";
import { ObjectId } from "mongodb";

export default async function handler(req, res) {
  if (req.method !== "GET") {
    return res.status(405).json({ message: "Method not allowed" });
  }

  const { id } = req.query;

  try {
    const admin = verifyAdminToken(req);
    if (!admin) {
      return res.status(401).json({ message: "Unauthorized" });
    }

    const client = await clientPromise;
    const db = client.db("techtrims");

    // Match both string AND ObjectId
    let salonQuery = { salonId: id };
    if (ObjectId.isValid(id)) {
      salonQuery = {
        $or: [{ salonId: id }, { salonId: new ObjectId(id) }],
      };
    }

    const reviews = await db
      .collection("bookings")
      .find({
        ...salonQuery,
        "feedback.submitted": true,
      })
      .sort({ "feedback.submittedAt": -1 })
      .limit(20)
      .toArray();

    const formattedReviews = reviews.map((booking) => ({
      _id: booking._id,
      customerName: booking.customerName,
      rating: booking.feedback?.ratings?.overall || 5,
      comment: booking.feedback?.comment || "No comment",
      service: booking.service,
      submittedAt: booking.feedback?.submittedAt,
    }));

    console.log(`Found ${formattedReviews.length} reviews for salon ${id}`);

    return res.status(200).json({ reviews: formattedReviews });
  } catch (error) {
    console.error("Reviews API error:", error.message);
    return res
      .status(500)
      .json({ message: "Internal server error", error: error.message });
  }
}
</file>

<file path="src/pages/api/admin/salons/[id]/toggle-status.js">
import clientPromise from "../../../../../lib/mongodb";
import { verifyAdminToken } from "../../../../../lib/adminAuth";
import { ObjectId } from "mongodb";

export default async function handler(req, res) {
  if (req.method !== "PUT") {
    return res.status(405).json({ message: "Method not allowed" });
  }

  try {
    const admin = verifyAdminToken(req);
    if (!admin) {
      return res.status(401).json({ message: "Unauthorized" });
    }

    const { id } = req.query;
    const { isActive } = req.body;

    const client = await clientPromise;
    const db = client.db("techtrims");

    const result = await db
      .collection("salons")
      .updateOne(
        { _id: new ObjectId(id) },
        { $set: { isActive, updatedAt: new Date() } }
      );

    if (result.matchedCount === 0) {
      return res.status(404).json({ message: "Salon not found" });
    }

    res.status(200).json({ message: "Status updated successfully" });
  } catch (error) {
    console.error("Toggle status error:", error);
    res.status(500).json({ message: "Internal server error" });
  }
}
</file>

<file path="src/pages/api/admin/salons/index.js">
import clientPromise from "../../../../lib/mongodb";
import { verifyAdminToken } from "../../../../lib/adminAuth";

export default async function handler(req, res) {
  if (req.method !== "GET") {
    return res.status(405).json({ message: "Method not allowed" });
  }

  try {
    const admin = verifyAdminToken(req);
    if (!admin) {
      return res.status(401).json({ message: "Unauthorized" });
    }

    const client = await clientPromise;
    const db = client.db("techtrims");

    // Get all salons with aggregated data
    const salons = await db
      .collection("salons")
      .aggregate([
        {
          $lookup: {
            from: "barbers",
            localField: "barbers",
            foreignField: "_id",
            as: "barberDetails",
          },
        },
        {
          $addFields: {
            barberCount: { $size: "$barberDetails" },
          },
        },
        {
          $project: {
            hashedPassword: 0,
            "ownerDetails.password": 0,
          },
        },
        { $sort: { createdAt: -1 } },
      ])
      .toArray();

    res.status(200).json({ salons });
  } catch (error) {
    console.error("Fetch salons error:", error);
    res.status(500).json({ message: "Internal server error" });
  }
}
</file>

<file path="src/pages/api/admin/users/[id]/bookings.js">
import clientPromise from "../../../../../lib/mongodb";
import { verifyAdminToken } from "../../../../../lib/adminAuth";
import { ObjectId } from "mongodb";

export default async function handler(req, res) {
  if (req.method !== "GET") {
    return res.status(405).json({ message: "Method not allowed" });
  }

  try {
    const admin = verifyAdminToken(req);
    if (!admin) {
      return res.status(401).json({ message: "Unauthorized" });
    }

    const { id } = req.query;

    const client = await clientPromise;
    const db = client.db("techtrims");

    // userId is stored as ObjectId
    const bookings = await db
      .collection("bookings")
      .find({ userId: new ObjectId(id) })
      .sort({ createdAt: -1 })
      .limit(50)
      .toArray();

    // Get salon names
    const bookingsWithSalon = await Promise.all(
      bookings.map(async (booking) => {
        const salon = await db.collection("salons").findOne({
          _id: new ObjectId(booking.salonId),
        });
        return {
          ...booking,
          salonName: salon?.salonName || "Unknown Salon",
        };
      })
    );

    res.status(200).json({ bookings: bookingsWithSalon });
  } catch (error) {
    console.error("Fetch user bookings error:", error);
    res
      .status(500)
      .json({ message: "Internal server error", error: error.message });
  }
}
</file>

<file path="src/pages/api/admin/users/index.js">
import clientPromise from "../../../../lib/mongodb";
import { verifyAdminToken } from "../../../../lib/adminAuth";

export default async function handler(req, res) {
  if (req.method !== "GET") {
    return res.status(405).json({ message: "Method not allowed" });
  }

  try {
    const admin = verifyAdminToken(req);
    if (!admin) {
      return res.status(401).json({ message: "Unauthorized" });
    }

    const client = await clientPromise;
    const db = client.db("techtrims");

    // Get all users
    const users = await db
      .collection("users")
      .find({}, { projection: { hashedPassword: 0 } })
      .sort({ createdAt: -1 })
      .toArray();

    // Get booking counts for each user
    const usersWithBookings = await Promise.all(
      users.map(async (user) => {
        const bookingCount = await db.collection("bookings").countDocuments({
          $or: [{ userId: user._id }, { customerPhone: user.phone }],
        });

        return {
          ...user,
          totalBookings: bookingCount,
        };
      })
    );

    res.status(200).json({ users: usersWithBookings });
  } catch (error) {
    console.error("Fetch users error:", error);
    res.status(500).json({ message: "Internal server error" });
  }
}
</file>

<file path="src/pages/api/auth/admin/login.js">
import clientPromise from "../../../../lib/mongodb";
import bcrypt from "bcryptjs";
import jwt from "jsonwebtoken";

export default async function handler(req, res) {
  if (req.method !== "POST") {
    return res.status(405).json({ message: "Method not allowed" });
  }

  try {
    const { username, password } = req.body;

    if (!username || !password) {
      return res
        .status(400)
        .json({ message: "Username and password required" });
    }

    const client = await clientPromise;
    const db = client.db("techtrims");

    // Find admin
    const admin = await db.collection("admins").findOne({ username });

    if (!admin) {
      return res.status(401).json({ message: "Invalid credentials" });
    }

    // Verify password
    const isValid = await bcrypt.compare(password, admin.hashedPassword);

    if (!isValid) {
      return res.status(401).json({ message: "Invalid credentials" });
    }

    // Generate token
    const token = jwt.sign(
      { adminId: admin._id, username: admin.username, role: "admin" },
      process.env.JWT_SECRET,
      { expiresIn: "7d" }
    );

    // Remove password from response
    const { hashedPassword, ...adminData } = admin;

    res.status(200).json({
      message: "Login successful",
      token,
      admin: adminData,
    });
  } catch (error) {
    console.error("Admin login error:", error);
    res.status(500).json({ message: "Internal server error" });
  }
}
</file>

<file path="src/pages/api/auth/reset-password.js">
import clientPromise from "../../../lib/mongodb";
import { verifyResetToken } from "../../../lib/resetToken";
import bcrypt from "bcryptjs";
import { ObjectId } from "mongodb";

export default async function handler(req, res) {
  if (req.method !== "POST") {
    return res.status(405).json({ message: "Method not allowed" });
  }

  try {
    const { token, newPassword } = req.body;

    if (!token || !newPassword) {
      return res
        .status(400)
        .json({ message: "Token and new password are required" });
    }

    // ✅ VALIDATE PASSWORD STRENGTH
    if (newPassword.length < 8) {
      return res.status(400).json({
        message: "Password must be at least 8 characters long",
      });
    }

    if (
      !/[A-Z]/.test(newPassword) ||
      !/[a-z]/.test(newPassword) ||
      !/[0-9]/.test(newPassword)
    ) {
      return res.status(400).json({
        message: "Password must contain uppercase, lowercase, and numbers",
      });
    }

    const client = await clientPromise;
    const db = client.db("techtrims");
    const users = db.collection("users");

    // First, get user to verify token
    const decoded = jwt.decode(token);
    if (!decoded || !decoded.userId) {
      return res.status(400).json({ message: "Invalid token format" });
    }

    const user = await users.findOne({ _id: new ObjectId(decoded.userId) });

    if (!user) {
      return res.status(404).json({ message: "User not found" });
    }

    // ✅ VERIFY JWT TOKEN with current password hash
    const verification = verifyResetToken(token, user.hashedPassword);

    if (!verification.valid) {
      return res.status(400).json({ message: verification.error });
    }

    // ✅ HASH NEW PASSWORD (never store plaintext)
    const hashedPassword = await bcrypt.hash(newPassword, 12);

    // ✅ UPDATE PASSWORD
    await users.updateOne(
      { _id: user._id },
      {
        $set: {
          hashedPassword,
          updatedAt: new Date(),
        },
      }
    );

    console.log("✅ Password reset successful:", {
      userId: user._id.toString(),
      email: user.email,
    });

    return res.status(200).json({
      message:
        "Password reset successfully! You can now login with your new password.",
      success: true,
    });
  } catch (error) {
    console.error("❌ Reset password error:", error.message);
    // ✅ NEVER expose internal errors
    return res.status(500).json({
      message: "An error occurred while resetting password. Please try again.",
    });
  }
}
</file>

<file path="src/pages/api/auth/salon/login.js">
import { connectToDatabase } from "../../../../lib/mongodb";
import { ObjectId } from "mongodb";
import bcrypt from "bcryptjs";
import jwt from "jsonwebtoken";

export default async function handler(req, res) {
  if (req.method !== "POST") {
    return res.status(405).json({ message: "Method not allowed" });
  }

  try {
    const { db } = await connectToDatabase();
    const { email, password } = req.body;

    if (!email || !password) {
      return res.status(400).json({ message: "Email and password required" });
    }

    // Find salon
    const salon = await db.collection("salons").findOne({
      $or: [
        { email: email.toLowerCase() },
        { "ownerDetails.email": email },
        { "salonDetails.ownerEmail": email },
      ],
    });

    if (!salon) {
      return res.status(401).json({ message: "Invalid credentials" });
    }

    // Debug log to see your data structure
    console.log("Found salon:", JSON.stringify(salon, null, 2));

    // Check password - handle both hashed and plain text passwords
    // Check password - always use hashedPassword
    let isValidPassword = false;

    if (salon.hashedPassword) {
      isValidPassword = await bcrypt.compare(password, salon.hashedPassword);
    } else if (salon.password) {
      // Fallback in case old records stored plain password
      isValidPassword = password === salon.password;
    } else if (salon.ownerDetails?.password) {
      // If you had an old schema with ownerDetails.password
      isValidPassword = await bcrypt.compare(
        password,
        salon.ownerDetails.password
      );
    }

    // Generate token
    const token = jwt.sign(
      { salonId: salon._id, email: salon.email },
      process.env.JWT_SECRET || "fallback_secret",
      { expiresIn: "30d" }
    );

    // Remove password from response
    const { password: _, ...salonData } = salon;

    res.status(200).json({
      success: true,
      message: "Login successful",
      salon: salonData,
      token,
    });
  } catch (error) {
    console.error("Login error:", error);
    res.status(500).json({ message: "Internal server error" });
  }
}
</file>

<file path="src/pages/api/auth/send-otp.js">
// pages/api/auth/send-otp.js
// Generates a 6-digit OTP and stores in 'otps' collection (expires in 5 minutes).
// NOTE: No SMS provider integrated. Replace sendSms() with your provider.
import { connectToDatabase } from "../../../lib/mongodb";
import { nanoid } from "nanoid";

function generateOtp() {
  return Math.floor(100000 + Math.random() * 900000).toString();
}

export default async function handler(req, res) {
  if (req.method !== "POST") return res.status(405).json({ message: "Method not allowed" });
  try {
    const { mobile } = req.body || {};
    if (!mobile) return res.status(400).json({ message: "Missing mobile" });
    const { db } = await connectToDatabase();
    const otp = generateOtp();
    const expiresAt = new Date(Date.now() + 5 * 60 * 1000); // 5 mins
    await db.collection("otps").updateOne({ mobile }, { $set: { otp, expiresAt } }, { upsert: true });
    // TODO: Integrate SMS provider here. For now we return OTP in response for testing.
    return res.status(200).json({ message: "OTP sent (dev)", otp });
  } catch (e) {
    console.error(e);
    return res.status(500).json({ message: e.message });
  }
}
</file>

<file path="src/pages/api/auth/verify-otp.js">
// pages/api/auth/verify-otp.js
// Verifies OTP and returns a temporary token (or creates/returns user).
// For demo returns user info if found or indicates success.
import { connectToDatabase } from "../../../lib/mongodb";

export default async function handler(req, res) {
  if (req.method !== "POST") return res.status(405).json({ message: "Method not allowed" });
  try {
    const { mobile, otp } = req.body || {};
    if (!mobile || !otp) return res.status(400).json({ message: "Missing fields" });
    const { db } = await connectToDatabase();
    const record = await db.collection("otps").findOne({ mobile });
    if (!record) return res.status(400).json({ message: "No OTP found" });
    if (new Date(record.expiresAt) < new Date()) return res.status(400).json({ message: "OTP expired" });
    if (String(record.otp) !== String(otp)) return res.status(400).json({ message: "Invalid OTP" });
    // OTP ok — optionally find/create user
    const user = await db.collection("users").findOne({ mobile });
    // delete OTP after use
    await db.collection("otps").deleteOne({ mobile });
    return res.status(200).json({ message: "Verified", user: user || null });
  } catch (e) {
    console.error(e);
    return res.status(500).json({ message: e.message });
  }
}
</file>

<file path="src/pages/api/barber/service-control.js">
import clientPromise from "../../../lib/mongodb";
import { ObjectId } from "mongodb";

export default async function handler(req, res) {
  if (req.method !== "POST") {
    return res.status(405).json({ message: "Method not allowed" });
  }

  try {
    const { action, bookingId, barberId, duration } = req.body;

    if (!action || !bookingId || !barberId) {
      return res.status(400).json({ message: "Missing required fields" });
    }

    const client = await clientPromise;
    const db = client.db("techtrims");

    if (action === "START") {
      if (!duration) {
        return res
          .status(400)
          .json({ message: "Duration is required for START action" });
      }

      const now = new Date();
      const serviceEndTime = new Date(now.getTime() + duration * 60 * 1000);

      // Update booking to GREEN (in service)
      await db.collection("walkinbookings").updateOne(
        { _id: new ObjectId(bookingId) },
        {
          $set: {
            queueStatus: "GREEN",
            serviceStartedAt: now,
            selectedDuration: duration,
          },
        }
      );

      // Update barber status
      await db.collection("barbers").updateOne(
        { _id: new ObjectId(barberId) },
        {
          $set: {
            currentStatus: "OCCUPIED",
            currentBookingId: new ObjectId(bookingId),
            currentServiceStartTime: now,
            currentServiceEndTime: serviceEndTime,
          },
        }
      );

      res.status(200).json({
        success: true,
        message: "Service started successfully",
      });
    } else if (action === "END") {
      const now = new Date();

      // Get booking to calculate actual duration
      const booking = await db.collection("walkinbookings").findOne({
        _id: new ObjectId(bookingId),
      });

      const actualDuration = booking?.serviceStartedAt
        ? Math.round((now - new Date(booking.serviceStartedAt)) / 1000 / 60)
        : null;

      // Update booking to COMPLETED
      await db.collection("walkinbookings").updateOne(
        { _id: new ObjectId(bookingId) },
        {
          $set: {
            queueStatus: "COMPLETED",
            serviceEndedAt: now,
            actualDuration,
          },
        }
      );

      // Get next customer in queue
      const nextCustomer = await db.collection("walkinbookings").findOne(
        {
          barberId: new ObjectId(barberId),
          queueStatus: "ORANGE",
          isExpired: false,
        },
        {
          sort: { arrivedAt: 1 },
        }
      );

      // Update barber status
      await db.collection("barbers").updateOne(
        { _id: new ObjectId(barberId) },
        {
          $set: {
            currentStatus: nextCustomer ? "AVAILABLE" : "AVAILABLE",
            currentBookingId: null,
            currentServiceStartTime: null,
            currentServiceEndTime: null,
          },
          $inc: { queueLength: -1 },
        }
      );

      res.status(200).json({
        success: true,
        message: "Service completed successfully",
        nextCustomer: nextCustomer
          ? {
              bookingCode: nextCustomer.bookingCode,
              customerName: nextCustomer.customerName,
            }
          : null,
      });
    } else {
      return res.status(400).json({ message: "Invalid action" });
    }
  } catch (error) {
    console.error("Service control error:", error);
    res
      .status(500)
      .json({ message: "Internal server error", error: error.message });
  }
}
</file>

<file path="src/pages/api/barber/update-status.js">
// File: /api/barber/service-control.js
// POST /api/barber/service-control

// Request Body:
// {
//   action: "START" | "END",
//   bookingId: String,
//   barberId: String,
//   duration: Number // only for START action
// }

// Response:
// {
//   success: true,
//   message: "Service started successfully",
//   nextCustomer: {
//     bookingCode: "...",
//     customerName: "...",
//     service: "..."
//   } | null
// }

export default async function handler(req, res) {
  if (req.method !== "POST") {
    return res.status(405).json({ message: "Method not allowed" });
  }

  try {
    const { action, bookingId, barberId, duration } = req.body;
    const db = await connectToDatabase();

    if (action === "START") {
      // Start service - move from ORANGE to GREEN
      const now = new Date();
      const serviceEndTime = new Date(now.getTime() + duration * 60 * 1000);

      await db.collection("bookings").updateOne(
        { _id: new ObjectId(bookingId) },
        {
          $set: {
            queueStatus: "GREEN",
            status: "in_service",
            serviceStartedAt: now,
            selectedDuration: duration,
            lastUpdated: now,
          },
        }
      );

      // Update barber status
      await db.collection("barbers").updateOne(
        { _id: new ObjectId(barberId) },
        {
          $set: {
            currentStatus: "OCCUPIED",
            currentBookingId: new ObjectId(bookingId),
            currentServiceStartTime: now,
            currentServiceEndTime: serviceEndTime,
            timeLeftInMinutes: duration,
          },
        }
      );

      res.status(200).json({
        success: true,
        message: "Service started successfully",
      });
    } else if (action === "END") {
      // End service
      const booking = await db.collection("bookings").findOne({
        _id: new ObjectId(bookingId),
      });

      const actualDuration = booking.serviceStartedAt
        ? (Date.now() - new Date(booking.serviceStartedAt).getTime()) /
          1000 /
          60
        : null;

      await db.collection("bookings").updateOne(
        { _id: new ObjectId(bookingId) },
        {
          $set: {
            queueStatus: "COMPLETED",
            status: "completed",
            serviceEndedAt: new Date(),
            actualDuration: Math.round(actualDuration),
            lastUpdated: new Date(),
          },
        }
      );

      // Get next customer in queue
      const nextCustomer = await db.collection("bookings").findOne(
        {
          barberId: new ObjectId(barberId),
          queueStatus: "ORANGE",
          isExpired: false,
        },
        {
          sort: { arrivedAt: 1 },
        }
      );

      // Update barber status
      await db.collection("barbers").updateOne(
        { _id: new ObjectId(barberId) },
        {
          $set: {
            currentStatus: nextCustomer ? "OCCUPIED" : "AVAILABLE",
            currentBookingId: nextCustomer?._id || null,
            timeLeftInMinutes: 0,
          },
          $inc: { queueLength: -1 },
          $pull: { waitingCustomers: new ObjectId(bookingId) },
        }
      );

      // Auto-start next customer's service
      if (nextCustomer) {
        await db.collection("bookings").updateOne(
          { _id: nextCustomer._id },
          {
            $set: {
              queueStatus: "GREEN",
              status: "in_service",
              serviceStartedAt: new Date(),
            },
          }
        );
      }

      res.status(200).json({
        success: true,
        message: "Service completed successfully",
        nextCustomer: nextCustomer
          ? {
              bookingCode: nextCustomer.bookingCode,
              customerName: nextCustomer.customerName,
              service: nextCustomer.service,
            }
          : null,
      });
    }

    // Update salon realtime state
    await updateSalonRealtimeState(db, booking.salonId);
  } catch (error) {
    console.error("Service control error:", error);
    res.status(500).json({ message: "Internal server error" });
  }
}
</file>

<file path="src/pages/api/bookings/status/[id].js">
import clientPromise from "../../../../lib/mongodb";
import { ObjectId } from "mongodb";

export default async function handler(req, res) {
  if (req.method !== "GET") {
    return res.status(405).json({ message: "Method not allowed" });
  }

  try {
    const { id } = req.query;

    const client = await clientPromise;
    const db = client.db("techtrims");

    const booking = await db.collection("bookings").findOne({
      _id: new ObjectId(id),
    });

    if (!booking) {
      return res.status(404).json({ message: "Booking not found" });
    }

    // Get queue position if ORANGE
    let queuePosition = null;
    if (booking.queueStatus === "ORANGE") {
      queuePosition = await db.collection("bookings").countDocuments({
        salonId: booking.salonId,
        queueStatus: "ORANGE",
        arrivedAt: { $lte: booking.arrivedAt },
      });
    }

    res.status(200).json({
      status: booking.status,
      queueStatus: booking.queueStatus,
      queuePosition,
      isExpired:
        booking.isExpired ||
        (booking.expiresAt && new Date(booking.expiresAt) < new Date()),
    });
  } catch (error) {
    console.error("Status check error:", error);
    res.status(500).json({ message: "Server error" });
  }
}
</file>

<file path="src/pages/api/maps/geocode.js">
// pages/api/maps/geocode.js
export default async function handler(req, res) {
  if (req.method !== "POST") {
    return res.status(405).json({ error: "Method not allowed" });
  }

  try {
    const { address } = req.body;
    const apiKey = process.env.NEXT_PUBLIC_GOOGLE_MAPS_API_KEY;

    if (!address) {
      return res.status(400).json({ error: "Address is required" });
    }

    const response = await fetch(
      `https://maps.googleapis.com/maps/api/geocode/json?address=${encodeURIComponent(
        address
      )}&key=${apiKey}`
    );

    const data = await response.json();

    if (data.status !== "OK" || !data.results || data.results.length === 0) {
      return res.status(400).json({ error: "Address not found" });
    }

    const result = data.results[0];
    const location = result.geometry.location;

    res.status(200).json({
      success: true,
      coordinates: [location.lng, location.lat], // [longitude, latitude] for MongoDB
      formattedAddress: result.formatted_address,
      placeId: result.place_id,
    });
  } catch (error) {
    console.error("Geocoding error:", error);
    res.status(500).json({ error: "Internal server error" });
  }
}
</file>

<file path="src/pages/api/ping.js">
export default function handler(req, res) {
  // Simple ping endpoint for connection testing
  res.status(200).json({
    status: "ok",
    timestamp: new Date().toISOString(),
  });
}
</file>

<file path="src/pages/api/salon/notifications.js">
// pages/api/salon/notifications.js
// Simple Server-Sent Events (SSE) endpoint for salon dashboards to subscribe to live notifications.
// Note: This is a simple in-memory solution for dev. For production use Redis/Message broker.

const subscribers = {}; // { salonId: [res, ...] }

export default async function handler(req, res) {
  const { salonId } = req.query;
  if (!salonId) return res.status(400).json({ message: "Missing salonId" });
  // Set SSE headers
  res.writeHead(200, {
    Connection: "keep-alive",
    "Cache-Control": "no-cache, no-transform",
    "Content-Type": "text/event-stream",
  });
  res.write("\n");

  subscribers[salonId] = subscribers[salonId] || [];
  subscribers[salonId].push(res);

  req.on("close", () => {
    subscribers[salonId] = subscribers[salonId].filter((r) => r !== res);
  });
}

// Provide a small helper to publish (other modules can import this file and call publish)
export function publish(salonId, payload) {
  const list = subscribers[salonId] || [];
  list.forEach((res) => {
    try {
      res.write(`data: ${JSON.stringify(payload)}\n\n`);
    } catch (e) {}
  });
}
</file>

<file path="src/pages/api/salons/[id].js">
// pages/api/salons/[id].js
import { connectToDatabase } from "../../../lib/mongodb";
import { ObjectId } from "mongodb";

export default async function handler(req, res) {
  const { id } = req.query;

  if (!ObjectId.isValid(id)) {
    return res.status(400).json({ error: "Invalid salon ID" });
  }

  try {
    const { db } = await connectToDatabase();

    if (req.method === "GET") {
      const salon = await db
        .collection("salons")
        .findOne(
          { _id: new ObjectId(id) },
          { projection: { "ownerDetails.password": 0 } }
        );

      if (!salon) {
        return res.status(404).json({ error: "Salon not found" });
      }

      // Get recent reviews/feedback
      const recentFeedback = await db
        .collection("bookings")
        .find({
          salonId: id,
          "feedback.submitted": true,
        })
        .sort({ updatedAt: -1 })
        .limit(5)
        .toArray();

      res.status(200).json({
        success: true,
        salon: {
          ...salon,
          recentFeedback: recentFeedback.map((booking) => ({
            userName: booking.userDetails.name,
            rating: booking.feedback.ratings.overall,
            comment: booking.feedback.comment,
            service: booking.service.name,
            date: booking.updatedAt,
          })),
        },
      });
    } else if (req.method === "PUT") {
      // Update salon details (protected route - needs authentication)
      const updateData = {
        ...req.body,
        updatedAt: new Date(),
      };

      const result = await db
        .collection("salons")
        .updateOne({ _id: new ObjectId(id) }, { $set: updateData });

      if (result.matchedCount === 0) {
        return res.status(404).json({ error: "Salon not found" });
      }

      res.status(200).json({
        success: true,
        message: "Salon updated successfully",
      });
    } else {
      res.status(405).json({ error: "Method not allowed" });
    }
  } catch (error) {
    console.error("Salon API error:", error);
    res.status(500).json({ error: "Internal server error" });
  }
}
</file>

<file path="src/pages/api/salons/[id]/reviews-detailed.js">
import clientPromise from "../../../../lib/mongodb";
import { ObjectId } from "mongodb";

export default async function handler(req, res) {
  if (req.method !== "GET") {
    return res.status(405).json({ message: "Method not allowed" });
  }

  const { id } = req.query;

  try {
    const client = await clientPromise;
    const db = client.db("techtrims");

    console.log("Fetching reviews for salon:", id);

    // Build query to match BOTH string and ObjectId format
    let salonQuery = { salonId: id };

    if (ObjectId.isValid(id)) {
      salonQuery = {
        $or: [
          { salonId: id }, // String format
          { salonId: new ObjectId(id) }, // ObjectId format
        ],
      };
    }

    // Get all bookings with feedback
    const reviews = await db
      .collection("bookings")
      .find({
        ...salonQuery,
        "feedback.submitted": true,
      })
      .sort({ "feedback.submittedAt": -1 })
      .toArray();

    console.log("Found reviews:", reviews.length);

    // Format reviews
    const formattedReviews = reviews.map((booking) => ({
      _id: booking._id,
      customerName: booking.customerName,
      rating: booking.feedback.ratings.overall,
      ratings: {
        serviceQuality: booking.feedback.ratings.serviceQuality,
        timing: booking.feedback.ratings.timing,
        ambience: booking.feedback.ratings.ambience,
        cleanliness: booking.feedback.ratings.cleanliness,
      },
      comment: booking.feedback.comment || "",
      service: booking.service,
      serviceDate: booking.date,
      submittedAt: booking.feedback.submittedAt,
    }));

    // Calculate statistics
    const totalReviews = formattedReviews.length;

    if (totalReviews === 0) {
      return res.status(200).json({
        reviews: [],
        stats: {
          totalReviews: 0,
          averageRating: 0,
          positiveCount: 0,
          mediumCount: 0,
          criticalCount: 0,
          positivePercentage: 0,
          mediumPercentage: 0,
          criticalPercentage: 0,
        },
      });
    }

    const averageRating =
      formattedReviews.reduce((sum, r) => sum + r.rating, 0) / totalReviews;

    const positiveCount = formattedReviews.filter((r) => r.rating >= 4).length;
    const mediumCount = formattedReviews.filter(
      (r) => r.rating >= 3 && r.rating < 4
    ).length;
    const criticalCount = formattedReviews.filter((r) => r.rating < 3).length;

    const stats = {
      totalReviews,
      averageRating: parseFloat(averageRating.toFixed(1)),
      positiveCount,
      mediumCount,
      criticalCount,
      positivePercentage: Math.round((positiveCount / totalReviews) * 100),
      mediumPercentage: Math.round((mediumCount / totalReviews) * 100),
      criticalPercentage: Math.round((criticalCount / totalReviews) * 100),
    };

    console.log("Stats:", stats);

    return res.status(200).json({ reviews: formattedReviews, stats });
  } catch (error) {
    console.error("Reviews detailed API error:", error.message);
    console.error("Stack:", error.stack);
    return res.status(500).json({
      message: "Internal server error",
      error: error.message,
    });
  }
}
</file>

<file path="src/pages/api/salons/barbers/[id].js">
// pages/api/salons/barbers/[id].js
import clientPromise from "../../../../lib/mongodb";
import { ObjectId } from "mongodb";

export default async function handler(req, res) {
  const { method } = req;
  const { id } = req.query;

  if (!ObjectId.isValid(id)) {
    return res.status(400).json({ error: "Invalid barber ID" });
  }

  try {
    const client = await clientPromise;
    const db = client.db("techtrims");
    const barbersCollection = db.collection("barbers");

    if (method === "GET") {
      const barber = await barbersCollection.findOne({ _id: new ObjectId(id) });
      if (!barber) return res.status(404).json({ error: "Barber not found" });
      return res.status(200).json(barber);
    }

    if (method === "PUT") {
      const updateData = { ...req.body, updatedAt: new Date() };

      const result = await barbersCollection.findOneAndUpdate(
        { _id: new ObjectId(id) },
        { $set: updateData },
        { returnDocument: "after" }
      );

      if (!result.value)
        return res.status(404).json({ error: "Barber not found" });
      return res.status(200).json(result.value);
    }

    if (method === "DELETE") {
      const result = await barbersCollection.deleteOne({
        _id: new ObjectId(id),
      });
      if (result.deletedCount === 0)
        return res.status(404).json({ error: "Barber not found" });
      return res.status(204).end();
    }

    return res.setHeader("Allow", ["GET", "PUT", "DELETE"]).status(405).end();
  } catch (err) {
    console.error("api/barbers/[id] error:", err);
    return res.status(500).json({ error: "Internal server error" });
  }
}
</file>

<file path="src/pages/api/salons/barbers/index.js">
// pages/api/salons/barbers/index.js
import clientPromise from "../../../../lib/mongodb";
import { ObjectId } from "mongodb";

export default async function handler(req, res) {
  const { method } = req;

  // Extract salonId from query parameters or request body
  const salonId = req.query.salonId || req.body.salonId;

  console.log("=== BARBERS API DEBUG ===");
  console.log("Method:", method);
  console.log("Raw salonId:", salonId);
  console.log("SalonId type:", typeof salonId);

  if (!salonId) {
    return res.status(400).json({ error: "salonId required" });
  }

  try {
    const client = await clientPromise;
    const db = client.db("techtrims");
    const barbersCollection = db.collection("barbers");

    console.log("Database connected successfully");

    if (method === "GET") {
      // Get all barbers for salon
      console.log("Fetching barbers for salon:", salonId);

      // Convert salonId to ObjectId - ADD VALIDATION
      let salonObjectId;
      try {
        salonObjectId = new ObjectId(salonId);
        console.log("Converted to ObjectId:", salonObjectId);
      } catch (objIdError) {
        console.error("Invalid ObjectId:", salonId, objIdError);
        return res.status(400).json({ error: "Invalid salonId format" });
      }

      const barbers = await barbersCollection
        .find({
          salonId: salonObjectId,
        })
        .sort({ name: 1 })
        .toArray();

      console.log("Found barbers:", barbers.length);
      console.log("Barbers data:", barbers);

      return res.status(200).json(barbers);
    }

    if (method === "POST") {
      // Create new barber
      let salonObjectId;
      try {
        salonObjectId = new ObjectId(salonId);
      } catch (objIdError) {
        return res.status(400).json({ error: "Invalid salonId format" });
      }

      const barberData = {
        ...req.body,
        salonId: salonObjectId,
        totalBookings: 0,
        rating: 5.0,
        isAvailable: req.body.isAvailable !== false,
        workingHours: {
          start: "09:00",
          end: "21:00",
        },
        accomplishments: [],
        earnings: 0,
        lastActiveAt: new Date(),
        createdAt: new Date(),
        updatedAt: new Date(),
      };

      console.log("Creating barber:", barberData);

      const result = await barbersCollection.insertOne(barberData);
      const createdBarber = await barbersCollection.findOne({
        _id: result.insertedId,
      });

      console.log("Barber created:", result.insertedId);
      return res.status(201).json(createdBarber);
    }

    return res
      .setHeader("Allow", ["GET", "POST"])
      .status(405)
      .json({ error: "Method not allowed" });
  } catch (err) {
    console.error("=== API ERROR ===");
    console.error("Error name:", err.name);
    console.error("Error message:", err.message);
    console.error("Error stack:", err.stack);
    console.error("=== END ERROR ===");

    return res.status(500).json({
      error: "Internal server error",
      details: err.message,
      name: err.name,
    });
  }
}
</file>

<file path="src/pages/api/salons/bookings/today.js">
import { connectToDatabase } from "../../../../lib/mongodb";
import { ObjectId } from "mongodb";

export default async function handler(req, res) {
  if (req.method !== "GET") {
    return res.status(405).json({ message: "Method not allowed" });
  }

  try {
    const { db } = await connectToDatabase();
    const { salonId } = req.query;

    if (!salonId) {
      return res.status(400).json({ message: "Salon ID required" });
    }

    // ✅ define today BEFORE using it
    // get today in local timezone as YYYY-MM-DD
    const today = new Date();
    const yyyy = today.getFullYear();
    const mm = String(today.getMonth() + 1).padStart(2, "0");
    const dd = String(today.getDate()).padStart(2, "0");
    const todayStr = `${yyyy}-${mm}-${dd}`;

    console.log("Fetching bookings for salon:", salonId, "date:", todayStr);

    const bookings = await db
      .collection("bookings")
      .find({
        salonId: salonId,
        date: todayStr,
        status: { $ne: "cancelled" },
      })
      .sort({ time: 1 })
      .toArray();

    res.status(200).json({
      success: true,
      bookings,
    });
  } catch (error) {
    console.error("Error fetching today's bookings:", error);
    // expose real error while debugging
    res.status(500).json({ message: error.message, stack: error.stack });
  }
}
</file>

<file path="src/pages/api/salons/bookings/update-status.js">
//pages/api/salons/bookings/today.js
import { connectToDatabase } from "../../../../lib/mongodb";
import { ObjectId } from "mongodb";

export default async function handler(req, res) {
  if (req.method !== "PUT") {
    return res.status(405).json({ message: "Method not allowed" });
  }

  try {
    const { db } = await connectToDatabase();
    const { bookingId, status } = req.body;

    if (!bookingId || !status) {
      return res
        .status(400)
        .json({ message: "Booking ID and status required" });
    }

    const result = await db.collection("bookings").updateOne(
      { _id: new ObjectId(bookingId) },
      {
        $set: {
          status,
          updatedAt: new Date(),
        },
      }
    );

    if (result.matchedCount === 0) {
      return res.status(404).json({ message: "Booking not found" });
    }

    res.status(200).json({
      success: true,
      message: "Booking status updated successfully",
    });
  } catch (error) {
    console.error("Error updating booking status:", error);
    res.status(500).json({ message: "Internal server error" });
  }
}
</file>

<file path="src/pages/api/salons/index.js">
// pages/api/salons/index.js
import { connectToDatabase } from "../../../lib/mongodb";

export default async function handler(req, res) {
  try {
    const { db } = await connectToDatabase();
    const salons = await db.collection("salons").find({}).toArray();
    console.log("Salons fetched from DB:", salons); // debug
    res.status(200).json({ success: true, salons });
  } catch (error) {
    console.error("Error fetching salons:", error);
    res.status(500).json({ error: "Internal server error" });
  }
}
</file>

<file path="src/pages/api/salons/profile.js">
// pages/api/salons/profile.js
import clientPromise from "../../../lib/mongodb";

export default async function handler(req, res) {
  try {
    const client = await clientPromise;
    const db = client.db("techtrims");
    const salon = await db.collection("salons").findOne({});
    res.status(200).json(salon);
  } catch (e) {
    console.error(e);
    res.status(500).json({ error: "Failed to load salon profile" });
  }
}
</file>

<file path="src/pages/api/salons/services/[id].js">
// pages/api/salons/services/[id].js
import { connectToDatabase } from "../../../../lib/mongodb";
import Service from "../../../../models/Service";

export default async function handler(req, res) {
  await connectToDatabase();
  const { method } = req;
  const { id } = req.query;

  try {
    if (method === "GET") {
      const s = await Service.findById(id);
      if (!s) return res.status(404).json({ error: "Not found" });
      return res.status(200).json(s);
    }
    if (method === "PUT") {
      const update = req.body;
      const s = await Service.findByIdAndUpdate(id, update, { new: true });
      return res.status(200).json(s);
    }
    if (method === "DELETE") {
      await Service.findByIdAndDelete(id);
      return res.status(204).end();
    }
    return res.setHeader("Allow", ["GET", "PUT", "DELETE"]).status(405).end();
  } catch (err) {
    console.error("api/services/[id] error", err);
    return res.status(500).json({ error: "Internal server error" });
  }
}
</file>

<file path="src/pages/api/salons/services/index.js">
// pages/api/salons/services/index.js
import { connectToDatabase } from "../../../../lib/mongodb";
import Service from "../../../../models/Service";

export default async function handler(req, res) {
  await connectToDatabase();
  const { method } = req;
  const salonId = req.query.salonId || req.body.salonId;
  if (!salonId) return res.status(400).json({ error: "salonId required" });

  try {
    if (method === "GET") {
      const items = await Service.find({ salonId }).sort({ title: 1 });
      return res.status(200).json(items);
    }
    if (method === "POST") {
      const payload = { ...req.body, salonId };
      const s = new Service(payload);
      await s.save();
      return res.status(201).json(s);
    }
    return res.setHeader("Allow", ["GET", "POST"]).status(405).end();
  } catch (err) {
    console.error("api/services error", err);
    return res.status(500).json({ error: "Internal server error" });
  }
}
</file>

<file path="src/pages/api/salons/staff/[id].js">
// pages/api/salons/staff/[id].js
import { connectToDatabase } from "../../../../lib/mongodb";
import Staff from "../../../../models/Staff";

export default async function handler(req, res) {
  await connectToDatabase();
  const { method } = req;
  const { id } = req.query;

  try {
    if (method === "GET") {
      const s = await Staff.findById(id);
      if (!s) return res.status(404).json({ error: "Not found" });
      return res.status(200).json(s);
    }
    if (method === "PUT") {
      const update = req.body;
      const s = await Staff.findByIdAndUpdate(id, update, { new: true });
      return res.status(200).json(s);
    }
    if (method === "DELETE") {
      await Staff.findByIdAndDelete(id);
      return res.status(204).end();
    }
    return res.setHeader("Allow", ["GET", "PUT", "DELETE"]).status(405).end();
  } catch (err) {
    console.error("api/staff/[id] error", err);
    return res.status(500).json({ error: "Internal server error" });
  }
}
</file>

<file path="src/pages/api/salons/staff/index.js">
// pages/api/salons/staff/index.js
import { connectToDatabase } from "../../../../lib/mongodb";
import Staff from "../../../../models/Staff";

export default async function handler(req, res) {
  await connectToDatabase();
  const { method } = req;
  const salonId = req.query.salonId || req.body.salonId;

  if (!salonId) return res.status(400).json({ error: "salonId required" });

  try {
    if (method === "GET") {
      const items = await Staff.find({ salonId }).sort({ name: 1 });
      return res.status(200).json(items);
    }
    if (method === "POST") {
      const payload = { ...req.body, salonId };
      const st = new Staff(payload);
      await st.save();
      return res.status(201).json(st);
    }

    return res.setHeader("Allow", ["GET", "POST"]).status(405).end();
  } catch (err) {
    console.error("api/staff error", err);
    return res.status(500).json({ error: "Internal server error" });
  }
}
</file>

<file path="src/pages/api/user/payments.js">
import clientPromise from "../../../lib/mongodb";
import { verifyToken } from "../../../lib/auth";
import { ObjectId } from "mongodb";

export default async function handler(req, res) {
  if (req.method !== "GET") {
    return res.status(405).json({ message: "Method not allowed" });
  }

  try {
    const token = req.headers.authorization?.replace("Bearer ", "");
    if (!token) {
      return res.status(401).json({ message: "No token provided" });
    }

    const decoded = verifyToken(token);
    if (!decoded || !decoded.userId) {
      return res.status(401).json({ message: "Invalid token" });
    }

    const client = await clientPromise;
    const db = client.db("techtrims");

    // Get user's bookings first
    const user = await db
      .collection("users")
      .findOne({ _id: new ObjectId(decoded.userId) });
    if (!user) {
      return res.status(404).json({ message: "User not found" });
    }

    // Get payments from bookings (since payment data is stored in bookings)
    const bookings = await db
      .collection("bookings")
      .find({
        $or: [
          { userId: new ObjectId(decoded.userId) },
          { customerPhone: user.phone },
        ],
        price: { $gt: 0 }, // Only bookings with payment
      })
      .sort({ createdAt: -1 })
      .toArray();

    // Transform bookings to payment format
    const payments = bookings.map((booking) => ({
      _id: booking._id,
      amount: booking.price || 0,
      bookingId: booking._id,
      status: booking.paymentStatus || "pending",
      createdAt: booking.createdAt,
      service: booking.service,
      date: booking.date,
    }));

    res.status(200).json(payments);
  } catch (error) {
    console.error("User payments API error:", error);
    res.status(500).json({ message: "Internal server error" });
  }
}
</file>

<file path="src/pages/api/user/register.js">
// pages/api/users/register.js
import { connectToDatabase } from "../../../lib/mongodb";
import { ObjectId } from "mongodb";

export default async function handler(req, res) {
  if (req.method !== "POST") return res.status(405).json({ message: "Method not allowed" });
  try {
    const body = req.body || {};
    const { name, mobile, email, gender, location } = body;
    if (!mobile || !name) return res.status(400).json({ message: "Missing name or mobile" });

    const { db } = await connectToDatabase();
    let existing = await db.collection("users").findOne({ mobile });
    if (existing) {
      return res.status(200).json({ message: "User exists", userId: existing._id });
    }

    const userDoc = {
      name,
      mobile,
      email: email || null,
      gender: gender || "other",
      location: location || null,
      bookingHistory: [],
      createdAt: new Date()
    };

    const r = await db.collection("users").insertOne(userDoc);
    return res.status(201).json({ userId: r.insertedId });
  } catch (e) {
    console.error(e);
    return res.status(500).json({ message: e.message });
  }
}
</file>

<file path="src/pages/api/user/sync-booking-history.js">
import clientPromise from "../../../lib/mongodb";
import { verifyToken } from "../../../lib/auth";
import { ObjectId } from "mongodb";

export default async function handler(req, res) {
  if (req.method !== "POST") {
    return res.status(405).json({ message: "Method not allowed" });
  }

  try {
    const token = req.headers.authorization?.replace("Bearer ", "");
    if (!token) {
      return res.status(401).json({ message: "No token provided" });
    }

    const decoded = verifyToken(token);
    if (!decoded || !decoded.userId) {
      return res.status(401).json({ message: "Invalid token" });
    }

    const client = await clientPromise;
    const db = client.db("techtrims");

    const user = await db
      .collection("users")
      .findOne({ _id: new ObjectId(decoded.userId) });
    if (!user) {
      return res.status(404).json({ message: "User not found" });
    }

    // Find all bookings for this user
    const allBookings = await db
      .collection("bookings")
      .find({
        $or: [
          { userId: new ObjectId(decoded.userId) },
          { customerPhone: user.phone },
          { customerName: { $regex: user.name, $options: "i" } },
        ],
      })
      .toArray();

    // Update bookings with userId if not set
    const bookingsToUpdate = allBookings.filter((b) => !b.userId);
    if (bookingsToUpdate.length > 0) {
      await db
        .collection("bookings")
        .updateMany(
          { _id: { $in: bookingsToUpdate.map((b) => b._id) } },
          { $set: { userId: new ObjectId(decoded.userId) } }
        );
    }

    // Update user's booking history
    const bookingIds = allBookings.map((b) => b._id);
    await db.collection("users").updateOne(
      { _id: new ObjectId(decoded.userId) },
      {
        $set: {
          bookingHistory: bookingIds,
          updatedAt: new Date(),
        },
      }
    );

    res.status(200).json({
      message: "Booking history synced successfully",
      totalBookings: allBookings.length,
      newlyLinked: bookingsToUpdate.length,
    });
  } catch (error) {
    console.error("Sync booking history error:", error);
    res.status(500).json({ message: "Internal server error" });
  }
}
</file>

<file path="src/pages/api/walkin/booking/[id].js">
import clientPromise from "../../../../lib/mongodb";
import { ObjectId } from "mongodb";

export default async function handler(req, res) {
  if (req.method !== "GET") {
    return res.status(405).json({ message: "Method not allowed" });
  }

  try {
    const { id } = req.query;

    if (!id) {
      return res.status(400).json({ message: "Booking ID is required" });
    }

    const client = await clientPromise;
    const db = client.db("techtrims");

    // Find booking
    const booking = await db.collection("bookings").findOne({
      _id: new ObjectId(id),
    });

    if (!booking) {
      return res.status(404).json({ message: "Booking not found" });
    }

    // Get barber details
    const barber = await db.collection("barbers").findOne({
      _id: booking.barberId,
    });

    // Get salon details
    const salon = await db.collection("salons").findOne({
      _id: booking.salonId,
    });

    res.status(200).json({
      booking: {
        ...booking,
        _id: booking._id.toString(),
        salonId: booking.salonId.toString(),
        barberId: booking.barberId.toString(),
        barberName: barber?.name || "Unknown",
        chairNumber: barber?.chairNumber || 1,
        salonName: salon?.salonName || "Unknown Salon",
        salonLocation: salon?.location?.address || "",
        salonCoordinates: salon?.location?.coordinates || null,
      },
    });
  } catch (error) {
    console.error("Get booking error:", error);
    res
      .status(500)
      .json({ message: "Internal server error", error: error.message });
  }
}
</file>

<file path="src/pages/api/walkin/create-booking.js">
import clientPromise from "../../../lib/mongodb";
import { ObjectId } from "mongodb";

export default async function handler(req, res) {
  if (req.method !== "POST") {
    return res.status(405).json({ message: "Method not allowed" });
  }

  try {
    const {
      salonId,
      barberId,
      service,
      customerName,
      customerPhone,
      estimatedDuration,
    } = req.body;

    // Validation
    if (!salonId || !barberId || !service || !customerName) {
      console.error("Missing fields:", {
        salonId,
        barberId,
        service,
        customerName,
      });
      return res.status(400).json({ message: "Missing required fields" });
    }

    const client = await clientPromise;
    const db = client.db("techtrims");

    // Generate unique booking code
    // Get salon details for initials
    const salon = await db.collection("salons").findOne({
      _id: new ObjectId(salonId),
    });

    // Generate short booking code based on salon name
    const generateShortBookingCode = (salonName) => {
      // Get initials from salon name (e.g., "Singhania Trims" -> "ST")
      const words = salonName.trim().split(" ");
      let initials = "";

      if (words.length >= 2) {
        // Take first letter of first two words
        initials = words[0][0] + words[1][0];
      } else if (words.length === 1) {
        // Take first two letters if single word
        initials = words[0].substring(0, 2);
      }

      initials = initials.toUpperCase();

      // Generate 4-digit random number
      const randomNumber = Math.floor(1000 + Math.random() * 9000);

      // Generate random letter (A-Z)
      const randomLetter = String.fromCharCode(
        65 + Math.floor(Math.random() * 26)
      );

      return `${initials}-${randomNumber}${randomLetter}`;
    };

    const bookingCode = generateShortBookingCode(
      salon?.salonName || "TechTrims"
    );

    // Create booking with 45-minute expiry
    const now = new Date();
    const expiresAt = new Date(now.getTime() + 45 * 60 * 1000);

    const bookingDoc = {
      salonId: new ObjectId(salonId),
      barberId: new ObjectId(barberId),
      customerName,
      customerPhone: customerPhone || "",
      service,
      bookingCode,
      queueStatus: "RED",
      status: "confirmed", // ✅ ADD THIS
      estimatedDuration: estimatedDuration || 5,
      expiresAt,
      isExpired: false,
      bookingType: "WALKIN",
      createdAt: now,
      updatedAt: now,
    };

    const result = await db.collection("bookings").insertOne(bookingDoc);

    // Update barber queue count
    await db
      .collection("barbers")
      .updateOne({ _id: new ObjectId(barberId) }, { $inc: { queueLength: 1 } });

    res.status(201).json({
      success: true,
      booking: {
        bookingId: result.insertedId.toString(),
        bookingCode,
        expiresAt: expiresAt.toISOString(),
      },
    });
  } catch (error) {
    console.error("Create walk-in booking error:", error);
    res
      .status(500)
      .json({ message: "Internal server error", error: error.message });
  }
}
</file>

<file path="src/pages/api/walkin/salon-state.js">
import clientPromise from "../../../lib/mongodb";
import { ObjectId } from "mongodb";

export default async function handler(req, res) {
  if (req.method !== "GET") {
    return res.status(405).json({ message: "Method not allowed" });
  }

  try {
    const { salonId } = req.query;

    if (!salonId) {
      return res.status(400).json({ message: "salonId is required" });
    }

    const client = await clientPromise;
    const db = client.db("techtrims");

    const now = new Date();
    const expiredResult = await db.collection("bookings").updateMany(
      {
        salonId: new ObjectId(salonId),
        queueStatus: "RED",
        expiresAt: { $lt: now },
        isExpired: false,
      },
      {
        $set: {
          isExpired: true,
          queueStatus: "EXPIRED",
        },
      }
    );

    console.log(`Auto-expired ${expiredResult.modifiedCount} bookings`);

    // Get all barbers
    const barbers = await db
      .collection("barbers")
      .find({
        salonId: new ObjectId(salonId),
      })
      .toArray();

    // Simple barber states
    const barberStates = await Promise.all(
      barbers.map(async (barber) => {
        let timeLeft = 0;
        let currentCustomer = null;

        if (
          barber.currentStatus === "OCCUPIED" &&
          barber.currentServiceEndTime
        ) {
          const now = new Date();
          const endTime = new Date(barber.currentServiceEndTime);
          timeLeft = Math.max(0, Math.ceil((endTime - now) / 1000 / 60));
          currentCustomer = barber.currentCustomerName || null;
        }

        // Count queue for this barber
        const queueCount = await db.collection("bookings").countDocuments({
          barberId: barber._id,
          queueStatus: "ORANGE",
          isExpired: { $ne: true },
        });

        return {
          barberId: barber._id.toString(),
          name: barber.name,
          chairNumber: barber.chairNumber || 1,
          status: barber.currentStatus || "AVAILABLE",
          timeLeft,
          queueCount,
          currentCustomer,
        };
      })
    );

    // Count RED bookings - EXCLUDE EXPIRED BY TIME
    const redCount = await db.collection("bookings").countDocuments({
      salonId: new ObjectId(salonId),
      queueStatus: "RED",
      isExpired: { $ne: true },
      expiresAt: { $gt: now }, // ✅ Only count if expiry is in future
    });

    // Count ORANGE bookings
    const orangeCount = await db.collection("bookings").countDocuments({
      salonId: new ObjectId(salonId),
      queueStatus: "ORANGE",
      isExpired: { $ne: true },
      expiresAt: { $gt: now }, // ✅ Check expiry
    });

    // Count GREEN bookings
    const greenCount = await db.collection("bookings").countDocuments({
      salonId: new ObjectId(salonId),
      queueStatus: "GREEN",
      isExpired: { $ne: true },
      // GREEN doesn't need expiry check (already in service)
    });

    const availableCount = barbers.filter((b) => !b.currentBookingId).length;

    // ✅ Calculate average wait time from current services
    const servingBookings = await db
      .collection("bookings")
      .find({
        salonId: new ObjectId(salonId),
        queueStatus: "GREEN",
        isExpired: { $ne: true },
      })
      .toArray();

    let totalTimeLeft = 0;
    servingBookings.forEach((b) => {
      if (b.expectedCompletionTime) {
        const timeLeft = Math.max(
          0,
          Math.ceil(
            (new Date(b.expectedCompletionTime) - new Date()) / 1000 / 60
          )
        );
        totalTimeLeft += timeLeft;
      }
    });

    const avgWaitTime =
      orangeCount > 0
        ? Math.round((totalTimeLeft + orangeCount * 30) / orangeCount)
        : 0;

    res.status(200).json({
      barbers: barberStates,
      totalServing: greenCount,
      totalWaiting: orangeCount,
      totalBooked: redCount,
      availableNow: barberStates.filter((b) => b.status === "AVAILABLE").length,
      avgWaitTime,
      statusCounts: {
        RED: redCount,
        ORANGE: orangeCount,
        GREEN: greenCount,
      },
      lastUpdated: new Date().toISOString(),
    });
  } catch (error) {
    console.error("Salon state error:", error);
    res.status(500).json({
      message: "Internal server error",
      error: error.message,
      stack: error.stack,
    });
  }
}
</file>

<file path="src/pages/api/walkin/verify-arrival.js">
import clientPromise from "../../../lib/mongodb";
import { ObjectId } from "mongodb";

export default async function handler(req, res) {
  if (req.method !== "POST") {
    return res
      .status(405)
      .json({ success: false, message: "Method not allowed" });
  }

  try {
    const { bookingCode, salonId } = req.body;

    console.log("Received:", { bookingCode, salonId });

    if (!bookingCode) {
      return res
        .status(400)
        .json({ success: false, message: "Booking code required" });
    }

    const client = await clientPromise;
    const db = client.db("techtrims");

    const booking = await db.collection("bookings").findOne({
      bookingCode: bookingCode.toUpperCase(),
      salonId: new ObjectId(salonId),
    });

    console.log("Found booking:", booking);

    if (!booking) {
      return res
        .status(404)
        .json({
          success: false,
          message: "Booking not found. Check the code.",
        });
    }

    if (booking.queueStatus !== "RED") {
      return res.status(400).json({
        success: false,
        message: `Already checked in (Status: ${booking.queueStatus})`,
      });
    }

    await db.collection("bookings").updateOne(
      { _id: booking._id },
      {
        $set: {
          queueStatus: "ORANGE",
          status: "arrived",
          arrivedAt: new Date(),
          updatedAt: new Date(),
        },
      }
    );

    const queuePosition = await db.collection("bookings").countDocuments({
      salonId: new ObjectId(salonId),
      queueStatus: "ORANGE",
    });

    res.status(200).json({
      success: true,
      message: "Customer checked in successfully",
      booking: {
        customerName: booking.customerName,
        queuePosition,
      },
    });
  } catch (error) {
    console.error("Verify arrival error:", error);
    res
      .status(500)
      .json({ success: false, message: "Server error: " + error.message });
  }
}
</file>

<file path="src/pages/auth/reset-password.js">
import { useState, useEffect } from "react";
import { useRouter } from "next/router";
import styles from "../../styles/Auth/UserAuth.module.css";

export default function ResetPassword() {
  const router = useRouter();
  const { token } = router.query;
  const [password, setPassword] = useState("");
  const [confirmPassword, setConfirmPassword] = useState("");
  const [loading, setLoading] = useState(false);
  const [showPassword, setShowPassword] = useState(false);

  const handleSubmit = async (e) => {
    e.preventDefault();

    if (!token) {
      alert("Invalid reset link");
      return;
    }

    if (password !== confirmPassword) {
      alert("Passwords do not match");
      return;
    }

    if (password.length < 8) {
      alert("Password must be at least 8 characters long");
      return;
    }

    setLoading(true);
    try {
      const response = await fetch("/api/auth/reset-password", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ token, newPassword: password }),
      });

      const data = await response.json();

      if (response.ok) {
        alert("✅ Password reset successfully! Redirecting to login...");
        setTimeout(() => router.push("/auth/user/login"), 2000);
      } else {
        alert(data.message || "Failed to reset password");
      }
    } catch (error) {
      alert("Network error. Please try again.");
    } finally {
      setLoading(false);
    }
  };

  return (
    <div className={styles.container}>
      <div className={styles.authCard}>
        <h1 className={styles.title}>🔐 Reset Password</h1>
        <form onSubmit={handleSubmit} className={styles.form}>
          <div className={styles.formGroup}>
            <input
              type={showPassword ? "text" : "password"}
              placeholder="New Password (min 8 chars)"
              value={password}
              onChange={(e) => setPassword(e.target.value)}
              required
              minLength="8"
              disabled={loading}
            />
          </div>
          <div className={styles.formGroup}>
            <input
              type={showPassword ? "text" : "password"}
              placeholder="Confirm New Password"
              value={confirmPassword}
              onChange={(e) => setConfirmPassword(e.target.value)}
              required
              disabled={loading}
            />
          </div>
          <label className={styles.checkbox}>
            <input
              type="checkbox"
              checked={showPassword}
              onChange={(e) => setShowPassword(e.target.checked)}
            />
            Show passwords
          </label>
          <button
            type="submit"
            className={styles.submitButton}
            disabled={loading || !token}
          >
            {loading ? "Resetting..." : "Reset Password"}
          </button>
        </form>
      </div>
    </div>
  );
}
</file>

<file path="src/pages/salons/bookings/[id].js">
// pages/salons/bookings/[id].jsx
import { useEffect, useState } from "react";
import { useRouter } from "next/router";

export default function BookingDetailPage() {
  const router = useRouter();
  const { id } = router.query;

  const [booking, setBooking] = useState(null);
  const [loading, setLoading] = useState(true);
  const [saving, setSaving] = useState(false);
  const [deleting, setDeleting] = useState(false);
  const [error, setError] = useState("");
  const [form, setForm] = useState({
    customerName: "",
    customerPhone: "",
    serviceId: "",
    appointmentAt: "",
    status: "",
  });

  // Fetch booking data
  useEffect(() => {
    if (!id) return;
    const fetchBooking = async () => {
      setLoading(true);
      try {
        const res = await fetch(`/api/salons/bookings/${id}`);
        if (!res.ok) throw new Error("Booking not found");
        const data = await res.json();
        setBooking(data);
        setForm({
          customerName: data.customerName || "",
          customerPhone: data.customerPhone || "",
          serviceId: data.serviceId || "",
          appointmentAt: data.appointmentAt
            ? new Date(data.appointmentAt).toISOString().slice(0, 16)
            : "",
          status: data.status || "pending",
        });
      } catch (err) {
        console.error(err);
        setError(err.message);
      } finally {
        setLoading(false);
      }
    };
    fetchBooking();
  }, [id]);

  // Update booking
  const handleUpdate = async (e) => {
    e.preventDefault();
    setSaving(true);
    setError("");
    try {
      const res = await fetch(`/api/salons/bookings/${id}`, {
        method: "PUT",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(form),
      });
      if (!res.ok) {
        const err = await res.json();
        throw new Error(err.error || "Update failed");
      }
      const updated = await res.json();
      setBooking(updated);
      alert("Booking updated successfully!");
    } catch (err) {
      console.error(err);
      setError(err.message);
    } finally {
      setSaving(false);
    }
  };

  // Delete booking
  const handleDelete = async () => {
    if (!confirm("Are you sure you want to delete this booking?")) return;
    setDeleting(true);
    setError("");
    try {
      const res = await fetch(`/api/salons/bookings/${id}`, {
        method: "DELETE",
      });
      if (!res.ok) throw new Error("Delete failed");
      alert("Booking deleted successfully!");
      router.push("/salons/bookings"); // redirect to booking list
    } catch (err) {
      console.error(err);
      setError(err.message);
    } finally {
      setDeleting(false);
    }
  };

  if (loading) return <p className="p-4">Loading booking...</p>;
  if (!booking)
    return <p className="p-4 text-red-500">{error || "Booking not found"}</p>;

  return (
    <div className="p-6 max-w-xl mx-auto space-y-6">
      <h1 className="text-2xl font-bold">Booking Details</h1>

      {error && <p className="text-red-500">{error}</p>}

      <form
        onSubmit={handleUpdate}
        className="grid gap-4 bg-white p-6 rounded shadow-md"
      >
        <div>
          <label className="block font-semibold">Customer Name</label>
          <input
            type="text"
            value={form.customerName}
            onChange={(e) => setForm({ ...form, customerName: e.target.value })}
            required
            className="w-full border rounded px-3 py-2"
          />
        </div>

        <div>
          <label className="block font-semibold">Customer Phone</label>
          <input
            type="text"
            value={form.customerPhone}
            onChange={(e) =>
              setForm({ ...form, customerPhone: e.target.value })
            }
            required
            className="w-full border rounded px-3 py-2"
          />
        </div>

        <div>
          <label className="block font-semibold">Service ID</label>
          <input
            type="text"
            value={form.serviceId}
            onChange={(e) => setForm({ ...form, serviceId: e.target.value })}
            required
            className="w-full border rounded px-3 py-2"
          />
        </div>

        <div>
          <label className="block font-semibold">Appointment Date & Time</label>
          <input
            type="datetime-local"
            value={form.appointmentAt}
            onChange={(e) =>
              setForm({ ...form, appointmentAt: e.target.value })
            }
            required
            className="w-full border rounded px-3 py-2"
          />
        </div>

        <div>
          <label className="block font-semibold">Status</label>
          <select
            value={form.status}
            onChange={(e) => setForm({ ...form, status: e.target.value })}
            className="w-full border rounded px-3 py-2"
          >
            <option value="pending">Pending</option>
            <option value="confirmed">Confirmed</option>
            <option value="completed">Completed</option>
            <option value="canceled">Canceled</option>
          </select>
        </div>

        <div className="flex justify-between items-center mt-4">
          <button
            type="submit"
            disabled={saving}
            className="bg-blue-600 text-white px-4 py-2 rounded hover:bg-blue-700 disabled:opacity-50"
          >
            {saving ? "Saving..." : "Update Booking"}
          </button>
          <button
            type="button"
            onClick={handleDelete}
            disabled={deleting}
            className="bg-red-600 text-white px-4 py-2 rounded hover:bg-red-700 disabled:opacity-50"
          >
            {deleting ? "Deleting..." : "Delete Booking"}
          </button>
        </div>
      </form>

      <div className="bg-gray-50 p-4 rounded shadow">
        <h2 className="font-semibold mb-2">Current Booking Info:</h2>
        <pre className="text-sm">{JSON.stringify(booking, null, 2)}</pre>
      </div>
    </div>
  );
}
</file>

<file path="src/pages/salons/bookings/index.js">
// src/pages/salons/bookings/index.jsx
import { useEffect, useState } from "react";
import { useRouter } from "next/router";

export default function BookingsPage() {
  const router = useRouter();
  const { salonId } = router.query; // salonId passed via query param
  const [bookings, setBookings] = useState([]);
  const [loading, setLoading] = useState(false);
  const [form, setForm] = useState({
    customerName: "",
    customerPhone: "",
    serviceId: "",
    appointmentAt: "",
  });

  // fetch bookings
  useEffect(() => {
    if (!salonId) return;
    setLoading(true);
    fetch(`/api/salons/bookings?salonId=${salonId}`)
      .then((res) => res.json())
      .then((data) => {
        setBookings(data);
        setLoading(false);
      })
      .catch(() => setLoading(false));
  }, [salonId]);

  // submit booking
  const handleSubmit = async (e) => {
    e.preventDefault();
    if (!salonId) return alert("No salon selected");

    const res = await fetch(`/api/salons/bookings?salonId=${salonId}`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(form),
    });

    if (res.ok) {
      const newBooking = await res.json();
      setBookings((prev) => [...prev, newBooking]);
      setForm({
        customerName: "",
        customerPhone: "",
        serviceId: "",
        appointmentAt: "",
      });
    } else {
      const err = await res.json();
      alert(err.error || "Failed to create booking");
    }
  };

  return (
    <div style={{ padding: "2rem" }}>
      <h1>Bookings</h1>

      {/* Add Booking Form */}
      <form
        onSubmit={handleSubmit}
        style={{
          marginBottom: "2rem",
          display: "grid",
          gap: "0.5rem",
          maxWidth: "400px",
        }}
      >
        <input
          type="text"
          placeholder="Customer Name"
          value={form.customerName}
          onChange={(e) => setForm({ ...form, customerName: e.target.value })}
          required
        />
        <input
          type="text"
          placeholder="Customer Phone"
          value={form.customerPhone}
          onChange={(e) => setForm({ ...form, customerPhone: e.target.value })}
          required
        />
        <input
          type="text"
          placeholder="Service ID"
          value={form.serviceId}
          onChange={(e) => setForm({ ...form, serviceId: e.target.value })}
          required
        />
        <input
          type="datetime-local"
          value={form.appointmentAt}
          onChange={(e) => setForm({ ...form, appointmentAt: e.target.value })}
          required
        />
        <button type="submit">Add Booking</button>
      </form>

      {/* Booking List */}
      {loading ? (
        <p>Loading...</p>
      ) : bookings.length === 0 ? (
        <p>No bookings yet.</p>
      ) : (
        <table
          border="1"
          cellPadding="8"
          style={{ borderCollapse: "collapse" }}
        >
          <thead>
            <tr>
              <th>Customer</th>
              <th>Phone</th>
              <th>Service</th>
              <th>Appointment</th>
              <th>Status</th>
            </tr>
          </thead>
          <tbody>
            {bookings.map((b) => (
              <tr key={b._id}>
                <td>{b.customerName}</td>
                <td>{b.customerPhone}</td>
                <td>{b.serviceId}</td>
                <td>{new Date(b.appointmentAt).toLocaleString()}</td>
                <td>{b.status || "pending"}</td>
              </tr>
            ))}
          </tbody>
        </table>
      )}
    </div>
  );
}
</file>

<file path="src/pages/salons/profile.js">
// pages/salons/profile.js
import { useEffect, useState } from "react";
import OwnerSidebar from "../../components/OwnerSidebar";

export default function SalonProfilePage() {
  const [salon, setSalon] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    async function fetchSalon() {
      try {
        const res = await fetch("/api/salons/profile");
        if (!res.ok) throw new Error("Failed to fetch salon profile");
        const data = await res.json();
        setSalon(data);
      } catch (err) {
        setError(err.message);
      } finally {
        setLoading(false);
      }
    }
    fetchSalon();
  }, []);

  return (
    <div className="flex">
      <OwnerSidebar />

      <main className="flex-1 p-6">
        <h1 className="text-3xl font-bold mb-6">Salon Profile</h1>

        {salon && (
          <div className="bg-white shadow rounded-lg p-6 space-y-4">
            <h2 className="text-2xl font-semibold">{salon.salonName}</h2>
            <p>
              <strong>Owner:</strong> {salon.ownerName}
            </p>
            <p>
              <strong>Email:</strong> {salon.email}
            </p>
            <p>
              <strong>Phone:</strong> {salon.phone}
            </p>
            <p>
              <strong>Status:</strong>{" "}
              {salon.isActive ? "✅ Active" : "❌ Inactive"}
            </p>
            <p>
              <strong>Verified:</strong> {salon.isVerified ? "✅ Yes" : "❌ No"}
            </p>
            <p>
              <strong>Amenities:</strong>{" "}
              {salon.amenities?.length
                ? salon.amenities.join(", ")
                : "Not listed"}
            </p>
            <p>
              <strong>Created At:</strong>{" "}
              {new Date(salon.createdAt).toLocaleString()}
            </p>
          </div>
        )}
      </main>
    </div>
  );
}
</file>

<file path="src/pages/salons/register.js">
// pages/salons/register.js
import React from "react";
import SalonRegisterForm from "../../components/Salon/SalonRegisterForm";

const SalonRegisterPage = () => {
  return (
    <div>
      <SalonRegisterForm />
    </div>
  );
};

export default SalonRegisterPage;
</file>

<file path="src/pages/salons/services/[id].js">
// pages/salons/services/[id].jsx
import { useRouter } from "next/router";
import { useEffect, useState } from "react";
import axios from "axios";

export default function ServicePage() {
  const router = useRouter();
  const { id } = router.query;

  const [service, setService] = useState(null);
  const [loading, setLoading] = useState(true);
  const [saving, setSaving] = useState(false);
  const [error, setError] = useState("");

  // Fetch the service by ID
  useEffect(() => {
    if (!id) return;

    const fetchService = async () => {
      setLoading(true);
      try {
        const res = await axios.get(`/api/salons/services/${id}`);
        setService(res.data);
        setError("");
      } catch (err) {
        console.error(err);
        setError("Failed to fetch service");
      }
      setLoading(false);
    };

    fetchService();
  }, [id]); // ✅ only depends on `id`

  // Handle form changes
  const handleChange = (e) => {
    const { name, value } = e.target;
    setService({ ...service, [name]: value });
  };

  // Save updated service
  const handleSave = async () => {
    if (!service) return;
    setSaving(true);
    try {
      const res = await axios.put(`/api/salons/services/${id}`, service);
      setService(res.data);
      setError("");
      alert("Service updated successfully!");
    } catch (err) {
      console.error(err);
      setError("Failed to update service");
    }
    setSaving(false);
  };

  // Delete service
  const handleDelete = async () => {
    if (!window.confirm("Are you sure you want to delete this service?"))
      return;
    try {
      await axios.delete(`/api/salons/services/${id}`);
      alert("Service deleted successfully!");
      router.push("/salons/services"); // Redirect after deletion
    } catch (err) {
      console.error(err);
      setError("Failed to delete service");
    }
  };

  if (loading) return <p>Loading service...</p>;
  if (!service) return <p>No service found.</p>;

  return (
    <div className="max-w-2xl mx-auto p-6">
      <h1 className="text-2xl font-bold mb-4">Edit Service</h1>
      {error && <p className="text-red-500 mb-4">{error}</p>}

      <div className="mb-4">
        <label className="block font-medium">Name:</label>
        <input
          type="text"
          name="name"
          value={service.name || ""}
          onChange={handleChange}
          className="w-full border rounded px-3 py-2 mt-1"
        />
      </div>

      <div className="mb-4">
        <label className="block font-medium">Description:</label>
        <textarea
          name="description"
          value={service.description || ""}
          onChange={handleChange}
          className="w-full border rounded px-3 py-2 mt-1"
        />
      </div>

      <div className="mb-4">
        <label className="block font-medium">Price:</label>
        <input
          type="number"
          name="price"
          value={service.price || 0}
          onChange={handleChange}
          className="w-full border rounded px-3 py-2 mt-1"
        />
      </div>

      <div className="flex gap-4">
        <button
          onClick={handleSave}
          disabled={saving}
          className="bg-blue-600 text-white px-4 py-2 rounded hover:bg-blue-700"
        >
          {saving ? "Saving..." : "Save Changes"}
        </button>
        <button
          onClick={handleDelete}
          className="bg-red-600 text-white px-4 py-2 rounded hover:bg-red-700"
        >
          Delete Service
        </button>
      </div>
    </div>
  );
}
</file>

<file path="src/pages/salons/services/index.js">
// pages/salons/[salonId]/services.jsx
import { useEffect, useState } from "react";
import { useRouter } from "next/router";
import axios from "axios";
import Link from "next/link";

export default function SalonServicesPage() {
  const router = useRouter();
  const { salonId } = router.query;

  const [services, setServices] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState("");
  const [newService, setNewService] = useState({
    title: "",
    description: "",
    price: 0,
  });
  const [creating, setCreating] = useState(false);

  // Fetch services
  useEffect(() => {
    if (!salonId) return;

    const fetchServices = async () => {
      setLoading(true);
      try {
        const res = await axios.get(`/api/salons/services?salonId=${salonId}`);
        setServices(res.data);
        setError("");
      } catch (err) {
        console.error(err);
        setError("Failed to fetch services");
      }
      setLoading(false);
    };

    fetchServices();
  }, [salonId]);

  // Handle input changes
  const handleChange = (e) => {
    const { name, value } = e.target;
    setNewService({ ...newService, [name]: value });
  };

  // Create new service
  const handleCreate = async () => {
    if (!newService.title) return alert("Title is required");
    setCreating(true);
    try {
      const res = await axios.post("/api/salons/services", {
        ...newService,
        salonId,
      });
      setServices([...services, res.data]);
      setNewService({ title: "", description: "", price: 0 });
      setError("");
    } catch (err) {
      console.error(err);
      setError("Failed to create service");
    }
    setCreating(false);
  };

  if (loading) return <p className="p-6">Loading services...</p>;

  return (
    <div className="max-w-4xl mx-auto p-6">
      <h1 className="text-3xl font-bold mb-6">Services for Salon {salonId}</h1>

      {error && <p className="text-red-500 mb-4">{error}</p>}

      {/* New Service Form */}
      <div className="mb-8 p-4 border rounded shadow">
        <h2 className="text-xl font-semibold mb-2">Add New Service</h2>
        <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
          <input
            type="text"
            name="title"
            placeholder="Title"
            value={newService.title}
            onChange={handleChange}
            className="border rounded px-3 py-2 w-full"
          />
          <input
            type="number"
            name="price"
            placeholder="Price"
            value={newService.price}
            onChange={handleChange}
            className="border rounded px-3 py-2 w-full"
          />
          <input
            type="text"
            name="description"
            placeholder="Description"
            value={newService.description}
            onChange={handleChange}
            className="border rounded px-3 py-2 w-full"
          />
        </div>
        <button
          onClick={handleCreate}
          disabled={creating}
          className="mt-3 bg-green-600 text-white px-4 py-2 rounded hover:bg-green-700"
        >
          {creating ? "Creating..." : "Add Service"}
        </button>
      </div>

      {/* Services List */}
      <div>
        <h2 className="text-xl font-semibold mb-2">Existing Services</h2>
        {services.length === 0 ? (
          <p>No services yet.</p>
        ) : (
          <div className="overflow-x-auto">
            <table className="min-w-full border rounded">
              <thead className="bg-gray-100">
                <tr>
                  <th className="px-4 py-2 border">Title</th>
                  <th className="px-4 py-2 border">Description</th>
                  <th className="px-4 py-2 border">Price</th>
                  <th className="px-4 py-2 border">Actions</th>
                </tr>
              </thead>
              <tbody>
                {services.map((s) => (
                  <tr key={s._id} className="hover:bg-gray-50">
                    <td className="px-4 py-2 border">{s.title}</td>
                    <td className="px-4 py-2 border">{s.description}</td>
                    <td className="px-4 py-2 border">{s.price}</td>
                    <td className="px-4 py-2 border">
                      <Link
                        href={`/salons/services/${s._id}`}
                        className="text-blue-600 hover:underline mr-3"
                      >
                        Edit
                      </Link>
                    </td>
                  </tr>
                ))}
              </tbody>
            </table>
          </div>
        )}
      </div>
    </div>
  );
}
</file>

<file path="src/pages/salons/staff/[id].js">
// pages/salons/staff/[id].js
import { useRouter } from "next/router";
import { useEffect, useState } from "react";

export default function StaffPage() {
  const router = useRouter();
  const { id } = router.query;

  const [staff, setStaff] = useState(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    if (!id) return;
    const fetchStaff = async () => {
      try {
        const res = await fetch(`/api/salons/staff/${id}`);
        if (!res.ok) throw new Error("Failed to fetch staff");
        const data = await res.json();
        setStaff(data);
      } catch (err) {
        console.error(err);
      } finally {
        setLoading(false);
      }
    };
    fetchStaff();
  }, [id]);

  if (loading) return <p>Loading...</p>;
  if (!staff) return <p>Staff not found</p>;

  return (
    <div>
      <h1>{staff.name}</h1>
      <p>Email: {staff.email}</p>
      <p>Role: {staff.role}</p>
    </div>
  );
}
</file>

<file path="src/pages/salons/staff/index.js">
// pages/salons/[salonId]/staff.jsx
import { useEffect, useState } from "react";
import { useRouter } from "next/router";
import axios from "axios";
import Link from "next/link";

export default function SalonStaffPage() {
  const router = useRouter();
  const { salonId } = router.query;

  const [staffList, setStaffList] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState("");
  const [newStaff, setNewStaff] = useState({
    name: "",
    email: "",
    phone: "",
    role: "",
  });
  const [creating, setCreating] = useState(false);

  // Fetch staff
  useEffect(() => {
    if (!salonId) return;

    const fetchStaff = async () => {
      setLoading(true);
      try {
        const res = await axios.get(`/api/salons/staff?salonId=${salonId}`);
        setStaffList(res.data);
        setError("");
      } catch (err) {
        console.error(err);
        setError("Failed to fetch staff");
      }
      setLoading(false);
    };

    fetchStaff();
  }, [salonId]);

  // Handle input changes
  const handleChange = (e) => {
    const { name, value } = e.target;
    setNewStaff({ ...newStaff, [name]: value });
  };

  // Create new staff
  const handleCreate = async () => {
    if (!newStaff.name) return alert("Name is required");
    setCreating(true);
    try {
      const res = await axios.post("/api/salons/staff", {
        ...newStaff,
        salonId,
      });
      setStaffList([...staffList, res.data]);
      setNewStaff({ name: "", email: "", phone: "", role: "" });
      setError("");
    } catch (err) {
      console.error(err);
      setError("Failed to create staff");
    }
    setCreating(false);
  };

  if (loading) return <p className="p-6">Loading staff...</p>;

  return (
    <div className="max-w-4xl mx-auto p-6">
      <h1 className="text-3xl font-bold mb-6">Staff for Salon {salonId}</h1>

      {error && <p className="text-red-500 mb-4">{error}</p>}

      {/* New Staff Form */}
      <div className="mb-8 p-4 border rounded shadow">
        <h2 className="text-xl font-semibold mb-2">Add New Staff</h2>
        <div className="grid grid-cols-1 md:grid-cols-4 gap-4">
          <input
            type="text"
            name="name"
            placeholder="Name"
            value={newStaff.name}
            onChange={handleChange}
            className="border rounded px-3 py-2 w-full"
          />
          <input
            type="email"
            name="email"
            placeholder="Email"
            value={newStaff.email}
            onChange={handleChange}
            className="border rounded px-3 py-2 w-full"
          />
          <input
            type="text"
            name="phone"
            placeholder="Phone"
            value={newStaff.phone}
            onChange={handleChange}
            className="border rounded px-3 py-2 w-full"
          />
          <input
            type="text"
            name="role"
            placeholder="Role"
            value={newStaff.role}
            onChange={handleChange}
            className="border rounded px-3 py-2 w-full"
          />
        </div>
        <button
          onClick={handleCreate}
          disabled={creating}
          className="mt-3 bg-green-600 text-white px-4 py-2 rounded hover:bg-green-700"
        >
          {creating ? "Adding..." : "Add Staff"}
        </button>
      </div>

      {/* Staff List */}
      <div>
        <h2 className="text-xl font-semibold mb-2">Existing Staff</h2>
        {staffList.length === 0 ? (
          <p>No staff yet.</p>
        ) : (
          <div className="overflow-x-auto">
            <table className="min-w-full border rounded">
              <thead className="bg-gray-100">
                <tr>
                  <th className="px-4 py-2 border">Name</th>
                  <th className="px-4 py-2 border">Email</th>
                  <th className="px-4 py-2 border">Phone</th>
                  <th className="px-4 py-2 border">Role</th>
                  <th className="px-4 py-2 border">Actions</th>
                </tr>
              </thead>
              <tbody>
                {staffList.map((st) => (
                  <tr key={st._id} className="hover:bg-gray-50">
                    <td className="px-4 py-2 border">{st.name}</td>
                    <td className="px-4 py-2 border">{st.email}</td>
                    <td className="px-4 py-2 border">{st.phone}</td>
                    <td className="px-4 py-2 border">{st.role}</td>
                    <td className="px-4 py-2 border">
                      <Link
                        href={`/salons/staff/${st._id}`}
                        className="text-blue-600 hover:underline"
                      >
                        Edit
                      </Link>
                    </td>
                  </tr>
                ))}
              </tbody>
            </table>
          </div>
        )}
      </div>
    </div>
  );
}
</file>

<file path="src/pages/styles/globals.css">
* {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
}

:root {
  /* Light Mode Colors */
  --gold-primary: #d4af37;
  --gold-dark: #b8941f;
  --gold-light: #f5e99b;
  --contrast-dark: #1a1a1a;
  --contrast-medium: #333333;
  --contrast-light: #666666;
  --background-primary: #ffffff;
  --background-secondary: #f8f8f8;
  --text-primary: #1a1a1a;
  --text-secondary: #666666;
  --border-color: #e5e5e5;
  --success: #22c55e;
  --error: #ef4444;
  --warning: #f59e0b;

  /* Dark Mode Colors */
  --dark-gold-primary: #ffd700;
  --dark-gold-dark: #e6c200;
  --dark-gold-light: #fff4b3;
  --dark-contrast-dark: #ffffff;
  --dark-contrast-medium: #cccccc;
  --dark-contrast-light: #999999;
  --dark-background-primary: #121212;
  --dark-background-secondary: #1e1e1e;
  --dark-text-primary: #ffffff;
  --dark-text-secondary: #cccccc;
  --dark-border-color: #333333;
}

[data-theme="dark"] {
  --gold-primary: var(--dark-gold-primary);
  --gold-dark: var(--dark-gold-dark);
  --gold-light: var(--dark-gold-light);
  --contrast-dark: var(--dark-contrast-dark);
  --contrast-medium: var(--dark-contrast-medium);
  --contrast-light: var(--dark-contrast-light);
  --background-primary: var(--dark-background-primary);
  --background-secondary: var(--dark-background-secondary);
  --text-primary: var(--dark-text-primary);
  --text-secondary: var(--dark-text-secondary);
  --border-color: var(--dark-border-color);
}

html,
body {
  font-family: "Inter", -apple-system, BlinkMacSystemFont, "Segoe UI", "Roboto",
    sans-serif;
  line-height: 1.6;
  color: var(--text-primary);
  background-color: var(--background-primary);
  transition: background-color 0.3s ease, color 0.3s ease;
}

/* Luxury scrollbar */
::-webkit-scrollbar {
  width: 8px;
}

::-webkit-scrollbar-track {
  background: var(--background-secondary);
}

::-webkit-scrollbar-thumb {
  background: var(--gold-primary);
  border-radius: 4px;
}

::-webkit-scrollbar-thumb:hover {
  background: var(--gold-dark);
}

/* Common button styles */
.btn {
  padding: 12px 24px;
  border-radius: 8px;
  border: none;
  cursor: pointer;
  font-weight: 600;
  font-size: 16px;
  transition: all 0.3s ease;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  gap: 8px;
  text-decoration: none;
}

.btn-primary {
  background: linear-gradient(
    135deg,
    var(--gold-primary) 0%,
    var(--gold-dark) 100%
  );
  color: var(--contrast-dark);
  box-shadow: 0 4px 15px rgba(212, 175, 55, 0.3);
}

.btn-primary:hover {
  transform: translateY(-2px);
  box-shadow: 0 8px 25px rgba(212, 175, 55, 0.4);
}

.btn-secondary {
  background: transparent;
  color: var(--text-primary);
  border: 2px solid var(--border-color);
}

.btn-secondary:hover {
  border-color: var(--gold-primary);
  color: var(--gold-primary);
}

/* Form styles */
.form-group {
  margin-bottom: 20px;
}

.form-label {
  display: block;
  margin-bottom: 8px;
  font-weight: 500;
  color: var(--text-primary);
}

.form-input {
  width: 100%;
  padding: 12px 16px;
  border: 2px solid var(--border-color);
  border-radius: 8px;
  font-size: 16px;
  background-color: var(--background-primary);
  color: var(--text-primary);
  transition: all 0.3s ease;
}

.form-input:focus {
  outline: none;
  border-color: var(--gold-primary);
  box-shadow: 0 0 0 3px rgba(212, 175, 55, 0.1);
}

.form-select {
  width: 100%;
  padding: 12px 16px;
  border: 2px solid var(--border-color);
  border-radius: 8px;
  font-size: 16px;
  background-color: var(--background-primary);
  color: var(--text-primary);
  cursor: pointer;
}

/* Card styles */
.card {
  background: var(--background-primary);
  border-radius: 12px;
  padding: 24px;
  box-shadow: 0 4px 20px rgba(0, 0, 0, 0.08);
  border: 1px solid var(--border-color);
  transition: all 0.3s ease;
}

.card:hover {
  transform: translateY(-4px);
  box-shadow: 0 8px 30px rgba(0, 0, 0, 0.12);
}

/* Animation keyframes */
@keyframes fadeIn {
  from {
    opacity: 0;
    transform: translateY(20px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

@keyframes slideIn {
  from {
    opacity: 0;
    transform: translateX(-30px);
  }
  to {
    opacity: 1;
    transform: translateX(0);
  }
}

@keyframes shimmer {
  0% {
    background-position: -200px 0;
  }
  100% {
    background-position: calc(200px + 100%) 0;
  }
}

.animate-fadeIn {
  animation: fadeIn 0.6s ease-out;
}

.animate-slideIn {
  animation: slideIn 0.6s ease-out;
}

/* Luxury gold gradient text */
.gold-gradient-text {
  background: linear-gradient(
    135deg,
    var(--gold-primary) 0%,
    var(--gold-dark) 100%
  );
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
}

/* Loading spinner */
.spinner {
  width: 24px;
  height: 24px;
  border: 3px solid var(--border-color);
  border-top: 3px solid var(--gold-primary);
  border-radius: 50%;
  animation: spin 1s linear infinite;
}

@keyframes spin {
  0% {
    transform: rotate(0deg);
  }
  100% {
    transform: rotate(360deg);
  }
}

/* Mobile optimizations */
@media (max-width: 768px) {
  .btn {
    width: 100%;
    padding: 14px 20px;
  }

  .card {
    padding: 20px;
    margin-bottom: 16px;
  }

  .form-input,
  .form-select {
    font-size: 18px; /* Prevents zoom on iOS */
  }
}
</file>

<file path="src/pages/styles/Home.module.css">
.container {
  min-height: 100vh;
  background: linear-gradient(
    135deg,
    var(--background-primary) 0%,
    var(--background-secondary) 100%
  );
}

.loadingContainer {
  min-height: 100vh;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  gap: 20px;
}

.spinner {
  width: 40px;
  height: 40px;
  border: 4px solid var(--border-color);
  border-top: 4px solid var(--gold-primary);
  border-radius: 50%;
  animation: spin 1s linear infinite;
}

/* Header */
.header {
  background: var(--background-primary);
  border-bottom: 1px solid var(--border-color);
  padding: 16px 0;
  position: sticky;
  top: 0;
  z-index: 100;
  backdrop-filter: blur(10px);
}

.headerContent {
  max-width: 1200px;
  margin: 0 auto;
  padding: 0 20px;
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.logo {
  font-size: 28px;
  font-weight: 700;
  color: var(--text-primary);
}

.goldText {
  background: linear-gradient(
    135deg,
    var(--gold-primary) 0%,
    var(--gold-dark) 100%
  );
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
}

.headerActions {
  display: flex;
  align-items: center;
  gap: 16px;
}

.themeToggle {
  padding: 8px;
  border: none;
  background: transparent;
  border-radius: 8px;
  cursor: pointer;
  font-size: 20px;
  transition: all 0.3s ease;
}

.themeToggle:hover {
  background: var(--background-secondary);
}

.ownerButton {
  padding: 10px 20px;
  background: transparent;
  color: var(--gold-primary);
  border: 2px solid var(--gold-primary);
  border-radius: 8px;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.3s ease;
}

.ownerButton:hover {
  background: var(--gold-primary);
  color: var(--contrast-dark);
}

.loginButton {
  padding: 10px 20px;
  background: linear-gradient(
    135deg,
    var(--gold-primary) 0%,
    var(--gold-dark) 100%
  );
  color: var(--contrast-dark);
  border: none;
  border-radius: 8px;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.3s ease;
}

.loginButton:hover {
  transform: translateY(-2px);
  box-shadow: 0 8px 25px rgba(212, 175, 55, 0.4);
}

/* Welcome Section */
.welcomeSection {
  max-width: 1200px;
  margin: 0 auto;
  padding: 60px 20px 40px;
  text-align: center;
}

.welcomeContent {
  margin-bottom: 40px;
}

.welcomeTitle {
  font-size: 48px;
  font-weight: 700;
  margin-bottom: 16px;
  color: var(--text-primary);
  line-height: 1.2;
}

.welcomeSubtitle {
  font-size: 18px;
  color: var(--text-secondary);
  margin-bottom: 0;
}

.quickStats {
  display: flex;
  justify-content: center;
  gap: 60px;
  margin-top: 40px;
}

.stat {
  text-align: center;
}

.statNumber {
  display: block;
  font-size: 32px;
  font-weight: 700;
  color: var(--gold-primary);
  margin-bottom: 4px;
}

.statLabel {
  font-size: 14px;
  color: var(--text-secondary);
  text-transform: uppercase;
  letter-spacing: 1px;
}

/* Search Section */
.searchSection {
  max-width: 800px;
  margin: 0 auto;
  padding: 0 20px 40px;
}

.searchContainer {
  text-align: center;
}

.searchBox {
  position: relative;
  margin-bottom: 24px;
}

.searchInput {
  width: 100%;
  padding: 16px 60px 16px 20px;
  border: 2px solid var(--border-color);
  border-radius: 50px;
  font-size: 16px;
  background: var(--background-primary);
  color: var(--text-primary);
  transition: all 0.3s ease;
}

.searchInput:focus {
  outline: none;
  border-color: var(--gold-primary);
  box-shadow: 0 0 0 4px rgba(212, 175, 55, 0.1);
}

.searchButton {
  position: absolute;
  right: 8px;
  top: 50%;
  transform: translateY(-50%);
  width: 44px;
  height: 44px;
  background: linear-gradient(
    135deg,
    var(--gold-primary) 0%,
    var(--gold-dark) 100%
  );
  border: none;
  border-radius: 50%;
  cursor: pointer;
  font-size: 18px;
  transition: all 0.3s ease;
}

.searchButton:hover {
  transform: translateY(-50%) scale(1.05);
}

.quickFilters {
  display: flex;
  justify-content: center;
  flex-wrap: wrap;
  gap: 12px;
}

.filterChip {
  padding: 8px 16px;
  background: var(--background-primary);
  border: 2px solid var(--border-color);
  border-radius: 25px;
  font-size: 14px;
  cursor: pointer;
  transition: all 0.3s ease;
}

.filterChip:hover {
  border-color: var(--gold-primary);
  background: var(--gold-primary);
  color: var(--contrast-dark);
}

/* Services Section */
.servicesSection {
  max-width: 1200px;
  margin: 0 auto;
  padding: 60px 20px;
}

.sectionTitle {
  font-size: 32px;
  font-weight: 700;
  text-align: center;
  margin-bottom: 40px;
  color: var(--text-primary);
}

.servicesGrid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
  gap: 24px;
}

.serviceCard {
  background: var(--background-primary);
  border-radius: 16px;
  padding: 32px 24px;
  text-align: center;
  border: 1px solid var(--border-color);
  transition: all 0.3s ease;
  cursor: pointer;
}

.serviceCard:hover {
  transform: translateY(-8px);
  box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
  border-color: var(--gold-primary);
}

.serviceIcon {
  font-size: 48px;
  margin-bottom: 16px;
}

.serviceName {
  font-size: 20px;
  font-weight: 600;
  margin-bottom: 8px;
  color: var(--text-primary);
}

.servicePrice {
  font-size: 24px;
  font-weight: 700;
  color: var(--gold-primary);
  margin-bottom: 4px;
}

.serviceDuration {
  font-size: 14px;
  color: var(--text-secondary);
}

/* Salons Section */
.salonsSection {
  max-width: 1200px;
  margin: 0 auto;
  padding: 60px 20px;
}

.sectionHeader {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 40px;
}

.viewAllButton {
  padding: 10px 20px;
  background: transparent;
  color: var(--gold-primary);
  border: 2px solid var(--gold-primary);
  border-radius: 8px;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.3s ease;
}

.viewAllButton:hover {
  background: var(--gold-primary);
  color: var(--contrast-dark);
}

.salonsCarousel {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
  gap: 24px;
}

.salonCard {
  background: var(--background-primary);
  border-radius: 16px;
  overflow: hidden;
  border: 1px solid var(--border-color);
  transition: all 0.3s ease;
  cursor: pointer;
}

.salonCard:hover {
  box-shadow: 0 20px 40px rgba(0, 0, 0, 0.15);
  border-color: var(--gold-primary);
}

.salonImage {
  position: relative;
  height: 200px;
  overflow: hidden;
}

.salonImage img {
  width: 100%;
  height: 100%;
  object-fit: cover;
  transition: transform 0.3s ease;
}

.salonCard:hover .salonImage img {
  transform: scale(1.05);
}

.salonBadge {
  position: absolute;
  top: 12px;
  right: 12px;
  background: linear-gradient(
    135deg,
    var(--gold-primary) 0%,
    var(--gold-dark) 100%
  );
  color: var(--contrast-dark);
  padding: 4px 12px;
  border-radius: 20px;
  font-size: 12px;
  font-weight: 600;
}

.salonInfo {
  padding: 20px;
}

.salonName {
  font-size: 20px;
  font-weight: 700;
  margin-bottom: 4px;
  color: var(--text-primary);
}

.salonLocation {
  color: var(--text-secondary);
  font-size: 14px;
  margin-bottom: 12px;
}

.salonStats {
  display: flex;
  gap: 16px;
  margin-bottom: 16px;
}

.rating,
.bookings {
  font-size: 14px;
  color: var(--text-secondary);
  display: flex;
  align-items: center;
  gap: 4px;
}

.rating {
  color: var(--gold-primary);
  font-weight: 600;
}

.salonServices {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
  margin-bottom: 20px;
}

.serviceTag {
  background: var(--background-secondary);
  color: var(--text-secondary);
  padding: 4px 8px;
  border-radius: 12px;
  font-size: 12px;
  white-space: nowrap;
}

.bookButton {
  width: 100%;
  padding: 12px;
  background: linear-gradient(
    135deg,
    var(--gold-primary) 0%,
    var(--gold-dark) 100%
  );
  color: var(--contrast-dark);
  border: none;
  border-radius: 8px;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.3s ease;
}

.bookButton:hover {
  transform: translateY(-2px);
  box-shadow: 0 8px 25px rgba(212, 175, 55, 0.4);
}

/* Footer */
.footer {
  background: var(--contrast-dark);
  color: var(--background-primary);
  padding: 60px 0 20px;
  margin-top: 80px;
}

.footerContent {
  max-width: 1200px;
  margin: 0 auto;
  padding: 0 20px;
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
  gap: 40px;
}

.footerSection h4 {
  color: var(--gold-primary);
  font-size: 24px;
  margin-bottom: 16px;
}

.footerSection h5 {
  color: var(--background-primary);
  font-size: 18px;
  margin-bottom: 12px;
}

.footerSection ul {
  list-style: none;
  padding: 0;
}

.footerSection ul li {
  margin-bottom: 8px;
}

.footerSection ul li a {
  color: var(--contrast-light);
  text-decoration: none;
  transition: color 0.3s ease;
}

.footerSection ul li a:hover {
  color: var(--gold-primary);
}

.footerBottom {
  max-width: 1200px;
  margin: 0 auto;
  padding: 20px;
  text-align: center;
  border-top: 1px solid var(--contrast-medium);
  margin-top: 40px;
}

.loadingSalons {
  text-align: center;
  padding: 60px 20px;
}

.loadingSalons p {
  margin-top: 16px;
  color: var(--text-secondary);
}

.noSalons {
  text-align: center;
  padding: 60px 20px;
  background: var(--background-secondary);
  border-radius: 16px;
}

.noSalons p {
  color: var(--text-secondary);
  font-size: 16px;
  margin-bottom: 24px;
}

.registerSalonButton {
  padding: 12px 24px;
  background: linear-gradient(
    135deg,
    var(--gold-primary) 0%,
    var(--gold-dark) 100%
  );
  color: var(--contrast-dark);
  border: none;
  border-radius: 8px;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.3s ease;
}

.registerSalonButton:hover {
  transform: translateY(-2px);
  box-shadow: 0 8px 25px rgba(212, 175, 55, 0.4);
}

.distanceBadge {
  position: absolute;
  top: 12px;
  left: 12px;
  background: rgba(0, 0, 0, 0.7);
  color: white;
  padding: 4px 8px;
  border-radius: 12px;
  font-size: 10px;
  font-weight: 600;
}

/* Mobile Optimizations */
@media (max-width: 768px) {
  .headerContent {
    padding: 0 16px;
  }

  .headerActions {
    gap: 8px;
  }

  .ownerButton,
  .loginButton {
    padding: 8px 12px;
    font-size: 14px;
  }

  .welcomeTitle {
    font-size: 32px;
  }

  .quickStats {
    gap: 30px;
  }

  .statNumber {
    font-size: 24px;
  }

  .servicesGrid {
    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
    gap: 16px;
  }

  .serviceCard {
    padding: 24px 16px;
  }

  .salonsCarousel {
    grid-template-columns: 1fr;
    gap: 16px;
  }

  .sectionHeader {
    flex-direction: column;
    gap: 16px;
    text-align: center;
  }

  .footerContent {
    grid-template-columns: 1fr;
    gap: 30px;
    text-align: center;
  }
}

@keyframes spin {
  0% {
    transform: rotate(0deg);
  }
  100% {
    transform: rotate(360deg);
  }
}
</file>

<file path="src/pages/styles/Onboarding.module.css">
.container {
  min-height: 100vh;
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 20px;
  position: relative;
  background: linear-gradient(
    135deg,
    var(--background-primary) 0%,
    var(--background-secondary) 100%
  );
}

.background {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  overflow: hidden;
  z-index: 0;
}

.goldOrb {
  position: absolute;
  border-radius: 50%;
  background: linear-gradient(
    135deg,
    var(--gold-primary) 0%,
    var(--gold-dark) 100%
  );
  opacity: 0.1;
  filter: blur(60px);
}

.goldOrb:first-child {
  width: 300px;
  height: 300px;
  top: -150px;
  right: -150px;
  animation: float 8s ease-in-out infinite;
}

.goldOrb:last-child {
  width: 200px;
  height: 200px;
  bottom: -100px;
  left: -100px;
  animation: float 8s ease-in-out infinite reverse;
}

@keyframes float {
  0%,
  100% {
    transform: translateY(0px) rotate(0deg);
  }
  50% {
    transform: translateY(-20px) rotate(180deg);
  }
}

.onboardingCard {
  background: var(--background-primary);
  border-radius: 20px;
  box-shadow: 0 20px 60px rgba(0, 0, 0, 0.1);
  padding: 40px;
  width: 100%;
  max-width: 500px;
  position: relative;
  z-index: 1;
  border: 1px solid var(--border-color);
}

.header {
  text-align: center;
  margin-bottom: 40px;
}

.title {
  font-size: 32px;
  font-weight: 700;
  margin-bottom: 8px;
  color: var(--text-primary);
}

.goldText {
  background: linear-gradient(
    135deg,
    var(--gold-primary) 0%,
    var(--gold-dark) 100%
  );
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
}

.subtitle {
  color: var(--text-secondary);
  font-size: 16px;
  margin-bottom: 30px;
}

.progressBar {
  display: flex;
  align-items: center;
  gap: 12px;
}

.progressTrack {
  flex: 1;
  height: 6px;
  background: var(--border-color);
  border-radius: 3px;
  overflow: hidden;
}

.progressFill {
  height: 100%;
  background: linear-gradient(
    135deg,
    var(--gold-primary) 0%,
    var(--gold-dark) 100%
  );
  border-radius: 3px;
  transition: width 0.3s ease;
}

.progressText {
  font-size: 14px;
  font-weight: 600;
  color: var(--gold-primary);
  min-width: 30px;
}

.stepContent {
  min-height: 300px;
  display: flex;
  flex-direction: column;
  justify-content: center;
}

.step {
  text-align: center;
}

.stepIcon {
  font-size: 64px;
  margin-bottom: 24px;
}

.step h2 {
  font-size: 24px;
  font-weight: 600;
  margin-bottom: 12px;
  color: var(--text-primary);
}

.step p {
  color: var(--text-secondary);
  margin-bottom: 32px;
  line-height: 1.5;
}

.formGroup {
  margin-bottom: 24px;
}

.input {
  width: 100%;
  padding: 16px 20px;
  border: 2px solid var(--border-color);
  border-radius: 12px;
  font-size: 16px;
  background: var(--background-primary);
  color: var(--text-primary);
  transition: all 0.3s ease;
  text-align: center;
}

.input:focus {
  outline: none;
  border-color: var(--gold-primary);
  box-shadow: 0 0 0 4px rgba(212, 175, 55, 0.1);
}

.genderOptions {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
  gap: 16px;
  margin-bottom: 20px;
}

.genderButton {
  padding: 20px 16px;
  border: 2px solid var(--border-color);
  border-radius: 12px;
  background: var(--background-primary);
  cursor: pointer;
  transition: all 0.3s ease;
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 8px;
}

.genderButton:hover {
  border-color: var(--gold-primary);
  transform: translateY(-2px);
}

.genderButton.selected {
  border-color: var(--gold-primary);
  background: linear-gradient(135deg, var(--gold-primary), var(--gold-dark));
  color: var(--contrast-dark);
  transform: translateY(-2px);
  box-shadow: 0 8px 25px rgba(212, 175, 55, 0.3);
}

.genderIcon {
  font-size: 32px;
}

.genderButton span {
  font-weight: 600;
  font-size: 14px;
}

.locationSection {
  margin-bottom: 20px;
}

.locationButton {
  width: 100%;
  padding: 16px 20px;
  background: linear-gradient(
    135deg,
    var(--gold-primary) 0%,
    var(--gold-dark) 100%
  );
  color: var(--contrast-dark);
  border: none;
  border-radius: 12px;
  font-size: 16px;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.3s ease;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 8px;
  margin-bottom: 20px;
}

.locationButton:hover {
  transform: translateY(-2px);
  box-shadow: 0 8px 25px rgba(212, 175, 55, 0.4);
}

.divider {
  text-align: center;
  margin: 20px 0;
  position: relative;
}

.divider::before {
  content: "";
  position: absolute;
  top: 50%;
  left: 0;
  right: 0;
  height: 1px;
  background: var(--border-color);
}

.divider span {
  background: var(--background-primary);
  padding: 0 16px;
  color: var(--text-secondary);
  font-size: 14px;
  position: relative;
  z-index: 1;
}

.loadingLocation {
  text-align: center;
  padding: 40px 20px;
}

.loadingLocation p {
  margin-top: 16px;
  color: var(--text-secondary);
}

.locationSuccess {
  display: flex;
  align-items: center;
  gap: 16px;
  padding: 16px;
  background: rgba(34, 197, 94, 0.1);
  border: 2px solid var(--success);
  border-radius: 12px;
}

.locationIcon {
  font-size: 24px;
}

.locationSuccess div {
  flex: 1;
}

.locationSuccess h4 {
  color: var(--success);
  font-size: 16px;
  font-weight: 600;
  margin-bottom: 4px;
}

.locationSuccess p {
  color: var(--text-secondary);
  font-size: 14px;
  margin: 0;
}

.changeLocationButton {
  padding: 8px 16px;
  background: transparent;
  color: var(--gold-primary);
  border: 1px solid var(--gold-primary);
  border-radius: 6px;
  font-size: 14px;
  cursor: pointer;
  transition: all 0.3s ease;
}

.changeLocationButton:hover {
  background: var(--gold-primary);
  color: var(--contrast-dark);
}

.locationError {
  text-align: center;
}

.locationError p {
  color: var(--error);
  margin-bottom: 16px;
}

.navigation {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-top: 40px;
  gap: 16px;
}

.backButton {
  padding: 12px 24px;
  background: transparent;
  color: var(--text-secondary);
  border: 2px solid var(--border-color);
  border-radius: 12px;
  cursor: pointer;
  font-size: 16px;
  font-weight: 600;
  transition: all 0.3s ease;
}

.backButton:hover {
  border-color: var(--gold-primary);
  color: var(--gold-primary);
}

.nextButton {
  flex: 1;
  padding: 14px 28px;
  background: linear-gradient(
    135deg,
    var(--gold-primary) 0%,
    var(--gold-dark) 100%
  );
  color: var(--contrast-dark);
  border: none;
  border-radius: 12px;
  font-size: 16px;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.3s ease;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 8px;
}

.nextButton:hover:not(:disabled) {
  transform: translateY(-2px);
  box-shadow: 0 8px 25px rgba(212, 175, 55, 0.4);
}

.nextButton:disabled {
  opacity: 0.7;
  cursor: not-allowed;
}

.spinner {
  width: 20px;
  height: 20px;
  border: 2px solid transparent;
  border-top: 2px solid currentColor;
  border-radius: 50%;
  animation: spin 1s linear infinite;
}

@keyframes spin {
  0% {
    transform: rotate(0deg);
  }
  100% {
    transform: rotate(360deg);
  }
}

/* Mobile Optimizations */
@media (max-width: 768px) {
  .container {
    padding: 16px;
  }

  .onboardingCard {
    padding: 24px;
    border-radius: 16px;
  }

  .title {
    font-size: 28px;
  }

  .step h2 {
    font-size: 20px;
  }

  .stepIcon {
    font-size: 48px;
  }

  .genderOptions {
    grid-template-columns: 1fr;
    gap: 12px;
  }

  .genderButton {
    flex-direction: row;
    justify-content: flex-start;
    padding: 16px 20px;
  }

  .navigation {
    flex-direction: column;
    gap: 12px;
  }

  .backButton {
    width: 100%;
    order: 2;
  }

  .nextButton {
    order: 1;
  }
}
</file>

<file path="src/pages/styles/Owner.module.css">
.dashboard {
  display: flex;
  min-height: 100vh;
  background: #f5f7fa;
}

.content {
  flex: 1;
  padding: 30px;
  margin-left: 250px;
}

.header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 30px;
}

.header h1 {
  font-size: 2rem;
  color: #333;
}

.date {
  color: #666;
  font-size: 1.1rem;
}

.statsGrid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
  gap: 25px;
  margin-bottom: 40px;
}

.statCard {
  background: white;
  padding: 25px;
  border-radius: 12px;
  box-shadow: 0 2px 10px rgba(0, 0, 0, 0.08);
}

.statCard h3 {
  color: #666;
  font-size: 0.95rem;
  margin-bottom: 10px;
  font-weight: normal;
}

.statNumber {
  font-size: 2.5rem;
  font-weight: bold;
  color: #333;
  margin-bottom: 10px;
}

.statSubtext {
  color: #999;
  font-size: 0.9rem;
}

.upcomingSection,
.notifications,
.quickActions {
  background: white;
  padding: 25px;
  border-radius: 12px;
  margin-bottom: 25px;
  box-shadow: 0 2px 10px rgba(0, 0, 0, 0.08);
}

.appointmentList {
  margin-top: 20px;
}

.appointmentCard {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 15px;
  border: 1px solid #e0e0e0;
  border-radius: 8px;
  margin-bottom: 12px;
}

.appointmentCard:hover {
  background: #f8f9fa;
}

.time {
  font-weight: bold;
  color: #667eea;
  font-size: 1.1rem;
  min-width: 80px;
}

.customerInfo {
  flex: 1;
  margin-left: 20px;
}

.customerInfo strong {
  display: block;
  margin-bottom: 5px;
}

.customerInfo span {
  color: #666;
  font-size: 0.9rem;
}

.barber {
  color: #999;
  font-size: 0.9rem;
  margin-right: 15px;
}

.actionBtn {
  background: #667eea;
  color: white;
  padding: 8px 16px;
  border-radius: 6px;
  font-size: 0.9rem;
}

.actionGrid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
  gap: 15px;
  margin-top: 20px;
}

.actionButton {
  padding: 20px;
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  color: white;
  border-radius: 10px;
  font-size: 1rem;
  transition: transform 0.2s;
}

.actionButton:hover {
  transform: scale(1.05);
}

.notificationList {
  margin-top: 20px;
}

.notification {
  display: flex;
  align-items: start;
  padding: 15px;
  border-bottom: 1px solid #e0e0e0;
}

.notification:last-child {
  border-bottom: none;
}

.notifIcon {
  font-size: 1.5rem;
  margin-right: 15px;
}

.notifContent {
  flex: 1;
}

.notifContent strong {
  display: block;
  margin-bottom: 5px;
}

.notifContent p {
  color: #666;
  font-size: 0.9rem;
  margin-bottom: 5px;
}

.notifTime {
  color: #999;
  font-size: 0.85rem;
}

/* Forms */
.formOverlay {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(0, 0, 0, 0.5);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 1000;
}

.formModal {
  background: white;
  padding: 30px;
  border-radius: 12px;
  width: 90%;
  max-width: 500px;
}

.formGroup {
  margin-bottom: 20px;
}

.formGroup label {
  display: block;
  margin-bottom: 8px;
  color: #333;
  font-weight: 500;
}

.formGroup input,
.formGroup textarea,
.formGroup select {
  width: 100%;
  padding: 10px;
  border: 1px solid #ddd;
  border-radius: 6px;
  font-size: 1rem;
}

.formRow {
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  gap: 15px;
}

.formActions {
  display: flex;
  gap: 15px;
  margin-top: 25px;
}

.saveBtn {
  flex: 1;
  padding: 12px;
  background: #667eea;
  color: white;
  border-radius: 6px;
  font-size: 1rem;
}

.cancelBtn {
  flex: 1;
  padding: 12px;
  background: #e0e0e0;
  color: #333;
  border-radius: 6px;
  font-size: 1rem;
}

.addButton {
  background: #667eea;
  color: white;
  padding: 10px 20px;
  border-radius: 6px;
  font-size: 1rem;
}

/* Services */
.servicesGrid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
  gap: 20px;
  margin-bottom: 40px;
}

.serviceCard {
  background: white;
  padding: 20px;
  border-radius: 10px;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
}

.serviceHeader {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 10px;
}

.genderBadge {
  background: #f0f0f0;
  padding: 4px 12px;
  border-radius: 20px;
  font-size: 0.85rem;
  color: #666;
}

.serviceDesc {
  color: #666;
  margin-bottom: 15px;
  min-height: 40px;
}

.serviceDetails {
  display: flex;
  justify-content: space-between;
  margin-bottom: 15px;
  padding-top: 15px;
  border-top: 1px solid #f0f0f0;
}

.serviceActions {
  display: flex;
  gap: 10px;
}

.editBtn,
.deleteBtn {
  flex: 1;
  padding: 8px;
  border-radius: 6px;
  font-size: 0.9rem;
}

.editBtn {
  background: #f0f0f0;
  color: #333;
}

.deleteBtn {
  background: #fee;
  color: #c00;
}

.packagesSection {
  background: white;
  padding: 25px;
  border-radius: 12px;
  box-shadow: 0 2px 10px rgba(0, 0, 0, 0.08);
}

.addPackageBtn {
  background: #667eea;
  color: white;
  padding: 10px 20px;
  border-radius: 6px;
  margin-top: 15px;
}

.packageList {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
  gap: 20px;
  margin-top: 20px;
}

.packageCard {
  border: 2px solid #667eea;
  border-radius: 10px;
  padding: 20px;
  background: linear-gradient(
    135deg,
    rgba(102, 126, 234, 0.1) 0%,
    rgba(118, 75, 162, 0.1) 100%
  );
}

.packagePrice {
  display: flex;
  align-items: center;
  gap: 10px;
  margin-top: 15px;
}

.originalPrice {
  text-decoration: line-through;
  color: #999;
}

.discountPrice {
  font-size: 1.5rem;
  font-weight: bold;
  color: #667eea;
}
</file>

<file path="src/pages/walkin/barber-select.js">
import { useState, useEffect } from "react";
import { useRouter } from "next/router";
import styles from "../../styles/WalkinBarberSelect.module.css";

export default function WalkinBarberSelect() {
  const router = useRouter();
  const { salonId } = router.query;

  const [salonState, setSalonState] = useState(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    if (!salonId) return;

    fetchSalonState();

    // Update every 30 seconds
    const interval = setInterval(fetchSalonState, 30000);

    return () => clearInterval(interval);
  }, [salonId]);

  const fetchSalonState = async () => {
    try {
      const res = await fetch(`/api/walkin/salon-state?salonId=${salonId}`);
      const data = await res.json();
      setSalonState(data);
    } catch (error) {
      console.error("Error fetching salon state:", error);
    } finally {
      setLoading(false);
    }
  };

  const handleBarberSelect = (barberId) => {
    router.push(`/walkin/booking-form?salonId=${salonId}&barberId=${barberId}`);
  };

  if (loading) {
    return <div className={styles.loading}>Loading barbers...</div>;
  }

  if (!salonState) {
    return <div className={styles.error}>Unable to load salon information</div>;
  }

  return (
    <div className={styles.container}>
      <h1 className={styles.title}>Select Your Barber</h1>

      {/* Overall Stats */}
      <div className={styles.overallStats}>
        <div className={styles.statItem}>
          <span className={styles.statIcon}>🟢</span>
          <span className={styles.statValue}>{salonState.totalServing}</span>
          <span className={styles.statLabel}>Serving Now</span>
        </div>
        <div className={styles.statItem}>
          <span className={styles.statIcon}>🟠</span>
          <span className={styles.statValue}>{salonState.totalWaiting}</span>
          <span className={styles.statLabel}>In Queue</span>
        </div>
        <div className={styles.statItem}>
          <span className={styles.statIcon}>⏱️</span>
          <span className={styles.statValue}>
            ~{salonState.avgWaitTime} min
          </span>
          <span className={styles.statLabel}>Avg Wait</span>
        </div>
      </div>

      {/* Barber Chairs Grid */}
      <div className={styles.chairsGrid}>
        {salonState.barbers.map((barber) => (
          <div
            key={barber.barberId}
            className={`${styles.chairCard} ${
              styles[barber.status.toLowerCase()]
            }`}
            onClick={() => handleBarberSelect(barber.barberId)}
          >
            {/* Chair Visual */}
            <div className={styles.chairIcon}>
              <div
                className={`${styles.statusDot} ${
                  styles[barber.status.toLowerCase()]
                }`}
              ></div>
              <span className={styles.chairNumber}>#{barber.chairNumber}</span>
            </div>

            {/* Barber Info */}
            <h3 className={styles.barberName}>{barber.name}</h3>

            {barber.status === "AVAILABLE" && (
              <div className={styles.availableTag}>✅ Available Now</div>
            )}

            {barber.status === "OCCUPIED" && (
              <div className={styles.occupiedInfo}>
                <p className={styles.servingText}>
                  🟢 Serving: {barber.currentCustomer}
                </p>
                <p className={styles.timeLeft}>
                  Time Left: ~{barber.timeLeft} mins
                </p>
              </div>
            )}

            {barber.queueCount > 0 && (
              <div className={styles.queueBadge}>
                {barber.queueCount} in queue
              </div>
            )}

            <div className={styles.waitEstimate}>
              {barber.status === "AVAILABLE" ? (
                <span className={styles.noWait}>No Wait</span>
              ) : (
                <span className={styles.waitTime}>
                  ~{barber.timeLeft + barber.queueCount * 45} mins wait
                </span>
              )}
            </div>
          </div>
        ))}
      </div>

      {/* Legend */}
      <div className={styles.legend}>
        <div className={styles.legendItem}>
          <span className={`${styles.dot} ${styles.green}`}></span>
          <span>Service In Progress</span>
        </div>
        <div className={styles.legendItem}>
          <span className={`${styles.dot} ${styles.orange}`}></span>
          <span>Waiting in Queue</span>
        </div>
        <div className={styles.legendItem}>
          <span className={`${styles.dot} ${styles.red}`}></span>
          <span>Booking Confirmed</span>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="src/pages/walkin/booking-form.js">
// import { useState } from "react";
// import { useRouter } from "next/router";
// import styles from "../../styles/wal";

// export default function WalkinBookingForm() {
//   const router = useRouter();
//   const { salonId, barberId } = router.query;

//   const [formData, setFormData] = useState({
//     customerName: "",
//     customerPhone: "",
//     service: "Haircut",
//     estimatedDuration: 45,
//   });

//   const [loading, setLoading] = useState(false);

//   const handleSubmit = async (e) => {
//     e.preventDefault();
//     setLoading(true);

//     try {
//       const res = await fetch("/api/walkin/create-booking", {
//         method: "POST",
//         headers: { "Content-Type": "application/json" },
//         body: JSON.stringify({
//           salonId,
//           barberId,
//           ...formData,
//         }),
//       });

//       const data = await res.json();

//       if (data.success) {
//         // Redirect to confirmation page
//         router.push(`/walkin/confirmation?bookingId=${data.booking.bookingId}`);
//       } else {
//         alert(data.message || "Booking failed");
//       }
//     } catch (error) {
//       console.error("Booking error:", error);
//       alert("Something went wrong. Please try again.");
//     } finally {
//       setLoading(false);
//     }
//   };

//   return (
//     <div className={styles.container}>
//       <h1 className={styles.title}>Book Your Service</h1>

//       <form onSubmit={handleSubmit} className={styles.form}>
//         <div className={styles.formGroup}>
//           <label>Full Name *</label>
//           <input
//             type="text"
//             value={formData.customerName}
//             onChange={(e) =>
//               setFormData({ ...formData, customerName: e.target.value })
//             }
//             required
//             placeholder="Enter your name"
//           />
//         </div>

//         <div className={styles.formGroup}>
//           <label>Phone Number *</label>
//           <input
//             type="tel"
//             value={formData.customerPhone}
//             onChange={(e) =>
//               setFormData({ ...formData, customerPhone: e.target.value })
//             }
//             required
//             placeholder="10-digit mobile number"
//             pattern="[0-9]{10}"
//           />
//         </div>

//         <div className={styles.formGroup}>
//           <label>Service *</label>
//           <select
//             value={formData.service}
//             onChange={(e) =>
//               setFormData({ ...formData, service: e.target.value })
//             }
//           >
//             <option value="Haircut">Haircut</option>
//             <option value="Shave">Shave</option>
//             <option value="Hair Styling">Hair Styling</option>
//             <option value="Beard Trim">Beard Trim</option>
//             <option value="Hair Color">Hair Color</option>
//           </select>
//         </div>

//         <button type="submit" disabled={loading} className={styles.submitBtn}>
//           {loading ? "Creating Booking..." : "Confirm Booking"}
//         </button>
//       </form>
//     </div>
//   );
// }
</file>

<file path="src/pages/walkin/confirmation.js">
import { useState, useEffect } from "react";
import { useRouter } from "next/router";
import styles from "../../styles/WalkinConfirmation.module.css";

export default function WalkinConfirmation() {
  const router = useRouter();
  const { bookingId } = router.query;

  const [booking, setBooking] = useState(null);
  const [timeLeft, setTimeLeft] = useState(null);
  const [loading, setLoading] = useState(true);
  const [qrCodeUrl, setQrCodeUrl] = useState("");

  useEffect(() => {
    if (!bookingId) return;

    fetchBooking();
  }, [bookingId]);

  useEffect(() => {
    if (!booking?.expiresAt) return;

    const interval = setInterval(() => {
      const remaining = new Date(booking.expiresAt) - new Date();
      if (remaining > 0) {
        const minutes = Math.floor(remaining / 1000 / 60);
        const seconds = Math.floor((remaining / 1000) % 60);
        setTimeLeft(`${minutes}:${seconds.toString().padStart(2, "0")}`);
      } else {
        setTimeLeft("EXPIRED");
      }
    }, 1000);

    return () => clearInterval(interval);
  }, [booking]);

  // ✅ Poll booking status every 10 seconds
  useEffect(() => {
    if (!bookingId) return;

    const pollStatus = async () => {
      try {
        const res = await fetch(`/api/bookings/status/${bookingId}`);
        const data = await res.json();

        setBooking((prev) => ({
          ...prev,
          status: data.status,
          queueStatus: data.queueStatus,
          queuePosition: data.queuePosition,
        }));

        // Stop timer if expired
        if (data.isExpired) {
          setTimeLeft("EXPIRED");
        }
      } catch (error) {
        console.error("Poll error:", error);
      }
    };

    const interval = setInterval(pollStatus, 10000); // Every 10 seconds

    return () => clearInterval(interval);
  }, [bookingId]);

  const fetchBooking = async () => {
    try {
      const res = await fetch(`/api/walkin/booking/${bookingId}`);

      if (!res.ok) {
        throw new Error("Failed to fetch booking");
      }

      const data = await res.json();
      setBooking(data.booking);
      if (data.booking?.bookingCode) {
        const QRCode = (await import("qrcode")).default;
        const qrUrl = await QRCode.toDataURL(data.booking.bookingCode, {
          width: 200,
          margin: 2,
          color: {
            dark: "#000000",
            light: "#FFFFFF",
          },
        });
        setQrCodeUrl(qrUrl);
      }
    } catch (error) {
      console.error("Error fetching booking:", error);
    } finally {
      setLoading(false);
    }
  };

  if (loading) {
    return (
      <div className={styles.container}>
        <div className={styles.loading}>Loading booking details...</div>
      </div>
    );
  }

  if (!booking) {
    return (
      <div className={styles.container}>
        <div className={styles.error}>
          <h2>Booking Not Found</h2>
          <p>Unable to load booking details. Please check your booking ID.</p>
          <button onClick={() => router.push("/")}>Go Home</button>
        </div>
      </div>
    );
  }

  return (
    <div className={styles.container}>
      <div className={styles.card}>
        <h1 className={styles.title}>✅ Booking Confirmed!</h1>

        {/* QR Code */}
        <div className={styles.qrSection}>
          <div className={styles.qrCodeWrapper}>
            {qrCodeUrl ? (
              <img
                src={qrCodeUrl}
                alt="Booking QR Code"
                className={styles.qrCode}
              />
            ) : (
              <div className={styles.qrPlaceholder}>
                <span>Generating QR Code...</span>
              </div>
            )}
          </div>
          <p className={styles.bookingCode}>{booking.bookingCode}</p>
          <p className={styles.qrInstruction}>Show this at salon entrance</p>
        </div>

        {/* Details */}
        <div className={styles.details}>
          <div className={styles.detailItem}>
            <span>Salon:</span>
            <strong>{booking.salonName}</strong>
          </div>
          <div className={styles.detailItem}>
            <span>Barber:</span>
            <strong>{booking.barberName}</strong>
          </div>
          <div className={styles.detailItem}>
            <span>Chair:</span>
            <strong>#{booking.chairNumber}</strong>
          </div>
          <div className={styles.detailItem}>
            <span>Service:</span>
            <strong>{booking.service}</strong>
          </div>
          <div className={styles.detailItem}>
            <span>Customer:</span>
            <strong>{booking.customerName}</strong>
          </div>
        </div>

        <div
          className={`${styles.statusBadge} ${
            booking.queueStatus === "RED"
              ? styles.red
              : booking.queueStatus === "ORANGE"
              ? styles.orange
              : booking.queueStatus === "GREEN"
              ? styles.green
              : styles.completed
          }`}
        >
          <span className={styles.statusDot}></span>
          <span>
            {booking.queueStatus === "RED" && "🔴 Confirmed - Not Arrived"}
            {booking.queueStatus === "ORANGE" &&
              `🟠 In Queue - Position #${booking.queuePosition || "?"}`}
            {booking.queueStatus === "GREEN" && "🟢 Service Started"}
            {booking.queueStatus === "COMPLETED" && (
              <div className={styles.feedbackSection}>
                <h3>✨ Service Complete!</h3>
                <p>How was your experience?</p>
                <button
                  onClick={() =>
                    router.push(`/feedback?bookingId=${bookingId}`)
                  }
                  className={styles.feedbackBtn}
                >
                  📝 Give Feedback
                </button>
              </div>
            )}
          </span>
        </div>

        {/* Expiry Timer */}
        {booking.queueStatus === "RED" && (
          <div className={styles.expiryAlert}>
            <p>
              ⏰ Please arrive within:{" "}
              <strong>{timeLeft || "Calculating..."}</strong>
            </p>
            <p className={styles.note}>Booking expires after 45 minutes</p>
          </div>
        )}

        {/* Instructions */}
        <div className={styles.instructions}>
          <h3>Next Steps:</h3>
          <ol>
            <li>📍 Head to the salon</li>
            <li>📱 Show this screen at reception</li>
            <li>✂️ Get your service done!</li>
          </ol>
        </div>

        {/* Actions */}
        <div className={styles.actions}>
          <button
            className={styles.btnPrimary}
            onClick={() => {
              if (booking.salonCoordinates) {
                // Use same format as SalonMap.js - opens with daddr (destination address)
                const [lng, lat] = booking.salonCoordinates;
                window.open(
                  `https://maps.google.com/maps?daddr=${lat},${lng}`,
                  "_blank"
                );
              } else if (booking.salonLocation) {
                // Fallback to address
                window.open(
                  `https://maps.google.com/?q=${encodeURIComponent(
                    booking.salonLocation
                  )}`,
                  "_blank"
                );
              }
            }}
          >
            📍 Get Directions
          </button>

          <button
            className={styles.btnSecondary}
            onClick={() => router.push("/")}
          >
            🏠 Go Home
          </button>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="src/pages/walkin/salon-select.js">
// import { useState, useEffect } from "react";
// import { useRouter } from "next/router";
// import styles from "../../styles/WalkinSalonSelect.module.css";

// export default function WalkinSalonSelect() {
//   const router = useRouter();
//   const [salons, setSalons] = useState([]);
//   const [loading, setLoading] = useState(true);

//   useEffect(() => {
//     fetchSalons();
//   }, []);

//   const fetchSalons = async () => {
//     try {
//       const res = await fetch("/api/salons");
//       const data = await res.json();
//       setSalons(data.salons || []);
//     } catch (error) {
//       console.error("Error fetching salons:", error);
//     } finally {
//       setLoading(false);
//     }
//   };

//   const handleSalonSelect = (salonId) => {
//     router.push(`/walkin/barber-select?salonId=${salonId}`);
//   };

//   if (loading) {
//     return <div className={styles.loading}>Loading salons...</div>;
//   }

//   return (
//     <div className={styles.container}>
//       <h1 className={styles.title}>Select a Salon</h1>

//       <div className={styles.salonGrid}>
//         {salons.map((salon) => (
//           <div
//             key={salon._id}
//             className={styles.salonCard}
//             onClick={() => handleSalonSelect(salon._id)}
//           >
//             <h2>{salon.salonName}</h2>
//             <p>{salon.address}</p>
//             <div className={styles.stats}>
//               <span>⭐ {salon.ratings?.overall || 5.0}</span>
//               <span>👥 {salon.stats?.totalBookings || 0} bookings</span>
//             </div>
//           </div>
//         ))}
//       </div>
//     </div>
//   );
// }
</file>

<file path="src/styles/Admin/AdminAnalytics.module.css">
.container {
  padding: 30px;
}

.title {
  font-size: 2rem;
  font-weight: 700;
  color: #1f2937;
  margin-bottom: 32px;
}

.loading {
  display: flex;
  align-items: center;
  justify-content: center;
  min-height: 400px;
  font-size: 1.2rem;
  color: #6b7280;
}

.section {
  background: white;
  border-radius: 16px;
  padding: 24px;
  margin-bottom: 32px;
  box-shadow: 0 2px 12px rgba(0, 0, 0, 0.08);
}

.section h2 {
  font-size: 1.5rem;
  font-weight: 600;
  color: #1f2937;
  margin-bottom: 24px;
}

.trendsGrid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
  gap: 24px;
}

.trendCard {
  background: #f9fafb;
  border-radius: 12px;
  padding: 20px;
  border: 1px solid #e5e7eb;
}

.trendCard h3 {
  font-size: 1.125rem;
  font-weight: 600;
  color: #1f2937;
  margin-bottom: 16px;
}

.trendCard ul {
  list-style: none;
  padding: 0;
  margin: 0;
}

.trendCard li {
  padding: 12px 0;
  border-bottom: 1px solid #e5e7eb;
  color: #4b5563;
}

.trendCard li:last-child {
  border-bottom: none;
}

.trendCard strong {
  color: #1f2937;
  font-weight: 600;
}

.topSalons {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
  gap: 20px;
}

.salonRankCard {
  display: flex;
  align-items: center;
  gap: 16px;
  background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);
  padding: 20px;
  border-radius: 12px;
  color: white;
  box-shadow: 0 4px 16px rgba(245, 158, 11, 0.3);
  transition: all 0.3s;
}

.salonRankCard:hover {
  transform: translateY(-4px);
  box-shadow: 0 8px 24px rgba(245, 158, 11, 0.4);
}

.rank {
  font-size: 2.5rem;
  font-weight: 800;
  opacity: 0.3;
  line-height: 1;
}

.salonInfo {
  flex: 1;
}

.salonInfo h3 {
  font-size: 1.125rem;
  font-weight: 700;
  margin: 0 0 8px 0;
}

.salonInfo p {
  margin: 4px 0;
  font-size: 0.875rem;
  opacity: 0.9;
}

.insights {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
  gap: 24px;
}

.insightCard {
  background: linear-gradient(135deg, #8b5cf6 0%, #6d28d9 100%);
  padding: 24px;
  border-radius: 12px;
  text-align: center;
  color: white;
  box-shadow: 0 4px 16px rgba(139, 92, 246, 0.3);
}

.insightCard h3 {
  font-size: 0.875rem;
  margin-bottom: 12px;
  opacity: 0.9;
}

.percentage,
.amount,
.rating {
  font-size: 2.5rem;
  font-weight: 800;
  margin: 0;
}

@media (max-width: 768px) {
  .trendsGrid,
  .topSalons,
  .insights {
    grid-template-columns: 1fr;
  }
}
</file>

<file path="src/styles/Admin/AdminDashboard.module.css">
.dashboard {
  padding: 30px;
}

.header {
  margin-bottom: 30px;
}

.title {
  font-size: 2rem;
  font-weight: 700;
  color: #1f2937;
  margin-bottom: 5px;
}

.subtitle {
  color: #6b7280;
  font-size: 1rem;
}

.loading {
  display: flex;
  align-items: center;
  justify-content: center;
  min-height: 400px;
  font-size: 1.2rem;
  color: #6b7280;
}

.quickActions {
  margin-top: 40px;
  margin-bottom: 40px;
}

.quickActions h2 {
  font-size: 1.5rem;
  margin-bottom: 20px;
  color: #1f2937;
  font-weight: 600;
}

.actionsGrid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
  gap: 20px;
}

.actionCard {
  background: white;
  border: 2px solid #e5e7eb;
  border-radius: 12px;
  padding: 30px 20px;
  text-align: center;
  cursor: pointer;
  transition: all 0.3s;
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 10px;
  font-size: 1rem;
  font-weight: 600;
  color: #1f2937;
}

.actionCard:hover {
  border-color: #f59e0b;
  transform: translateY(-5px);
  box-shadow: 0 10px 25px rgba(245, 158, 11, 0.2);
}

.actionIcon {
  font-size: 2.5rem;
}

.recentActivity {
  margin-top: 40px;
}

.recentActivity h2 {
  font-size: 1.5rem;
  margin-bottom: 20px;
  color: #1f2937;
  font-weight: 600;
}

.activityList {
  background: white;
  border-radius: 12px;
  padding: 20px;
  border: 1px solid #e5e7eb;
}

.activityItem {
  display: flex;
  align-items: center;
  gap: 15px;
  padding: 15px;
  border-bottom: 1px solid #f3f4f6;
}

.activityItem:last-child {
  border-bottom: none;
}

.activityIcon {
  font-size: 1.5rem;
}

.activityDetails {
  flex: 1;
}

.activityText {
  color: #1f2937;
  margin-bottom: 5px;
  font-weight: 500;
}

.activityTime {
  color: #6b7280;
  font-size: 0.85rem;
}

@media (max-width: 768px) {
  .actionsGrid {
    grid-template-columns: repeat(2, 1fr);
  }
}

@media (max-width: 480px) {
  .actionsGrid {
    grid-template-columns: 1fr;
  }
}
</file>

<file path="src/styles/Admin/AdminLayout.module.css">
.layout {
  display: flex;
  min-height: 100vh;
  background: #f9fafb;
}

.sidebar {
  width: 260px;
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  color: white;
  display: flex;
  flex-direction: column;
  padding: 20px;
}

.logo {
  margin-bottom: 40px;
}

.logo h2 {
  font-size: 1.5rem;
  font-weight: 700;
}

.nav {
  flex: 1;
  display: flex;
  flex-direction: column;
  gap: 10px;
}

.navItem {
  display: flex;
  align-items: center;
  gap: 12px;
  padding: 12px 16px;
  background: rgba(255, 255, 255, 0.1);
  border: none;
  border-radius: 10px;
  color: white;
  font-size: 1rem;
  cursor: pointer;
  transition: all 0.3s;
  text-align: left;
}

.navItem:hover {
  background: rgba(255, 255, 255, 0.2);
  transform: translateX(5px);
}

.navItem.active {
  background: rgba(255, 255, 255, 0.3);
}

.icon {
  font-size: 1.3rem;
}

.logoutBtn {
  padding: 12px;
  background: rgba(255, 255, 255, 0.1);
  border: none;
  border-radius: 10px;
  color: white;
  font-size: 1rem;
  cursor: pointer;
  transition: all 0.3s;
  margin-top: 20px;
}

.logoutBtn:hover {
  background: rgba(255, 255, 255, 0.2);
}

.main {
  flex: 1;
  overflow-y: auto;
}

@media (max-width: 768px) {
  .sidebar {
    width: 80px;
  }

  .navItem span:not(.icon) {
    display: none;
  }

  .logo h2 {
    font-size: 1rem;
  }
}
</file>

<file path="src/styles/Admin/AdminLogin.module.css">
.container {
  min-height: 100vh;
  display: flex;
  align-items: center;
  justify-content: center;
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  padding: 20px;
}

.loginCard {
  background: white;
  border-radius: 20px;
  padding: 40px;
  max-width: 450px;
  width: 100%;
  box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
}

.header {
  text-align: center;
  margin-bottom: 30px;
}

.title {
  font-size: 2rem;
  font-weight: 700;
  color: #1f2937;
  margin-bottom: 10px;
}

.subtitle {
  color: #6b7280;
  font-size: 0.95rem;
}

.error {
  background: #fef2f2;
  color: #dc2626;
  padding: 12px;
  border-radius: 8px;
  margin-bottom: 20px;
  font-size: 0.9rem;
}

.form {
  display: flex;
  flex-direction: column;
  gap: 20px;
}

.formGroup label {
  display: block;
  font-weight: 600;
  margin-bottom: 8px;
  color: #374151;
}

.formGroup input {
  width: 100%;
  padding: 12px 16px;
  border: 2px solid #e5e7eb;
  border-radius: 10px;
  font-size: 1rem;
  transition: all 0.3s;
}

.formGroup input:focus {
  outline: none;
  border-color: #667eea;
  box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
}

.submitButton {
  padding: 14px;
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  color: white;
  border: none;
  border-radius: 10px;
  font-size: 1rem;
  font-weight: 600;
  cursor: pointer;
  transition: transform 0.2s;
}

.submitButton:hover {
  transform: translateY(-2px);
}

.submitButton:disabled {
  opacity: 0.6;
  cursor: not-allowed;
}
</file>

<file path="src/styles/Admin/AdminModal.module.css">
.overlay {
  position: fixed;
  inset: 0;
  background: rgba(0, 0, 0, 0.6);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 1000;
  padding: 20px;
  animation: fadeIn 0.3s ease-out;
}

@keyframes fadeIn {
  from {
    opacity: 0;
  }
  to {
    opacity: 1;
  }
}

.modal {
  background: white;
  border-radius: 20px;
  width: 100%;
  max-width: 900px;
  max-height: 90vh;
  overflow-y: auto;
  box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
  position: relative;
  animation: slideUp 0.4s ease-out;
}

@keyframes slideUp {
  from {
    opacity: 0;
    transform: translateY(30px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

.closeBtn {
  position: absolute;
  top: 20px;
  right: 20px;
  background: #f3f4f6;
  border: none;
  width: 36px;
  height: 36px;
  border-radius: 50%;
  font-size: 1.25rem;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.2s;
  z-index: 10;
}

.closeBtn:hover {
  background: #e5e7eb;
  transform: scale(1.1);
}

.title {
  font-size: 1.875rem;
  font-weight: 700;
  color: #1f2937;
  margin: 0 0 24px 0;
  padding: 24px 24px 0 24px;
  border-bottom: 2px solid #f3f4f6;
  padding-bottom: 16px;
}

.content {
  padding: 24px;
}

.loading {
  text-align: center;
  padding: 40px;
  color: #6b7280;
  font-size: 1.125rem;
}

.section {
  margin-bottom: 32px;
}

.section:last-child {
  margin-bottom: 0;
}

.section h3 {
  font-size: 1.25rem;
  font-weight: 600;
  color: #1f2937;
  margin-bottom: 16px;
  display: flex;
  align-items: center;
  gap: 8px;
}

.info {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
  gap: 16px;
}

.info p {
  color: #4b5563;
  margin: 0;
  padding: 12px;
  background: #f9fafb;
  border-radius: 8px;
  font-size: 0.9375rem;
}

.info strong {
  color: #1f2937;
  font-weight: 600;
  margin-right: 8px;
}

.stats {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
  gap: 16px;
}

.statCard {
  background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);
  padding: 20px;
  border-radius: 12px;
  text-align: center;
  color: white;
}

.statCard span {
  display: block;
  font-size: 0.875rem;
  margin-bottom: 8px;
  opacity: 0.9;
}

.statCard strong {
  display: block;
  font-size: 2rem;
  font-weight: 700;
}

.list {
  display: flex;
  flex-direction: column;
  gap: 12px;
  max-height: 300px;
  overflow-y: auto;
}

.listItem {
  padding: 16px;
  background: #f9fafb;
  border-radius: 8px;
  border-left: 3px solid #f59e0b;
}

.listItem p {
  margin: 0 0 4px 0;
  color: #1f2937;
  font-weight: 500;
}

.small {
  font-size: 0.875rem;
  color: #6b7280;
  margin-top: 4px;
}

@media (max-width: 768px) {
  .modal {
    max-width: 100%;
    border-radius: 16px;
  }

  .info {
    grid-template-columns: 1fr;
  }

  .stats {
    grid-template-columns: 1fr;
  }
}
</file>

<file path="src/styles/Admin/AdminReports.module.css">
.container {
  padding: 30px;
  max-width: 800px;
  margin: 0 auto;
}

.container h1 {
  font-size: 2rem;
  font-weight: 700;
  color: #1f2937;
  margin-bottom: 8px;
}

.subtitle {
  color: #6b7280;
  font-size: 1rem;
  margin-bottom: 32px;
}

.reportForm {
  background: white;
  border-radius: 16px;
  padding: 32px;
  box-shadow: 0 2px 12px rgba(0, 0, 0, 0.08);
  margin-bottom: 32px;
}

.formGroup {
  margin-bottom: 24px;
}

.formGroup label {
  display: block;
  font-weight: 600;
  color: #374151;
  margin-bottom: 8px;
  font-size: 0.9375rem;
}

.formGroup select {
  width: 100%;
  padding: 12px 16px;
  border: 2px solid #e5e7eb;
  border-radius: 12px;
  font-size: 1rem;
  background: white;
  cursor: pointer;
  transition: all 0.3s;
}

.formGroup select:focus {
  outline: none;
  border-color: #8b5cf6;
  box-shadow: 0 0 0 3px rgba(139, 92, 246, 0.1);
}

.dateRange {
  display: flex;
  align-items: center;
  gap: 12px;
}

.dateRange input {
  flex: 1;
  padding: 12px 16px;
  border: 2px solid #e5e7eb;
  border-radius: 12px;
  font-size: 1rem;
  transition: all 0.3s;
}

.dateRange input:focus {
  outline: none;
  border-color: #8b5cf6;
  box-shadow: 0 0 0 3px rgba(139, 92, 246, 0.1);
}

.dateRange span {
  color: #6b7280;
  font-weight: 500;
}

.generateBtn {
  width: 100%;
  padding: 16px;
  background: linear-gradient(135deg, #8b5cf6 0%, #6d28d9 100%);
  color: white;
  border: none;
  border-radius: 12px;
  font-size: 1.125rem;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.3s;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 8px;
}

.generateBtn:hover {
  transform: translateY(-2px);
  box-shadow: 0 8px 20px rgba(139, 92, 246, 0.4);
}

.generateBtn:disabled {
  opacity: 0.6;
  cursor: not-allowed;
  transform: none;
}

.reportInfo {
  background: #f9fafb;
  border-radius: 12px;
  padding: 24px;
  border: 1px solid #e5e7eb;
}

.reportInfo h3 {
  font-size: 1.25rem;
  font-weight: 600;
  color: #1f2937;
  margin-bottom: 16px;
}

.reportInfo ul {
  list-style: none;
  padding: 0;
  margin: 0;
}

.reportInfo li {
  padding: 12px 0;
  color: #4b5563;
  display: flex;
  align-items: center;
  gap: 8px;
  font-size: 0.9375rem;
}

@media (max-width: 640px) {
  .dateRange {
    flex-direction: column;
  }

  .dateRange input {
    width: 100%;
  }
}
</file>

<file path="src/styles/Admin/AdminRevenue.module.css">
.container {
  padding: 30px;
}

.header {
  margin-bottom: 30px;
}

.header h1 {
  font-size: 2rem;
  font-weight: 700;
  color: #1f2937;
  margin-bottom: 8px;
}

.subtitle {
  color: #6b7280;
  font-size: 1rem;
}

.loading {
  display: flex;
  align-items: center;
  justify-content: center;
  min-height: 400px;
  font-size: 1.2rem;
  color: #6b7280;
}

.filters {
  margin-bottom: 24px;
}

.filters select {
  padding: 12px 20px;
  border: 2px solid #e5e7eb;
  border-radius: 12px;
  font-size: 1rem;
  background: white;
  cursor: pointer;
  transition: all 0.3s;
}

.filters select:focus {
  outline: none;
  border-color: #8b5cf6;
}

.summaryCards {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
  gap: 24px;
  margin-bottom: 32px;
}

.card {
  background: white;
  border-radius: 16px;
  padding: 24px;
  box-shadow: 0 2px 12px rgba(0, 0, 0, 0.08);
  transition: all 0.3s ease;
}

.card:hover {
  transform: translateY(-4px);
  box-shadow: 0 8px 20px rgba(0, 0, 0, 0.12);
}

.card h3 {
  font-size: 0.875rem;
  color: #6b7280;
  margin-bottom: 12px;
  font-weight: 500;
}

.amount {
  font-size: 2rem;
  font-weight: 700;
  color: #8b5cf6;
  margin: 0;
}

.count {
  font-size: 2rem;
  font-weight: 700;
  color: #1f2937;
  margin: 0;
}

.tableContainer {
  background: white;
  border-radius: 16px;
  padding: 24px;
  box-shadow: 0 2px 12px rgba(0, 0, 0, 0.08);
}

.tableContainer h2 {
  font-size: 1.5rem;
  font-weight: 600;
  color: #1f2937;
  margin-bottom: 24px;
}

.table {
  width: 100%;
  border-collapse: collapse;
}

.table thead {
  background: #f9fafb;
  border-bottom: 2px solid #e5e7eb;
}

.table th {
  padding: 16px;
  text-align: left;
  font-weight: 600;
  color: #374151;
  font-size: 0.875rem;
  text-transform: uppercase;
  letter-spacing: 0.5px;
}

.table tbody tr {
  border-bottom: 1px solid #f3f4f6;
  transition: background 0.2s;
}

.table tbody tr:hover {
  background: #f9fafb;
}

.table td {
  padding: 16px;
  color: #4b5563;
  font-size: 0.9375rem;
}

.salonName {
  font-weight: 600;
  color: #1f2937;
}

.paid {
  color: #10b981;
  font-weight: 600;
}

.balance {
  color: #ef4444;
  font-weight: 600;
}

.viewBtn {
  padding: 8px 16px;
  border-radius: 8px;
  font-size: 0.875rem;
  font-weight: 600;
  border: none;
  cursor: pointer;
  transition: all 0.2s;
  background: #e0e7ff;
  color: #4338ca;
}

.viewBtn:hover {
  background: #c7d2fe;
}

@media (max-width: 1024px) {
  .tableContainer {
    overflow-x: auto;
  }

  .table {
    min-width: 1100px;
  }
}
</file>

<file path="src/styles/Admin/AdminSalons.module.css">
.container {
  padding: 30px;
}

.header {
  margin-bottom: 30px;
}

.header h1 {
  font-size: 2rem;
  font-weight: 700;
  color: #1f2937;
  margin-bottom: 8px;
}

.subtitle {
  color: #6b7280;
  font-size: 1rem;
}

.loading {
  display: flex;
  align-items: center;
  justify-content: center;
  min-height: 400px;
  font-size: 1.2rem;
  color: #6b7280;
}

.filters {
  display: flex;
  gap: 16px;
  margin-bottom: 24px;
  flex-wrap: wrap;
}

.searchBox {
  flex: 1;
  min-width: 300px;
}

.searchBox input {
  width: 100%;
  padding: 12px 20px;
  border: 2px solid #e5e7eb;
  border-radius: 12px;
  font-size: 1rem;
  transition: all 0.3s;
}

.searchBox input:focus {
  outline: none;
  border-color: #f59e0b;
  box-shadow: 0 0 0 3px rgba(245, 158, 11, 0.1);
}

.statusFilter select {
  padding: 12px 20px;
  border: 2px solid #e5e7eb;
  border-radius: 12px;
  font-size: 1rem;
  background: white;
  cursor: pointer;
  transition: all 0.3s;
}

.statusFilter select:focus {
  outline: none;
  border-color: #f59e0b;
}

.tableContainer {
  background: white;
  border-radius: 16px;
  overflow: hidden;
  box-shadow: 0 2px 12px rgba(0, 0, 0, 0.08);
}

.table {
  width: 100%;
  border-collapse: collapse;
}

.table thead {
  background: #f9fafb;
  border-bottom: 2px solid #e5e7eb;
}

.table th {
  padding: 16px;
  text-align: left;
  font-weight: 600;
  color: #374151;
  font-size: 0.875rem;
  text-transform: uppercase;
  letter-spacing: 0.5px;
}

.table tbody tr {
  border-bottom: 1px solid #f3f4f6;
  transition: background 0.2s;
}

.table tbody tr:hover {
  background: #f9fafb;
}

.table td {
  padding: 16px;
  color: #4b5563;
  font-size: 0.9375rem;
}

.salonName {
  font-weight: 600;
  color: #1f2937;
}

.rating {
  display: inline-flex;
  align-items: center;
  gap: 4px;
  padding: 4px 8px;
  background: #fef3c7;
  border-radius: 6px;
  font-size: 0.875rem;
  font-weight: 600;
  color: #92400e;
}

.status {
  display: inline-block;
  padding: 6px 12px;
  border-radius: 20px;
  font-size: 0.875rem;
  font-weight: 600;
}

.status.active {
  background: #d1fae5;
  color: #065f46;
}

.status.inactive {
  background: #fee2e2;
  color: #991b1b;
}

.actions {
  display: flex;
  gap: 8px;
}

.viewBtn,
.toggleBtn {
  padding: 8px 16px;
  border-radius: 8px;
  font-size: 0.875rem;
  font-weight: 600;
  border: none;
  cursor: pointer;
  transition: all 0.2s;
}

.viewBtn {
  background: #dbeafe;
  color: #1e40af;
}

.viewBtn:hover {
  background: #bfdbfe;
}

.toggleBtn {
  background: #fef3c7;
  color: #92400e;
}

.toggleBtn:hover {
  background: #fde68a;
}

.noData {
  text-align: center;
  padding: 60px 20px;
  color: #9ca3af;
  font-size: 1.125rem;
}

@media (max-width: 1024px) {
  .tableContainer {
    overflow-x: auto;
  }

  .table {
    min-width: 1000px;
  }
}
</file>

<file path="src/styles/Admin/AdminStatsCards.module.css">
.container {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
  gap: 24px;
  margin-bottom: 32px;
}

.card {
  background: white;
  border-radius: 16px;
  padding: 24px;
  display: flex;
  align-items: center;
  gap: 20px;
  box-shadow: 0 2px 12px rgba(0, 0, 0, 0.08);
  transition: all 0.3s ease;
  border-left: 4px solid #f59e0b;
}

.card:hover {
  transform: translateY(-4px);
  box-shadow: 0 8px 20px rgba(0, 0, 0, 0.12);
}

.icon {
  width: 60px;
  height: 60px;
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: 12px;
  font-size: 28px;
}

.content {
  flex: 1;
}

.title {
  font-size: 0.875rem;
  color: #6b7280;
  margin-bottom: 8px;
  font-weight: 500;
}

.value {
  font-size: 2rem;
  font-weight: 700;
  color: #1f2937;
  margin: 0;
}

@media (max-width: 768px) {
  .container {
    grid-template-columns: 1fr;
  }
}
</file>

<file path="src/styles/Admin/AdminUsers.module.css">
.container {
  padding: 30px;
}

.header {
  margin-bottom: 30px;
}

.header h1 {
  font-size: 2rem;
  font-weight: 700;
  color: #1f2937;
  margin-bottom: 8px;
}

.subtitle {
  color: #6b7280;
  font-size: 1rem;
}

.loading {
  display: flex;
  align-items: center;
  justify-content: center;
  min-height: 400px;
  font-size: 1.2rem;
  color: #6b7280;
}

.searchBox {
  margin-bottom: 24px;
}

.searchBox input {
  width: 100%;
  max-width: 500px;
  padding: 12px 20px;
  border: 2px solid #e5e7eb;
  border-radius: 12px;
  font-size: 1rem;
  transition: all 0.3s;
}

.searchBox input:focus {
  outline: none;
  border-color: #3b82f6;
  box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
}

.tableContainer {
  background: white;
  border-radius: 16px;
  overflow: hidden;
  box-shadow: 0 2px 12px rgba(0, 0, 0, 0.08);
}

.table {
  width: 100%;
  border-collapse: collapse;
}

.table thead {
  background: #f9fafb;
  border-bottom: 2px solid #e5e7eb;
}

.table th {
  padding: 16px;
  text-align: left;
  font-weight: 600;
  color: #374151;
  font-size: 0.875rem;
  text-transform: uppercase;
  letter-spacing: 0.5px;
}

.table tbody tr {
  border-bottom: 1px solid #f3f4f6;
  transition: background 0.2s;
}

.table tbody tr:hover {
  background: #f9fafb;
}

.table td {
  padding: 16px;
  color: #4b5563;
  font-size: 0.9375rem;
}

.userName {
  font-weight: 600;
  color: #1f2937;
}

.gender {
  text-transform: capitalize;
}

.status {
  display: inline-block;
  padding: 6px 12px;
  border-radius: 20px;
  font-size: 0.875rem;
  font-weight: 600;
}

.status.active {
  background: #d1fae5;
  color: #065f46;
}

.status.inactive {
  background: #fee2e2;
  color: #991b1b;
}

.viewBtn {
  padding: 8px 16px;
  border-radius: 8px;
  font-size: 0.875rem;
  font-weight: 600;
  border: none;
  cursor: pointer;
  transition: all 0.2s;
  background: #dbeafe;
  color: #1e40af;
}

.viewBtn:hover {
  background: #bfdbfe;
}

.noData {
  text-align: center;
  padding: 60px 20px;
  color: #9ca3af;
  font-size: 1.125rem;
}

@media (max-width: 1024px) {
  .tableContainer {
    overflow-x: auto;
  }

  .table {
    min-width: 900px;
  }
}
</file>

<file path="src/styles/Auth.module.css">
.container {
  min-height: 100vh;
  display: flex;
  align-items: center;
  justify-content: center;
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
}

.loginCard {
  background: white;
  padding: 2rem;
  border-radius: 12px;
  box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
  width: 100%;
  max-width: 400px;
}

.loginCard h1 {
  text-align: center;
  margin-bottom: 1.5rem;
  color: #333;
}

.loginCard form {
  display: flex;
  flex-direction: column;
  gap: 1rem;
}

.loginCard input {
  padding: 12px;
  border: 2px solid #e1e5e9;
  border-radius: 8px;
  font-size: 16px;
}

.loginCard input:focus {
  outline: none;
  border-color: #667eea;
}

.loginCard button {
  background: #667eea;
  color: white;
  border: none;
  padding: 12px;
  border-radius: 8px;
  font-size: 16px;
  cursor: pointer;
  transition: background 0.3s;
}

.loginCard button:hover:not(:disabled) {
  background: #5a6fd8;
}

.loginCard button:disabled {
  background: #ccc;
  cursor: not-allowed;
}

.loginCard p {
  text-align: center;
  margin-top: 1rem;
}

.loginCard a {
  color: #667eea;
  cursor: pointer;
  text-decoration: underline;
}
</file>

<file path="src/styles/Auth/SalonAuth.module.css">
.container {
  min-height: 100vh;
  display: flex;
  align-items: center;
  justify-content: center;
  background: linear-gradient(135deg, var(--gray-50) 0%, var(--gold-50) 100%);
  padding: var(--space-6);
  position: relative;
  overflow: hidden;
}

.container::before {
  content: "";
  position: absolute;
  top: -50%;
  right: -50%;
  width: 100%;
  height: 100%;
  background: radial-gradient(
    circle,
    rgba(212, 175, 55, 0.1) 0%,
    transparent 70%
  );
  animation: float 20s ease-in-out infinite;
}

.loginCard {
  background: var(--background-primary);
  border-radius: var(--radius-3xl);
  padding: var(--space-12);
  max-width: 480px;
  width: 100%;
  box-shadow: var(--shadow-luxury);
  border: 1px solid var(--border-color);
  position: relative;
  z-index: 1;
  animation: fadeInUp 0.6s ease-out;
}

.loginCard::before {
  content: "";
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  height: 4px;
  background: linear-gradient(
    90deg,
    var(--primary),
    var(--primary-dark),
    var(--primary)
  );
  border-radius: var(--radius-3xl) var(--radius-3xl) 0 0;
}

.loginCard h1 {
  font-family: var(--font-display);
  font-size: 2.5rem;
  font-weight: 700;
  text-align: center;
  margin-bottom: var(--space-2);
  background: linear-gradient(
    135deg,
    var(--primary) 0%,
    var(--primary-dark) 100%
  );
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
}

.loginCard form {
  margin-top: var(--space-8);
}

.loginCard input {
  width: 100%;
  padding: var(--space-4) var(--space-5);
  margin-bottom: var(--space-5);
  border: 2px solid var(--border-color);
  border-radius: var(--radius-lg);
  font-size: 1rem;
  font-family: var(--font-body);
  background: var(--background-primary);
  color: var(--text-primary);
  transition: all var(--transition-normal);
}

.loginCard input:focus {
  outline: none;
  border-color: var(--primary);
  box-shadow: 0 0 0 4px rgba(212, 175, 55, 0.1);
  transform: translateY(-2px);
}

.loginCard input::placeholder {
  color: var(--text-tertiary);
}

.loginCard button[type="submit"] {
  width: 100%;
  padding: var(--space-4) var(--space-6);
  background: linear-gradient(
    135deg,
    var(--primary) 0%,
    var(--primary-dark) 100%
  );
  color: var(--black);
  border: none;
  border-radius: var(--radius-lg);
  font-size: 1rem;
  font-weight: 600;
  font-family: var(--font-body);
  cursor: pointer;
  transition: all var(--transition-luxury);
  box-shadow: var(--shadow-md), 0 0 20px rgba(212, 175, 55, 0.3);
  position: relative;
  overflow: hidden;
}

.loginCard button[type="submit"]:hover:not(:disabled) {
  transform: translateY(-2px) scale(1.02);
  box-shadow: var(--shadow-xl), 0 0 30px rgba(212, 175, 55, 0.5);
}

.loginCard button[type="submit"]:disabled {
  opacity: 0.6;
  cursor: not-allowed;
}

.loginCard p {
  text-align: center;
  margin-top: var(--space-6);
  color: var(--text-secondary);
  font-size: 0.9375rem;
}

.loginCard a {
  color: var(--primary);
  font-weight: 600;
  cursor: pointer;
  text-decoration: none;
  transition: color var(--transition-fast);
}

.loginCard a:hover {
  color: var(--primary-dark);
  text-decoration: underline;
}

/* Dark mode */
[data-theme="dark"] .container {
  background: linear-gradient(135deg, var(--gray-900) 0%, var(--gray-800) 100%);
}

[data-theme="dark"] .loginCard {
  background: var(--gray-800);
  border-color: var(--gray-700);
}

@media (max-width: 640px) {
  .loginCard {
    padding: var(--space-8);
  }

  .loginCard h1 {
    font-size: 2rem;
  }
}
</file>

<file path="src/styles/Booking.module.css">
/* styles/Booking.module.css - replace broken CSS with this clear, modular style set */

/* Overlay for modal */
.modalOverlay {
  position: fixed;
  inset: 0;
  background: rgba(0, 0, 0, 0.45);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 1000;
}

/* Modal content */
.modalContent {
  background: #fff;
  padding: 20px;
  border-radius: 10px;
  min-width: 320px;
  max-width: 560px;
  box-shadow: 0 8px 24px rgba(0, 0, 0, 0.12);
}

/* Buttons */
.confirmButton {
  background: #0b76ef;
  color: #fff;
  border: none;
  padding: 8px 12px;
  border-radius: 6px;
  cursor: pointer;
}
.cancelButton {
  background: #eee;
  color: #333;
  border: none;
  padding: 8px 12px;
  border-radius: 6px;
  cursor: pointer;
}
.bookNowButton {
  background: #0b76ef;
  color: #fff;
  border: none;
  padding: 10px 14px;
  border-radius: 8px;
  cursor: pointer;
}

/* Time slots grid */
.timeSlotsWrapper {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
  margin-top: 8px;
}

/* Each slot */
.timeSlot {
  border: 1px solid #ddd;
  padding: 8px 10px;
  border-radius: 6px;
  margin: 4px;
  cursor: pointer;
  min-width: 90px;
  text-align: center;
  user-select: none;
  transition: transform 0.12s ease, box-shadow 0.12s ease;
  background: #fff;
}

/* Hover effect */
.timeSlot:hover {
  transform: translateY(-2px);
  box-shadow: 0 6px 12px rgba(0, 0, 0, 0.06);
}

/* Disabled / unavailable slot */
.timeSlot.disabled {
  opacity: 0.5;
  pointer-events: none;
  transform: none;
  box-shadow: none;
}

/* Selected slot */
.timeSlot.selected {
  border-color: #0b76ef;
  background: rgba(11, 118, 239, 0.08);
  color: #0b76ef;
  font-weight: 600;
}
</file>

<file path="src/styles/BookingConfirmed.module.css">
/* BookingConfirmed.module.css */

.container {
  padding: var(--space-8);
  max-width: 600px;
  margin: 0 auto;
  min-height: 100vh;
}

.loading,
.notFound {
  padding: var(--space-8);
  text-align: center;
  color: var(--text-secondary);
  font-size: 1.125rem;
}

.heading {
  font-family: var(--font-display);
  font-size: 2rem;
  font-weight: 700;
  color: var(--text-primary);
  margin-bottom: var(--space-8);
  text-align: center;
}

.bookingCard {
  background: var(--background-secondary);
  padding: var(--space-8);
  border-radius: var(--radius-xl);
  margin-bottom: var(--space-8);
  border: 1px solid var(--border-color);
  transition: all var(--transition-normal);
}

.bookingInfo {
  margin-bottom: var(--space-4);
  color: var(--text-primary);
  font-size: 1rem;
  line-height: 1.6;
}

.bookingInfo strong {
  color: var(--primary);
  font-weight: 600;
  margin-right: var(--space-2);
}

.statusSection {
  margin-bottom: var(--space-8);
}

.statusHeading {
  font-family: var(--font-display);
  font-size: 1.5rem;
  font-weight: 600;
  color: var(--text-primary);
  margin-bottom: var(--space-6);
}

.statusTracker {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin: var(--space-8) 0;
  position: relative;
}

.statusTracker::before {
  content: "";
  position: absolute;
  top: 15px;
  left: 15px;
  right: 15px;
  height: 2px;
  background: var(--border-color);
  z-index: 0;
}

.statusStep {
  text-align: center;
  position: relative;
  z-index: 1;
  flex: 1;
  transition: all var(--transition-normal);
}

.statusStep.active,
.statusStep.completed {
  opacity: 1;
}

.statusStep.inactive {
  opacity: 0.4;
}

.statusIcon {
  width: 40px;
  height: 40px;
  border-radius: 50%;
  margin: 0 auto var(--space-2);
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 1rem;
  font-weight: bold;
  transition: all var(--transition-luxury);
  box-shadow: var(--shadow-md);
}

.statusIcon.completed {
  background: linear-gradient(135deg, var(--success), #059669);
  color: white;
  animation: scaleIn 0.5s ease-out;
}

.statusIcon.active {
  background: linear-gradient(135deg, var(--primary), var(--primary-dark));
  color: var(--black);
  animation: pulse 2s ease-in-out infinite;
}

.statusIcon.inactive {
  background: var(--gray-400);
  color: white;
}

.statusLabel {
  font-size: 0.75rem;
  color: var(--text-secondary);
  font-weight: 500;
}

.statusStep.active .statusLabel,
.statusStep.completed .statusLabel {
  color: var(--text-primary);
  font-weight: 600;
}

.completedAlert {
  background: linear-gradient(135deg, #d4edda, #c3e6cb);
  border: 2px solid var(--success);
  padding: var(--space-6);
  border-radius: var(--radius-xl);
  margin-bottom: var(--space-8);
  box-shadow: var(--shadow-lg);
  animation: fadeInUp 0.6s ease-out;
}

[data-theme="dark"] .completedAlert {
  background: linear-gradient(
    135deg,
    rgba(16, 185, 129, 0.2),
    rgba(5, 150, 105, 0.15)
  );
  border-color: var(--success);
}

.completedTitle {
  font-family: var(--font-display);
  font-size: 1.5rem;
  font-weight: 700;
  color: var(--success);
  margin: 0 0 var(--space-3) 0;
}

.completedText {
  color: #155724;
  margin: 0;
  font-size: 1rem;
  line-height: 1.6;
}

[data-theme="dark"] .completedText {
  color: var(--text-primary);
}

.feedbackButton {
  background: linear-gradient(135deg, var(--success), #059669);
  color: white;
  border: none;
  padding: var(--space-4) var(--space-8);
  border-radius: var(--radius-lg);
  cursor: pointer;
  margin-top: var(--space-4);
  font-weight: 600;
  font-size: 1rem;
  transition: all var(--transition-luxury);
  box-shadow: var(--shadow-md);
  position: relative;
  overflow: hidden;
}

.feedbackButton::before {
  content: "";
  position: absolute;
  top: 0;
  left: -100%;
  width: 100%;
  height: 100%;
  background: linear-gradient(
    90deg,
    transparent,
    rgba(255, 255, 255, 0.3),
    transparent
  );
  transition: left 0.5s ease;
}

.feedbackButton:hover::before {
  left: 100%;
}

.feedbackButton:hover {
  transform: translateY(-2px) scale(1.02);
  box-shadow: var(--shadow-xl), 0 0 20px rgba(16, 185, 129, 0.4);
}

.feedbackButton:active {
  transform: translateY(0);
}

.pendingAlert {
  background: linear-gradient(135deg, #fff3cd, #ffeaa7);
  border: 2px solid var(--warning);
  padding: var(--space-6);
  border-radius: var(--radius-xl);
  box-shadow: var(--shadow-sm);
}

[data-theme="dark"] .pendingAlert {
  background: linear-gradient(
    135deg,
    rgba(245, 158, 11, 0.2),
    rgba(217, 119, 6, 0.15)
  );
  border-color: var(--warning);
}

.pendingText {
  margin: 0;
  color: #856404;
  font-size: 1rem;
  line-height: 1.6;
}

[data-theme="dark"] .pendingText {
  color: var(--text-primary);
}

@keyframes scaleIn {
  from {
    opacity: 0;
    transform: scale(0.8);
  }
  to {
    opacity: 1;
    transform: scale(1);
  }
}

@keyframes fadeInUp {
  from {
    opacity: 0;
    transform: translateY(20px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

@keyframes pulse {
  0%,
  100% {
    box-shadow: 0 0 0 0 rgba(212, 175, 55, 0.7);
  }
  50% {
    box-shadow: 0 0 0 10px rgba(212, 175, 55, 0);
  }
}

/* Responsive Design */
@media (max-width: 768px) {
  .container {
    padding: var(--space-6);
  }

  .heading {
    font-size: 1.5rem;
  }

  .statusTracker {
    margin: var(--space-6) 0;
  }

  .statusIcon {
    width: 35px;
    height: 35px;
    font-size: 0.875rem;
  }

  .statusLabel {
    font-size: 0.625rem;
  }

  .feedbackButton {
    width: 100%;
  }
}

@media (max-width: 480px) {
  .bookingCard {
    padding: var(--space-6);
  }

  .statusIcon {
    width: 30px;
    height: 30px;
    font-size: 0.75rem;
  }

  .statusLabel {
    font-size: 0.5rem;
  }

  .completedTitle {
    font-size: 1.25rem;
  }
}
</file>

<file path="src/styles/Owner.module.css">
.dashboard {
  display: flex;
  min-height: 100vh;
  background: #f5f7fa;
}

.content {
  flex: 1;
  padding: 30px;
  margin-left: 250px;
}

.header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 30px;
}

.header h1 {
  font-size: 2rem;
  color: #333;
}

.date {
  color: #666;
  font-size: 1.1rem;
}

.statsGrid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
  gap: 25px;
  margin-bottom: 40px;
}

.statCard {
  background: white;
  padding: 25px;
  border-radius: 12px;
  box-shadow: 0 2px 10px rgba(0, 0, 0, 0.08);
}

.statCard h3 {
  color: #666;
  font-size: 0.95rem;
  margin-bottom: 10px;
  font-weight: normal;
}

.statNumber {
  font-size: 2.5rem;
  font-weight: bold;
  color: #333;
  margin-bottom: 10px;
}

.statSubtext {
  color: #999;
  font-size: 0.9rem;
}

.upcomingSection,
.notifications,
.quickActions {
  background: white;
  padding: 25px;
  border-radius: 12px;
  margin-bottom: 25px;
  box-shadow: 0 2px 10px rgba(0, 0, 0, 0.08);
}

.appointmentList {
  margin-top: 20px;
}

.appointmentCard {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 15px;
  border: 1px solid #e0e0e0;
  border-radius: 8px;
  margin-bottom: 12px;
}

.appointmentCard:hover {
  background: #f8f9fa;
}

.time {
  font-weight: bold;
  color: #667eea;
  font-size: 1.1rem;
  min-width: 80px;
}

.customerInfo {
  flex: 1;
  margin-left: 20px;
}

.customerInfo strong {
  display: block;
  margin-bottom: 5px;
}

.customerInfo span {
  color: #666;
  font-size: 0.9rem;
}

.barber {
  color: #999;
  font-size: 0.9rem;
  margin-right: 15px;
}

.actionBtn {
  background: #667eea;
  color: white;
  padding: 8px 16px;
  border-radius: 6px;
  font-size: 0.9rem;
}

.actionGrid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
  gap: 15px;
  margin-top: 20px;
}

.actionButton {
  padding: 20px;
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  color: white;
  border-radius: 10px;
  font-size: 1rem;
  transition: transform 0.2s;
}

.actionButton:hover {
  transform: scale(1.05);
}

.notificationList {
  margin-top: 20px;
}

.notification {
  display: flex;
  align-items: start;
  padding: 15px;
  border-bottom: 1px solid #e0e0e0;
}

.notification:last-child {
  border-bottom: none;
}

.notifIcon {
  font-size: 1.5rem;
  margin-right: 15px;
}

.notifContent {
  flex: 1;
}

.notifContent strong {
  display: block;
  margin-bottom: 5px;
}

.notifContent p {
  color: #666;
  font-size: 0.9rem;
  margin-bottom: 5px;
}

.notifTime {
  color: #999;
  font-size: 0.85rem;
}

/* Forms */
.formOverlay {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(0, 0, 0, 0.5);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 1000;
}

.formModal {
  background: white;
  padding: 30px;
  border-radius: 12px;
  width: 90%;
  max-width: 500px;
}

.formGroup {
  margin-bottom: 20px;
}

.formGroup label {
  display: block;
  margin-bottom: 8px;
  color: #333;
  font-weight: 500;
}

.formGroup input,
.formGroup textarea,
.formGroup select {
  width: 100%;
  padding: 10px;
  border: 1px solid #ddd;
  border-radius: 6px;
  font-size: 1rem;
}

.formRow {
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  gap: 15px;
}

.formActions {
  display: flex;
  gap: 15px;
  margin-top: 25px;
}

.saveBtn {
  flex: 1;
  padding: 12px;
  background: #667eea;
  color: white;
  border-radius: 6px;
  font-size: 1rem;
}

.cancelBtn {
  flex: 1;
  padding: 12px;
  background: #e0e0e0;
  color: #333;
  border-radius: 6px;
  font-size: 1rem;
}

.addButton {
  background: #667eea;
  color: white;
  padding: 10px 20px;
  border-radius: 6px;
  font-size: 1rem;
}

/* Services */
.servicesGrid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
  gap: 20px;
  margin-bottom: 40px;
}

.serviceCard {
  background: white;
  padding: 20px;
  border-radius: 10px;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
}

.serviceHeader {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 10px;
}

.genderBadge {
  background: #f0f0f0;
  padding: 4px 12px;
  border-radius: 20px;
  font-size: 0.85rem;
  color: #666;
}

.serviceDesc {
  color: #666;
  margin-bottom: 15px;
  min-height: 40px;
}

.serviceDetails {
  display: flex;
  justify-content: space-between;
  margin-bottom: 15px;
  padding-top: 15px;
  border-top: 1px solid #f0f0f0;
}

.serviceActions {
  display: flex;
  gap: 10px;
}

.editBtn,
.deleteBtn {
  flex: 1;
  padding: 8px;
  border-radius: 6px;
  font-size: 0.9rem;
}

.editBtn {
  background: #f0f0f0;
  color: #333;
}

.deleteBtn {
  background: #fee;
  color: #c00;
}

.packagesSection {
  background: white;
  padding: 25px;
  border-radius: 12px;
  box-shadow: 0 2px 10px rgba(0, 0, 0, 0.08);
}

.addPackageBtn {
  background: #667eea;
  color: white;
  padding: 10px 20px;
  border-radius: 6px;
  margin-top: 15px;
}

.packageList {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
  gap: 20px;
  margin-top: 20px;
}

.packageCard {
  border: 2px solid #667eea;
  border-radius: 10px;
  padding: 20px;
  background: linear-gradient(
    135deg,
    rgba(102, 126, 234, 0.1) 0%,
    rgba(118, 75, 162, 0.1) 100%
  );
}

.packagePrice {
  display: flex;
  align-items: center;
  gap: 10px;
  margin-top: 15px;
}

.originalPrice {
  text-decoration: line-through;
  color: #999;
}

.discountPrice {
  font-size: 1.5rem;
  font-weight: bold;
  color: #667eea;
}
</file>

<file path="src/styles/ReviewsSection.module.css">
.reviewsSection {
  width: 100%;
  max-width: 1400px;
  margin: 40px auto;
  padding: 0 20px;
}

.mainTitle {
  font-size: 1.875rem;
  font-weight: 700;
  color: var(--text-primary);
  margin-bottom: 24px;
  text-align: center;
}

.loading,
.noReviews {
  text-align: center;
  padding: 40px;
  color: var(--text-secondary);
}
.reviewsContainer {
  display: flex;
  gap: 24px;
  margin-bottom: 24px;
}
.reviewsContainerright {
  width: 70%;
}
.statsHeader {
  display: flex;
  gap: 32px;
  background: var(--background-secondary);
  border: 1px solid var(--border-color);
  border-radius: 16px;
  padding: 24px;
  margin-bottom: 24px;
}

.overallBox {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  padding: 16px 24px;
  background: var(--background-primary);
  border-radius: 12px;
  border: 2px solid var(--primary);
  min-width: 140px;
}

.bigRating {
  font-size: 3rem;
  font-weight: 800;
  color: var(--primary);
  line-height: 1;
}

.stars {
  font-size: 1.125rem;
  margin: 4px 0;
}

.reviewCount {
  font-size: 0.875rem;
  color: var(--text-secondary);
}

/* Breakdown Bars */
.breakdown {
  flex: 1;
  display: flex;
  flex-direction: column;
  justify-content: center;
  gap: 16px;
}

.breakdownRow {
  display: grid;
  grid-template-columns: 100px 1fr 50px 60px;
  align-items: center;
  gap: 12px;
}

.label {
  font-size: 0.875rem;
  font-weight: 600;
  color: var(--text-primary);
}

.bar {
  height: 8px;
  background: var(--gray-200);
  border-radius: 10px;
  overflow: hidden;
}

.fill {
  height: 100%;
  border-radius: 10px;
  transition: width 0.5s ease;
}

.fill.positive {
  background: #10b981;
}

.fill.medium {
  background: #f59e0b;
}

.fill.critical {
  background: #ef4444;
}

.percent {
  font-size: 0.875rem;
  font-weight: 700;
  color: var(--text-primary);
  text-align: right;
}

.count {
  font-size: 0.8125rem;
  color: var(--text-secondary);
}

/* Controls Section */
.controls {
  display: flex;
  justify-content: space-between;
  align-items: flex-start;
  margin-bottom: 24px;
  gap: 20px;
  flex-wrap: wrap;
  flex-direction: column;
  align-content: center;
}
.filterPills {
  display: flex;
  gap: 12px;
  flex-wrap: wrap;
  flex: 1;
}

/* Sort Dropdown */
.sortDropdown {
  display: flex;
  align-items: center;
  gap: 10px;
}

.sortDropdown label {
  font-size: 0.875rem;
  font-weight: 600;
  color: var(--text-secondary);
  white-space: nowrap;
}

.sortDropdown select {
  padding: 10px 16px;
  background: var(--background-secondary);
  border: 2px solid var(--border-color);
  border-radius: 10px;
  font-size: 0.875rem;
  font-weight: 600;
  color: var(--text-primary);
  cursor: pointer;
  transition: all 0.3s;
  min-width: 160px;
}

.sortDropdown select:hover {
  border-color: var(--primary);
}

.sortDropdown select:focus {
  outline: none;
  border-color: var(--primary);
  box-shadow: 0 0 0 3px rgba(var(--primary-rgb), 0.1);
}

@media (max-width: 768px) {
  .controls {
    flex-direction: column;
    align-items: stretch;
  }

  .sortDropdown {
    justify-content: space-between;
  }

  .sortDropdown select {
    flex: 1;
  }
}

/* Filter Pills */
.filterPills {
  display: flex;
  gap: 12px;
  margin-bottom: 24px;
  flex-wrap: wrap;
}

.pill {
  padding: 10px 20px;
  background: var(--background-secondary);
  border: 2px solid var(--border-color);
  border-radius: 24px;
  font-size: 0.875rem;
  font-weight: 600;
  color: var(--text-primary);
  cursor: pointer;
  transition: all 0.3s;
}

.pill:hover {
  border-color: var(--primary);
}

.pill.active {
  background: var(--primary);
  color: var(--black);
  border-color: var(--primary);
}

/* Reviews Grid - 3 Columns */
.reviewsGrid {
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  gap: 16px;
  margin-bottom: 24px;
}

.reviewCard {
  background: var(--background-secondary);
  border: 1px solid var(--border-color);
  border-radius: 12px;
  padding: 16px;
  transition: all 0.3s;
  display: flex;
  flex-direction: column;
  gap: 12px;
}

.reviewCard:hover {
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
  transform: translateY(-2px);
}

.cardHeader {
  display: flex;
  justify-content: space-between;
  align-items: flex-start;
}

.user {
  display: flex;
  align-items: center;
  gap: 10px;
  flex: 1;
  min-width: 0;
}

.avatar {
  width: 36px;
  height: 36px;
  border-radius: 50%;
  background: linear-gradient(135deg, var(--primary), var(--primary-dark));
  color: var(--black);
  display: flex;
  align-items: center;
  justify-content: center;
  font-weight: 700;
  font-size: 1rem;
  flex-shrink: 0;
}

.name {
  font-size: 0.9375rem;
  font-weight: 700;
  color: var(--text-primary);
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

.service {
  font-size: 0.8125rem;
  color: var(--text-secondary);
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

.badge {
  background: var(--primary);
  color: var(--black);
  padding: 6px 10px;
  border-radius: 8px;
  font-size: 0.875rem;
  font-weight: 700;
  flex-shrink: 0;
}

.comment {
  font-size: 0.875rem;
  line-height: 1.4;
  color: var(--text-primary);
  margin: 0;
  font-style: italic;
  overflow: hidden;
  text-overflow: ellipsis;
  display: -webkit-box;
  -webkit-line-clamp: 2;
  -webkit-box-orient: vertical;
}

.meta {
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.date {
  font-size: 0.75rem;
  color: var(--text-tertiary);
}

/* Show More */
.showMore {
  text-align: center;
}

.showMore button {
  padding: 12px 32px;
  background: var(--primary);
  color: var(--black);
  border: none;
  border-radius: 12px;
  font-weight: 700;
  font-size: 0.9375rem;
  cursor: pointer;
  transition: all 0.3s;
}

.showMore button:hover {
  background: var(--primary-dark);
  transform: translateY(-2px);
}

.noResults {
  text-align: center;
  padding: 40px;
  color: var(--text-secondary);
}

/* Responsive */
@media (max-width: 1200px) {
  .reviewsGrid {
    grid-template-columns: repeat(2, 1fr);
  }
}

@media (max-width: 968px) {
  .statsHeader {
    flex-direction: column;
  }

  .breakdownRow {
    grid-template-columns: 90px 1fr 45px 55px;
  }
}

@media (max-width: 640px) {
  .reviewsGrid {
    grid-template-columns: 1fr;
  }

  .breakdownRow {
    grid-template-columns: 80px 1fr 40px 50px;
    gap: 8px;
  }

  .label {
    font-size: 0.8125rem;
  }
}
</file>

<file path="src/styles/SalonDetails.module.css">
.container {
  min-height: 100vh;
  background: linear-gradient(135deg, #fef3c7, #fed7aa);
}

.header {
  display: flex;
  align-items: center;
  padding: 20px;
  background: white;
  box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
  position: sticky;
  top: 0;
  z-index: 100;
}

.backBtn {
  background: #f59e0b;
  color: white;
  border: none;
  padding: 8px 16px;
  border-radius: 8px;
  font-weight: 600;
  cursor: pointer;
  margin-right: 20px;
}

.heroSection {
  position: relative;
  padding: 40px 20px;
}

.imageGallery {
  width: 100%;
  max-width: 1200px;
  margin: 0 auto 30px;
  border-radius: 20px;
  overflow: hidden;
}

.heroImage {
  width: 100%;
  height: 400px;
  object-fit: cover;
}

.heroContent {
  max-width: 1200px;
  margin: 0 auto;
}

.salonInfo {
  background: white;
  padding: 30px;
  border-radius: 20px;
  box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
}

.salonName {
  font-size: 32px;
  font-weight: 700;
  color: #1f2937;
  margin: 0 0 10px;
}

.address {
  color: #6b7280;
  font-size: 16px;
  margin: 0 0 20px;
}

.badges {
  display: flex;
  gap: 10px;
  margin-bottom: 20px;
}

.badge {
  background: #f59e0b;
  color: white;
  padding: 6px 12px;
  border-radius: 12px;
  font-size: 14px;
  font-weight: 600;
}

.stats {
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  gap: 20px;
  margin-bottom: 30px;
}

.stat {
  text-align: center;
  padding: 20px;
  background: #fef3c7;
  border-radius: 12px;
}

.statNumber {
  display: block;
  font-size: 24px;
  font-weight: 700;
  color: #d97706;
  margin-bottom: 5px;
}

.statLabel {
  font-size: 14px;
  color: #92400e;
}

.actionButtons {
  display: flex;
  gap: 15px;
}

.bookButton {
  flex: 1;
  background: linear-gradient(135deg, #f59e0b, #d97706);
  color: white;
  border: none;
  padding: 15px 30px;
  border-radius: 12px;
  font-size: 18px;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.3s;
}

.bookButton:hover {
  transform: translateY(-2px);
  box-shadow: 0 8px 20px rgba(245, 158, 11, 0.3);
}

.directionsButton {
  background: white;
  color: #f59e0b;
  border: 2px solid #f59e0b;
  padding: 15px 20px;
  border-radius: 12px;
  font-size: 16px;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.3s;
}

.directionsButton:hover {
  background: #f59e0b;
  color: white;
}

.servicesSection {
  padding: 40px 20px;
  max-width: 1200px;
  margin: 0 auto;
}

.servicesSection h2 {
  font-size: 28px;
  font-weight: 700;
  color: #1f2937;
  margin-bottom: 30px;
  text-align: center;
}

.servicesGrid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
  gap: 20px;
}

.serviceCard {
  background: white;
  padding: 20px;
  border-radius: 16px;
  box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
  cursor: pointer;
  transition: all 0.3s;
  display: flex;
  align-items: center;
  gap: 15px;
}

.serviceCard:hover {
  transform: translateY(-4px);
  box-shadow: 0 8px 25px rgba(0, 0, 0, 0.15);
}

.serviceIcon {
  font-size: 32px;
  width: 60px;
  height: 60px;
  display: flex;
  align-items: center;
  justify-content: center;
  background: #fef3c7;
  border-radius: 12px;
}

.serviceDetails h3 {
  font-size: 18px;
  font-weight: 600;
  color: #1f2937;
  margin: 0 0 5px;
}

.serviceDetails p {
  color: #6b7280;
  font-size: 14px;
  margin: 0 0 10px;
}

.serviceMeta {
  display: flex;
  gap: 15px;
}

.price {
  font-size: 16px;
  font-weight: 700;
  color: #f59e0b;
}

.duration {
  font-size: 14px;
  color: #6b7280;
}

.locationSection {
  padding: 40px 20px;
  max-width: 1200px;
  margin: 0 auto;
}

.locationSection h2 {
  font-size: 28px;
  font-weight: 700;
  color: #1f2937;
  margin-bottom: 20px;
  text-align: center;
}

.reviewsSection {
  padding: 40px 20px;
  max-width: 1200px;
  margin: 0 auto;
}

.reviewsSection h2 {
  font-size: 28px;
  font-weight: 700;
  color: #1f2937;
  margin-bottom: 30px;
  text-align: center;
}

.reviewsList {
  display: grid;
  gap: 20px;
}

.reviewCard {
  background: white;
  padding: 20px;
  border-radius: 16px;
  box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
}

.reviewHeader {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 10px;
}

.userName {
  font-weight: 600;
  color: #1f2937;
}

.rating {
  color: #f59e0b;
  font-weight: 600;
}

.reviewComment {
  color: #4b5563;
  margin: 10px 0;
  line-height: 1.6;
}

.reviewMeta {
  display: flex;
  justify-content: space-between;
  font-size: 14px;
  color: #6b7280;
}

.noReviews {
  text-align: center;
  color: #6b7280;
  font-style: italic;
  padding: 40px;
}

.modalOverlay {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(0, 0, 0, 0.5);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 1000;
}

.bookingModal {
  background: white;
  padding: 30px;
  border-radius: 20px;
  width: 90%;
  max-width: 500px;
  box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
  position: relative;
  max-height: 90vh;
  overflow-y: auto;
  animation: fadeInScale 0.3s ease-out;
}
@keyframes fadeInScale {
  from {
    opacity: 0;
    transform: scale(0.95);
  }
  to {
    opacity: 1;
    transform: scale(1);
  }
}
.closeModalBtn {
  position: absolute;
  top: 15px;
  right: 15px;
  background: #f59e0b;
  color: white;
  border: none;
  width: 30px;
  height: 30px;
  border-radius: 50%;
  font-size: 18px;
  font-weight: bold;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
}
.closeModalBtn:hover {
  background: #d97706;
}
.mapContainer {
  position: relative;
  height: 600px;
  margin-top: 40px;
  border-radius: 20px;
  overflow: hidden;
  box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
  max-width: 1200px;
  margin-left: auto;
  margin-right: auto;
  background: white;
  padding: 20px;
  box-sizing: border-box;
  margin-bottom: 60px;
  border-radius: 20px;
  overflow: hidden;
  box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
  border: 2px solid #f3f4f6;
  background: #f9fafb;
  border-radius: 20px;
}
</file>

<file path="src/styles/SalonRegister.module.css">
/* Salon Registration Form Styles */

.container {
  min-height: 100vh;
  padding: var(--space-8) var(--space-4);
  background: var(--background-primary);
  transition: background-color var(--transition-normal);
  max-width: 1000px;
  margin: 0 auto;
}

/* Header Section */
.header {
  text-align: center;
  margin-bottom: var(--space-8);
  animation: fadeInDown 0.8s ease-out;
}

.headerIcon {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  width: 64px;
  height: 64px;
  border-radius: var(--radius-full);
  margin-bottom: var(--space-4);
  box-shadow: var(--shadow-lg);
}

.headerTitle {
  font-family: var(--font-display);
  font-size: 2.5rem;
  font-weight: 700;
  margin-bottom: var(--space-2);
  background: linear-gradient(135deg, var(--primary), var(--primary-dark));
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
}

.headerSubtitle {
  font-size: 1.125rem;
  color: var(--text-secondary);
}

/* Progress Steps */
.progressSteps {
  display: flex;
  align-items: center;
  justify-content: center;
  margin-bottom: var(--space-8);
  flex-wrap: nowrap;
  overflow-x: auto;
  padding: var(--space-4) 0;
}

.stepCircle {
  display: flex;
  align-items: center;
  justify-content: center;
  width: 40px;
  height: 40px;
  min-width: 40px;
  border-radius: var(--radius-full);
  font-weight: 700;
  transition: all var(--transition-luxury);
  box-shadow: var(--shadow-sm);
}

.stepLine {
  width: 48px;
  height: 4px;
  margin: 0 var(--space-2);
  border-radius: var(--radius-full);
  transition: all var(--transition-normal);
}

/* Form Card */
.formCard {
  max-width: 1000px;
  margin: 0 auto;
  background: var(--background-secondary);
  border: 1px solid var(--border-color);
  border-radius: var(--radius-2xl);
  padding: var(--space-10);
  box-shadow: var(--shadow-luxury);
  backdrop-filter: blur(10px);
}

/* Form Steps */
.stepContainer {
  animation: slideIn 0.6s ease-out;
}

.stepTitle {
  font-family: var(--font-display);
  font-size: 1.875rem;
  font-weight: 700;
  color: var(--text-primary);
  margin-bottom: var(--space-6);
  display: flex;
  align-items: center;
  gap: var(--space-3);
}

/* Grid Layouts */
.formGrid {
  display: grid;
  grid-template-columns: repeat(2, 1fr);
  gap: var(--space-6);
}

.formGridFull {
  grid-column: span 2;
}

/* Form Groups */
.formGroup {
  display: flex;
  flex-direction: column;
  gap: var(--space-2);
}

.formLabel {
  font-weight: 600;
  color: var(--text-primary);
  font-size: 0.9375rem;
}

.formInput {
  width: 100%;
  padding: var(--space-4);
  background: var(--background-primary);
  border: 2px solid var(--border-color);
  border-radius: var(--radius-lg);
  color: var(--text-primary);
  font-size: 1rem;
  transition: all var(--transition-normal);
}

.formInput:focus {
  outline: none;
  border-color: var(--primary);
  box-shadow: 0 0 0 3px rgba(212, 175, 55, 0.1);
}

.formInput::placeholder {
  color: var(--text-tertiary);
}

.inputWithIcon {
  position: relative;
}

.inputIcon {
  position: absolute;
  left: var(--space-3);
  top: 50%;
  transform: translateY(-50%);
  width: 20px;
  height: 20px;
  color: var(--text-tertiary);
}

.inputWithIcon .formInput {
  padding-left: var(--space-12);
}

/* Textarea */
.textarea {
  width: 100%;
  padding: var(--space-4);
  background: var(--background-primary);
  border: 2px solid var(--border-color);
  border-radius: var(--radius-lg);
  color: var(--text-primary);
  font-size: 1rem;
  font-family: var(--font-body);
  resize: vertical;
  min-height: 100px;
  transition: all var(--transition-normal);
}

.textarea:focus {
  outline: none;
  border-color: var(--primary);
  box-shadow: 0 0 0 3px rgba(212, 175, 55, 0.1);
}

/* Location Picker Button */
.locationButton {
  width: 100%;
  padding: var(--space-4);
  padding-left: var(--space-12);
  background: var(--background-primary);
  border: 2px solid var(--border-color);
  border-radius: var(--radius-lg);
  color: var(--text-secondary);
  text-align: left;
  cursor: pointer;
  transition: all var(--transition-normal);
}

.locationButton:hover {
  background: var(--background-tertiary);
  border-color: var(--primary);
}

/* Modal Overlay */
.modalOverlay {
  position: fixed;
  inset: 0;
  z-index: 100;
  display: flex;
  align-items: center;
  justify-content: center;
  background: rgba(0, 0, 0, 0.7);
  backdrop-filter: blur(5px);
  padding: var(--space-6);
}

.modalContent {
  background: var(--background-primary);
  border-radius: var(--radius-2xl);
  padding: var(--space-8);
  box-shadow: var(--shadow-2xl);
  position: relative;
  width: 100%;
  max-width: 800px;
  max-height: 90vh;
  overflow-y: auto;
}

.modalClose {
  position: absolute;
  top: var(--space-4);
  right: var(--space-4);
  background: transparent;
  border: none;
  color: var(--text-secondary);
  font-size: 1.5rem;
  cursor: pointer;
  transition: color var(--transition-fast);
}

.modalClose:hover {
  color: var(--text-primary);
}

/* Barber Cards */
.barberCard {
  padding: var(--space-6);
  background: var(--background-primary);
  border: 2px solid var(--border-color);
  border-radius: var(--radius-xl);
  margin-bottom: var(--space-6);
  transition: all var(--transition-normal);
}

.barberCard:hover {
  border-color: var(--primary);
  box-shadow: var(--shadow-md);
}

.barberHeader {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: var(--space-4);
}

.barberTitle {
  font-weight: 600;
  color: var(--text-primary);
  font-size: 1.125rem;
}

.removeButton {
  background: transparent;
  border: none;
  color: var(--error);
  font-size: 1.25rem;
  cursor: pointer;
  transition: opacity var(--transition-fast);
}

.removeButton:hover {
  opacity: 0.7;
}

.barberInputGrid {
  display: grid;
  grid-template-columns: repeat(2, 1fr);
  gap: var(--space-4);
}

/* Skills Grid */
.skillsLabel {
  display: block;
  font-size: 0.875rem;
  font-weight: 600;
  color: var(--text-primary);
  margin-bottom: var(--space-2);
}

.skillsGrid {
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  gap: var(--space-2);
}

.skillCheckbox {
  display: flex;
  align-items: center;
  gap: var(--space-2);
}

.skillCheckbox input[type="checkbox"] {
  width: 18px;
  height: 18px;
  border-radius: var(--radius-sm);
  border: 2px solid var(--border-color);
  cursor: pointer;
}

.skillCheckbox input[type="checkbox"]:checked {
  background: var(--primary);
  border-color: var(--primary);
}

.skillCheckbox label {
  font-size: 0.875rem;
  color: var(--text-secondary);
  cursor: pointer;
}

/* Add Barber Button */
.addBarberButton {
  width: 100%;
  padding: var(--space-4);
  border: 2px dashed var(--border-color);
  background: transparent;
  border-radius: var(--radius-xl);
  color: var(--text-secondary);
  font-weight: 600;
  cursor: pointer;
  transition: all var(--transition-normal);
}

.addBarberButton:hover {
  border-color: var(--primary);
  color: var(--primary);
  background: rgba(212, 175, 55, 0.05);
}

/* Service Cards */
.servicesGrid {
  display: grid;
  grid-template-columns: repeat(2, 1fr);
  gap: var(--space-4);
}

.serviceCard {
  padding: var(--space-4);
  border: 2px solid var(--border-color);
  border-radius: var(--radius-xl);
  background: var(--background-primary);
  transition: all var(--transition-luxury);
  cursor: pointer;
}

.serviceCard:hover {
  border-color: var(--primary);
}

.serviceCard.active {
  background: linear-gradient(
    135deg,
    rgba(212, 175, 55, 0.15),
    rgba(212, 175, 55, 0.05)
  );
  border-color: var(--primary);
}

.serviceHeader {
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin-bottom: var(--space-3);
}

.serviceCheckbox {
  display: flex;
  align-items: center;
  gap: var(--space-3);
}

.serviceCheckbox input[type="checkbox"] {
  width: 20px;
  height: 20px;
  border-radius: var(--radius-sm);
  cursor: pointer;
}

.serviceIcon {
  width: 20px;
  height: 20px;
}

.serviceName {
  font-weight: 600;
  color: var(--text-primary);
}

.priceInput {
  display: flex;
  align-items: center;
  gap: var(--space-2);
  animation: slideIn 0.3s ease-out;
}

.priceSymbol {
  font-size: 0.875rem;
  font-weight: 600;
  color: var(--text-secondary);
}

.priceInput input {
  flex: 1;
  padding: var(--space-2) var(--space-3);
  background: var(--background-secondary);
  border: 2px solid var(--border-color);
  border-radius: var(--radius-md);
  color: var(--text-primary);
  font-size: 0.9375rem;
}

.priceInput input:focus {
  outline: none;
  border-color: var(--primary);
}

/* Validation Errors */
.errorText {
  color: var(--error);
  font-size: 0.875rem;
  margin-top: var(--space-1);
}

.inputError {
  border-color: var(--error) !important;
}

/* Navigation Buttons */
.navigationButtons {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-top: var(--space-10);
  padding-top: var(--space-8);
  border-top: 1px solid var(--border-color);
}

.prevButton {
  padding: var(--space-4) var(--space-8);
  background: transparent;
  border: 2px solid var(--border-color);
  border-radius: var(--radius-lg);
  color: var(--text-primary);
  font-weight: 600;
  cursor: pointer;
  transition: all var(--transition-luxury);
}

.prevButton:hover {
  background: var(--background-tertiary);
  border-color: var(--primary);
}

.nextButton {
  padding: var(--space-4) var(--space-10);
  background: linear-gradient(135deg, var(--primary), var(--primary-dark));
  border: none;
  border-radius: var(--radius-lg);
  color: var(--black);
  font-weight: 700;
  font-size: 1rem;
  cursor: pointer;
  transition: all var(--transition-luxury);
  box-shadow: var(--shadow-lg);
  margin-left: auto;
}

.nextButton:hover {
  transform: translateY(-2px);
  box-shadow: var(--shadow-xl), 0 0 20px rgba(212, 175, 55, 0.4);
}

/* Sign In Link */
.signInSection {
  text-align: center;
  margin-top: var(--space-8);
  padding-top: var(--space-6);
  border-top: 1px solid var(--border-color);
}

.signInText {
  color: var(--text-secondary);
  font-size: 0.9375rem;
}

.signInLink {
  color: var(--primary);
  font-weight: 600;
  text-decoration: none;
  transition: opacity var(--transition-fast);
}

.signInLink:hover {
  opacity: 0.8;
}

/* Animations */
@keyframes fadeInDown {
  from {
    opacity: 0;
    transform: translateY(-30px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

@keyframes slideIn {
  from {
    opacity: 0;
    transform: translateX(-30px);
  }
  to {
    opacity: 1;
    transform: translateX(0);
  }
}

/* Tablet Responsive */
@media (max-width: 1024px) {
  .formCard {
    padding: var(--space-8);
  }

  .servicesGrid {
    grid-template-columns: 1fr;
  }

  .skillsGrid {
    grid-template-columns: repeat(2, 1fr);
  }
}

/* Mobile Responsive */
@media (max-width: 768px) {
  .container {
    padding: var(--space-6) var(--space-4);
  }

  .headerTitle {
    font-size: 2rem;
  }

  .headerSubtitle {
    font-size: 1rem;
  }

  .formCard {
    padding: var(--space-6);
  }

  .stepTitle {
    font-size: 1.5rem;
  }

  .formGrid {
    grid-template-columns: 1fr;
  }

  .formGridFull {
    grid-column: span 1;
  }

  .barberInputGrid {
    grid-template-columns: 1fr;
  }

  .servicesGrid {
    grid-template-columns: 1fr;
  }

  .skillsGrid {
    grid-template-columns: 1fr;
  }

  .progressSteps {
    padding: var(--space-2);
  }

  .stepCircle {
    width: 36px;
    height: 36px;
    min-width: 36px;
    font-size: 0.875rem;
  }

  .stepLine {
    width: 32px;
  }

  .navigationButtons {
    flex-direction: column-reverse;
    gap: var(--space-4);
  }

  .prevButton,
  .nextButton {
    width: 100%;
    margin-left: 0;
  }
}

/* Small Mobile */
@media (max-width: 480px) {
  .headerIcon {
    width: 48px;
    height: 48px;
  }

  .headerTitle {
    font-size: 1.75rem;
  }

  .formCard {
    padding: var(--space-5);
  }

  .stepTitle {
    font-size: 1.25rem;
  }

  .formInput,
  .textarea,
  .locationButton {
    padding: var(--space-3);
  }

  .barberCard {
    padding: var(--space-4);
  }
}

/* Dark Mode Overrides */
[data-theme="dark"] .formCard {
  background: var(--gray-800);
  border-color: var(--gray-700);
}

[data-theme="dark"] .formInput,
[data-theme="dark"] .textarea,
[data-theme="dark"] .locationButton {
  background: var(--gray-900);
  border-color: var(--gray-700);
  color: var(--white);
}

[data-theme="dark"] .barberCard {
  background: var(--gray-700);
  border-color: var(--gray-600);
}

[data-theme="dark"] .serviceCard {
  background: var(--gray-900);
  border-color: var(--gray-700);
}

[data-theme="dark"] .serviceCard.active {
  background: linear-gradient(
    135deg,
    rgba(255, 215, 0, 0.25),
    rgba(255, 215, 0, 0.15)
  );
  border-color: #ffd700;
}

[data-theme="dark"] .modalContent {
  background: var(--gray-800);
}

[data-theme="dark"] .priceInput input {
  background: var(--gray-800);
  border-color: var(--gray-600);
} /* Salon Registration Form Styles */

.container {
  min-height: 100vh;
  padding: var(--space-8) var(--space-4);
  background: var(--background-primary);
  transition: background-color var(--transition-normal);
}

/* Dark Mode Toggle */
.darkModeToggle {
  position: fixed;
  top: var(--space-4);
  right: var(--space-4);
  z-index: 50;
  padding: var(--space-3);
  border-radius: var(--radius-full);
  transition: all var(--transition-luxury);
  box-shadow: var(--shadow-lg);
}

/* Header Section */
.header {
  text-align: center;
  margin-bottom: var(--space-8);
  animation: fadeInDown 0.8s ease-out;
}

.headerIcon {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  width: 64px;
  height: 64px;
  border-radius: var(--radius-full);
  margin-bottom: var(--space-4);
  box-shadow: var(--shadow-lg);
}

.headerTitle {
  font-family: var(--font-display);
  font-size: 2.5rem;
  font-weight: 700;
  margin-bottom: var(--space-2);
  background: linear-gradient(135deg, var(--primary), var(--primary-dark));
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
}

.headerSubtitle {
  font-size: 1.125rem;
  color: var(--text-secondary);
}

/* Progress Steps */
.progressSteps {
  display: flex;
  align-items: center;
  justify-content: center;
  margin-bottom: var(--space-8);
  flex-wrap: nowrap;
  overflow-x: auto;
  padding: var(--space-4) 0;
}

.stepCircle {
  display: flex;
  align-items: center;
  justify-content: center;
  width: 40px;
  height: 40px;
  min-width: 40px;
  border-radius: var(--radius-full);
  font-weight: 700;
  transition: all var(--transition-luxury);
  box-shadow: var(--shadow-sm);
}

.stepLine {
  width: 48px;
  height: 4px;
  margin: 0 var(--space-2);
  border-radius: var(--radius-full);
  transition: all var(--transition-normal);
}

/* Form Card */
.formCard {
  max-width: 1000px;
  margin: 0 auto;
  background: var(--background-secondary);
  border: 1px solid var(--border-color);
  border-radius: var(--radius-2xl);
  padding: var(--space-10);
  box-shadow: var(--shadow-luxury);
  backdrop-filter: blur(10px);
}

/* Form Steps */
.stepContainer {
  animation: slideIn 0.6s ease-out;
}

.stepTitle {
  font-family: var(--font-display);
  font-size: 1.875rem;
  font-weight: 700;
  color: var(--text-primary);
  margin-bottom: var(--space-6);
  display: flex;
  align-items: center;
  gap: var(--space-3);
}

/* Grid Layouts */
.formGrid {
  display: grid;
  grid-template-columns: repeat(2, 1fr);
  gap: var(--space-6);
}

.formGridFull {
  grid-column: span 2;
}

/* Form Groups */
.formGroup {
  display: flex;
  flex-direction: column;
  gap: var(--space-2);
}

.formLabel {
  font-weight: 600;
  color: var(--text-primary);
  font-size: 0.9375rem;
}

.formInput {
  width: 100%;
  padding: var(--space-4);
  background: var(--background-primary);
  border: 2px solid var(--border-color);
  border-radius: var(--radius-lg);
  color: var(--text-primary);
  font-size: 1rem;
  transition: all var(--transition-normal);
}

.formInput:focus {
  outline: none;
  border-color: var(--primary);
  box-shadow: 0 0 0 3px rgba(212, 175, 55, 0.1);
}

.formInput::placeholder {
  color: var(--text-tertiary);
}

.inputWithIcon {
  position: relative;
}

.inputIcon {
  position: absolute;
  left: var(--space-3);
  top: 50%;
  transform: translateY(-50%);
  width: 20px;
  height: 20px;
  color: var(--text-tertiary);
}

.inputWithIcon .formInput {
  padding-left: var(--space-12);
}

/* Textarea */
.textarea {
  width: 100%;
  padding: var(--space-4);
  background: var(--background-primary);
  border: 2px solid var(--border-color);
  border-radius: var(--radius-lg);
  color: var(--text-primary);
  font-size: 1rem;
  font-family: var(--font-body);
  resize: vertical;
  min-height: 100px;
  transition: all var(--transition-normal);
}

.textarea:focus {
  outline: none;
  border-color: var(--primary);
  box-shadow: 0 0 0 3px rgba(212, 175, 55, 0.1);
}

/* Location Picker Button */
.locationButton {
  width: 100%;
  padding: var(--space-4);
  padding-left: var(--space-12);
  background: var(--background-primary);
  border: 2px solid var(--border-color);
  border-radius: var(--radius-lg);
  color: var(--text-secondary);
  text-align: left;
  cursor: pointer;
  transition: all var(--transition-normal);
}

.locationButton:hover {
  background: var(--background-tertiary);
  border-color: var(--primary);
}

/* Modal Overlay */
.modalOverlay {
  position: fixed;
  inset: 0;
  z-index: 100;
  display: flex;
  align-items: center;
  justify-content: center;
  background: rgba(0, 0, 0, 0.7);
  backdrop-filter: blur(5px);
  padding: var(--space-6);
}

.modalContent {
  background: var(--background-primary);
  border-radius: var(--radius-2xl);
  padding: var(--space-8);
  box-shadow: var(--shadow-2xl);
  position: relative;
  width: 100%;
  max-width: 800px;
  max-height: 90vh;
  overflow-y: auto;
}

.modalClose {
  position: absolute;
  top: var(--space-4);
  right: var(--space-4);
  background: transparent;
  border: none;
  color: var(--text-secondary);
  font-size: 1.5rem;
  cursor: pointer;
  transition: color var(--transition-fast);
}

.modalClose:hover {
  color: var(--text-primary);
}

/* Barber Cards */
.barberCard {
  padding: var(--space-6);
  background: var(--background-primary);
  border: 2px solid var(--border-color);
  border-radius: var(--radius-xl);
  margin-bottom: var(--space-6);
  transition: all var(--transition-normal);
}

.barberCard:hover {
  border-color: var(--primary);
  box-shadow: var(--shadow-md);
}

.barberHeader {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: var(--space-4);
}

.barberTitle {
  font-weight: 600;
  color: var(--text-primary);
  font-size: 1.125rem;
}

.removeButton {
  background: transparent;
  border: none;
  color: var(--error);
  font-size: 1.25rem;
  cursor: pointer;
  transition: opacity var(--transition-fast);
}

.removeButton:hover {
  opacity: 0.7;
}

.barberInputGrid {
  display: grid;
  grid-template-columns: repeat(2, 1fr);
  gap: var(--space-4);
}

/* Skills Grid */
.skillsLabel {
  display: block;
  font-size: 0.875rem;
  font-weight: 600;
  color: var(--text-primary);
  margin-bottom: var(--space-2);
}

.skillsGrid {
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  gap: var(--space-2);
}

.skillCheckbox {
  display: flex;
  align-items: center;
  gap: var(--space-2);
}

.skillCheckbox input[type="checkbox"] {
  width: 18px;
  height: 18px;
  border-radius: var(--radius-sm);
  border: 2px solid var(--border-color);
  cursor: pointer;
}

.skillCheckbox input[type="checkbox"]:checked {
  background: var(--primary);
  border-color: var(--primary);
}

.skillCheckbox label {
  font-size: 0.875rem;
  color: var(--text-secondary);
  cursor: pointer;
}

/* Add Barber Button */
.addBarberButton {
  width: 100%;
  padding: var(--space-4);
  border: 2px dashed var(--border-color);
  background: transparent;
  border-radius: var(--radius-xl);
  color: var(--text-secondary);
  font-weight: 600;
  cursor: pointer;
  transition: all var(--transition-normal);
}

.addBarberButton:hover {
  border-color: var(--primary);
  color: var(--primary);
  background: rgba(212, 175, 55, 0.05);
}

/* Service Cards */
.servicesGrid {
  display: grid;
  grid-template-columns: repeat(2, 1fr);
  gap: var(--space-4);
}

.serviceCard {
  padding: var(--space-4);
  border: 2px solid var(--border-color);
  border-radius: var(--radius-xl);
  background: var(--background-primary);
  transition: all var(--transition-luxury);
  cursor: pointer;
}

.serviceCard:hover {
  border-color: var(--primary);
}

.serviceCard.active {
  background: linear-gradient(
    135deg,
    rgba(212, 175, 55, 0.15),
    rgba(212, 175, 55, 0.05)
  );
  border-color: var(--primary);
}

.serviceHeader {
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin-bottom: var(--space-3);
}

.serviceCheckbox {
  display: flex;
  align-items: center;
  gap: var(--space-3);
}

.serviceCheckbox input[type="checkbox"] {
  width: 20px;
  height: 20px;
  border-radius: var(--radius-sm);
  cursor: pointer;
}

.serviceIcon {
  width: 20px;
  height: 20px;
}

.serviceName {
  font-weight: 600;
  color: var(--text-primary);
}

.priceInput {
  display: flex;
  align-items: center;
  gap: var(--space-2);
  animation: slideIn 0.3s ease-out;
}

.priceSymbol {
  font-size: 0.875rem;
  font-weight: 600;
  color: var(--text-secondary);
}

.priceInput input {
  flex: 1;
  padding: var(--space-2) var(--space-3);
  background: var(--background-secondary);
  border: 2px solid var(--border-color);
  border-radius: var(--radius-md);
  color: var(--text-primary);
  font-size: 0.9375rem;
}

.priceInput input:focus {
  outline: none;
  border-color: var(--primary);
}

/* Validation Errors */
.errorText {
  color: var(--error);
  font-size: 0.875rem;
  margin-top: var(--space-1);
}

.inputError {
  border-color: var(--error) !important;
}

/* Navigation Buttons */
.navigationButtons {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-top: var(--space-10);
  padding-top: var(--space-8);
  border-top: 1px solid var(--border-color);
}

.prevButton {
  padding: var(--space-4) var(--space-8);
  background: transparent;
  border: 2px solid var(--border-color);
  border-radius: var(--radius-lg);
  color: var(--text-primary);
  font-weight: 600;
  cursor: pointer;
  transition: all var(--transition-luxury);
}

.prevButton:hover {
  background: var(--background-tertiary);
  border-color: var(--primary);
}

.nextButton {
  padding: var(--space-4) var(--space-10);
  background: linear-gradient(135deg, var(--primary), var(--primary-dark));
  border: none;
  border-radius: var(--radius-lg);
  color: var(--black);
  font-weight: 700;
  font-size: 1rem;
  cursor: pointer;
  transition: all var(--transition-luxury);
  box-shadow: var(--shadow-lg);
  margin-left: auto;
}

.nextButton:hover {
  transform: translateY(-2px);
  box-shadow: var(--shadow-xl), 0 0 20px rgba(212, 175, 55, 0.4);
}

/* Sign In Link */
.signInSection {
  text-align: center;
  margin-top: var(--space-8);
  padding-top: var(--space-6);
  border-top: 1px solid var(--border-color);
}

.signInText {
  color: var(--text-secondary);
  font-size: 0.9375rem;
}

.signInLink {
  color: var(--primary);
  font-weight: 600;
  text-decoration: none;
  transition: opacity var(--transition-fast);
}

.signInLink:hover {
  opacity: 0.8;
}

/* Animations */
@keyframes fadeInDown {
  from {
    opacity: 0;
    transform: translateY(-30px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

@keyframes slideIn {
  from {
    opacity: 0;
    transform: translateX(-30px);
  }
  to {
    opacity: 1;
    transform: translateX(0);
  }
}

/* Tablet Responsive */
@media (max-width: 1024px) {
  .formCard {
    padding: var(--space-8);
  }

  .servicesGrid {
    grid-template-columns: 1fr;
  }

  .skillsGrid {
    grid-template-columns: repeat(2, 1fr);
  }
}

/* Mobile Responsive */
@media (max-width: 768px) {
  .container {
    padding: var(--space-6) var(--space-4);
  }

  .headerTitle {
    font-size: 2rem;
  }

  .headerSubtitle {
    font-size: 1rem;
  }

  .formCard {
    padding: var(--space-6);
  }

  .stepTitle {
    font-size: 1.5rem;
  }

  .formGrid {
    grid-template-columns: 1fr;
  }

  .formGridFull {
    grid-column: span 1;
  }

  .barberInputGrid {
    grid-template-columns: 1fr;
  }

  .servicesGrid {
    grid-template-columns: 1fr;
  }

  .skillsGrid {
    grid-template-columns: 1fr;
  }

  .progressSteps {
    padding: var(--space-2);
  }

  .stepCircle {
    width: 36px;
    height: 36px;
    min-width: 36px;
    font-size: 0.875rem;
  }

  .stepLine {
    width: 32px;
  }

  .navigationButtons {
    flex-direction: column-reverse;
    gap: var(--space-4);
  }

  .prevButton,
  .nextButton {
    width: 100%;
    margin-left: 0;
  }
}

/* Small Mobile */
@media (max-width: 480px) {
  .headerIcon {
    width: 48px;
    height: 48px;
  }

  .headerTitle {
    font-size: 1.75rem;
  }

  .formCard {
    padding: var(--space-5);
  }

  .stepTitle {
    font-size: 1.25rem;
  }

  .formInput,
  .textarea,
  .locationButton {
    padding: var(--space-3);
  }

  .barberCard {
    padding: var(--space-4);
  }
}

/* Dark Mode Overrides */
[data-theme="dark"] .formCard {
  background: var(--gray-800);
  border-color: var(--gray-700);
}

[data-theme="dark"] .formInput,
[data-theme="dark"] .textarea,
[data-theme="dark"] .locationButton {
  background: var(--gray-900);
  border-color: var(--gray-700);
  color: var(--white);
}

[data-theme="dark"] .barberCard {
  background: var(--gray-700);
  border-color: var(--gray-600);
}

[data-theme="dark"] .serviceCard {
  background: var(--gray-900);
  border-color: var(--gray-700);
}

[data-theme="dark"] .serviceCard.active {
  background: linear-gradient(
    135deg,
    rgba(255, 215, 0, 0.25),
    rgba(255, 215, 0, 0.15)
  );
  border-color: #ffd700;
}

[data-theme="dark"] .modalContent {
  background: var(--gray-800);
}

[data-theme="dark"] .priceInput input {
  background: var(--gray-800);
  border-color: var(--gray-600);
}
</file>

<file path="src/styles/WalkinBarberSelect.module.css">
.container {
  max-width: 1200px;
  margin: 0 auto;
  padding: 20px;
}

.title {
  text-align: center;
  font-size: 32px;
  margin-bottom: 30px;
}

.overallStats {
  display: flex;
  justify-content: space-around;
  margin-bottom: 40px;
  padding: 20px;
  background: #f5f5f5;
  border-radius: 10px;
}

.statItem {
  display: flex;
  flex-direction: column;
  align-items: center;
}

.statIcon {
  font-size: 24px;
}

.statValue {
  font-size: 24px;
  font-weight: bold;
  margin: 5px 0;
}

.statLabel {
  font-size: 14px;
  color: #666;
}

.chairsGrid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
  gap: 20px;
  margin-bottom: 30px;
}

.chairCard {
  border: 2px solid #ddd;
  border-radius: 10px;
  padding: 20px;
  cursor: pointer;
  transition: transform 0.2s, box-shadow 0.2s;
}

.chairCard:hover {
  transform: translateY(-5px);
  box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
}

.chairCard.available {
  border-color: #4caf50;
  background: #f0f9f0;
}

.chairCard.occupied {
  border-color: #ff9800;
  background: #fff8f0;
}

.chairIcon {
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin-bottom: 15px;
}

.statusDot {
  width: 20px;
  height: 20px;
  border-radius: 50%;
}

.statusDot.available {
  background: #4caf50;
}

.statusDot.occupied {
  background: #ff9800;
  animation: pulse 2s infinite;
}

@keyframes pulse {
  0%,
  100% {
    opacity: 1;
  }
  50% {
    opacity: 0.5;
  }
}

.chairNumber {
  font-size: 18px;
  font-weight: bold;
  color: #333;
}

.barberName {
  font-size: 20px;
  margin-bottom: 10px;
}

.availableTag {
  background: #4caf50;
  color: white;
  padding: 5px 10px;
  border-radius: 5px;
  font-size: 14px;
  text-align: center;
  margin: 10px 0;
}

.occupiedInfo {
  margin: 10px 0;
}

.servingText {
  font-size: 14px;
  color: #ff9800;
  margin-bottom: 5px;
}

.timeLeft {
  font-size: 14px;
  color: #666;
}

.queueBadge {
  background: #f44336;
  color: white;
  padding: 5px 10px;
  border-radius: 5px;
  font-size: 12px;
  text-align: center;
  margin: 10px 0;
}

.waitEstimate {
  text-align: center;
  margin-top: 15px;
  font-size: 16px;
  font-weight: bold;
}

.noWait {
  color: #4caf50;
}

.waitTime {
  color: #ff9800;
}

.legend {
  display: flex;
  justify-content: center;
  gap: 30px;
  margin-top: 30px;
}

.legendItem {
  display: flex;
  align-items: center;
  gap: 10px;
}

.dot {
  width: 15px;
  height: 15px;
  border-radius: 50%;
}

.dot.green {
  background: #4caf50;
}

.dot.orange {
  background: #ff9800;
}

.dot.red {
  background: #f44336;
}

.loading,
.error {
  text-align: center;
  padding: 50px;
  font-size: 18px;
}
</file>

<file path="src/styles/WalkinConfirmation.module.css">
.container {
  min-height: 100vh;
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 20px;
  background: white;
}

.card {
  background: white;
  border-radius: 20px;
  padding: 40px;
  max-width: 500px;
  width: 100%;
  box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
}

.title {
  text-align: center;
  color: #4caf50;
  margin-bottom: 30px;
  font-size: 28px;
}

.qrCode {
  width: 200px;
  height: 200px;
  border: 4px solid #000;
  border-radius: 8px;
  padding: 10px;
  background: white;
}

.qrPlaceholder {
  width: 200px;
  height: 200px;
  border: 4px solid #ddd;
  border-radius: 8px;
  display: flex;
  align-items: center;
  justify-content: center;
  background: #f5f5f5;
  color: #666;
  font-size: 14px;
}

.bookingCode {
  font-size: 24px;
  font-weight: bold;
  margin: 15px 0 5px;
  color: #333;
  letter-spacing: 2px;
}

.qrInstruction {
  font-size: 14px;
  color: #666;
}

.details {
  margin-bottom: 30px;
}

.detailItem {
  display: flex;
  justify-content: space-between;
  padding: 12px 0;
  border-bottom: 1px solid #eee;
  font-size: 16px;
}

.detailItem span {
  color: #666;
}

.detailItem strong {
  color: #333;
}
.statusBadge.orange {
  background: #fff3e0;
  color: #e65100;
  border-color: #ff9800;
}

.statusBadge.green {
  background: #e8f5e9;
  color: #2e7d32;
  border-color: #4caf50;
}

.statusBadge.completed {
  background: #f3e5f5;
  color: #6a1b9a;
  border-color: #9c27b0;
}

.statusBadge {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 10px;
  padding: 15px;
  border-radius: 10px;
  margin-bottom: 20px;
  font-weight: 500;
}

.statusBadge.red {
  background: #ffebee;
  color: #c62828;
}

.statusDot {
  width: 12px;
  height: 12px;
  border-radius: 50%;
  background: currentColor;
  animation: pulse 2s infinite;
}

@keyframes pulse {
  0%,
  100% {
    opacity: 1;
  }
  50% {
    opacity: 0.5;
  }
}

.expiryAlert {
  background: #fff3cd;
  border: 2px solid #ffc107;
  border-radius: 10px;
  padding: 15px;
  text-align: center;
  margin-bottom: 20px;
}

.expiryAlert p {
  margin: 5px 0;
}

.expiryAlert strong {
  font-size: 20px;
  color: #ff6b00;
}

.note {
  font-size: 12px;
  color: #666;
}

.instructions {
  background: #f5f5f5;
  padding: 20px;
  border-radius: 10px;
  margin-bottom: 20px;
}

.instructions h3 {
  margin: 0 0 15px;
  color: #333;
}

.instructions ol {
  margin: 0;
  padding-left: 20px;
}

.instructions li {
  margin: 10px 0;
  font-size: 16px;
  line-height: 1.6;
}

.actions {
  display: flex;
  gap: 12px;
}

.btnPrimary,
.btnSecondary {
  flex: 1;
  padding: 14px;
  border: none;
  border-radius: 10px;
  font-size: 16px;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.3s ease;
}

.btnPrimary {
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  color: white;
}

.btnPrimary:hover {
  transform: translateY(-2px);
  box-shadow: 0 8px 20px rgba(102, 126, 234, 0.4);
}

.btnSecondary {
  background: #f5f5f5;
  color: #333;
}

.btnSecondary:hover {
  background: #e0e0e0;
}

.loading,
.error {
  text-align: center;
  padding: 50px;
  background: white;
  border-radius: 20px;
}

.error h2 {
  color: #f44336;
  margin-bottom: 15px;
}

.error button {
  margin-top: 20px;
  padding: 12px 24px;
  background: #667eea;
  color: white;
  border: none;
  border-radius: 8px;
  cursor: pointer;
  font-size: 16px;
}

/* Mobile */
@media (max-width: 768px) {
  .card {
    padding: 30px 20px;
  }

  .actions {
    flex-direction: column;
  }
}
</file>

<file path="src/components/Admin/UserDetailsModal.js">
import { useState, useEffect } from "react";
import styles from "../../styles/Admin/AdminModal.module.css";

export default function UserDetailsModal({ user, onClose }) {
  const [bookings, setBookings] = useState([]);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    fetchUserBookings();
  }, []);

  const fetchUserBookings = async () => {
    try {
      const token = localStorage.getItem("adminToken");
      const response = await fetch(`/api/admin/users/${user._id}/bookings`, {
        headers: { Authorization: `Bearer ${token}` },
      });
      const data = await response.json();
      setBookings(data.bookings || []);
    } catch (error) {
      console.error("Error fetching user bookings:", error);
    } finally {
      setLoading(false);
    }
  };

  return (
    <div className={styles.overlay} onClick={onClose}>
      <div className={styles.modal} onClick={(e) => e.stopPropagation()}>
        <button className={styles.closeBtn} onClick={onClose}>
          ✕
        </button>

        <h2 className={styles.title}>{user.name}</h2>

        {loading ? (
          <div className={styles.loading}>Loading details...</div>
        ) : (
          <div className={styles.content}>
            {/* Basic Info */}
            <section className={styles.section}>
              <h3>User Information</h3>
              <div className={styles.info}>
                <p>
                  <strong>Email:</strong> {user.email || "N/A"}
                </p>
                <p>
                  <strong>Phone:</strong> {user.phoneNumber || user.phone}
                </p>
                <p>
                  <strong>Age:</strong> {user.age ? `${user.age} years` : "N/A"}
                </p>
                <p>
                  <strong>Gender:</strong> {user.gender}
                </p>
                {user.location && (
                  <p>
                    <strong>Location:</strong> {user.location.address || "Set"}
                  </p>
                )}
                <p>
                  <strong>Status:</strong>{" "}
                  {user.isActive ? "Active" : "Inactive"}
                </p>
                <p>
                  <strong>Joined:</strong>{" "}
                  {new Date(user.createdAt).toLocaleDateString()}
                </p>
              </div>
            </section>

            {/* Booking History */}
            <section className={styles.section}>
              <h3>Booking History ({bookings.length})</h3>
              <div className={styles.list}>
                {bookings.map((booking) => (
                  <div key={booking._id} className={styles.listItem}>
                    <p>
                      <strong>{booking.service}</strong>
                    </p>
                    <p className={styles.small}>
                      {booking.salonName} - {booking.date} at {booking.time}
                    </p>
                    <p className={styles.small}>
                      Status: {booking.status} | ₹{booking.price}
                    </p>
                  </div>
                ))}
              </div>
            </section>

            {/* Reviews Given */}
            <section className={styles.section}>
              <h3>Reviews & Feedback</h3>
              <div className={styles.list}>
                {bookings
                  .filter((b) => b.feedback?.submitted)
                  .map((booking) => (
                    <div key={booking._id} className={styles.listItem}>
                      <p>⭐ {booking.feedback.ratings.overall}/5</p>
                      <p className={styles.small}>{booking.feedback.comment}</p>
                    </div>
                  ))}
              </div>
            </section>
          </div>
        )}
      </div>
    </div>
  );
}
</file>

<file path="src/components/Background.js">
// import { useEffect, useRef } from "react";
// import * as THREE from "three";

// export default function SoftMeshGradient({
//   color1 = "#8B5CF6",
//   color2 = "#3B82F6",
//   color3 = "#EC4899",
//   color4 = "#F59E0B",
//   speed = 0.5,
//   distortion = 2.5,
//   swirl = 3.0,
// }) {
//   const containerRef = useRef(null);

//   useEffect(() => {
//     if (!containerRef.current) return;
//     const container = containerRef.current;

//     const scene = new THREE.Scene();
//     const camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);

//     const renderer = new THREE.WebGLRenderer({
//       antialias: true,
//       alpha: true,
//     });
//     renderer.setSize(window.innerWidth, window.innerHeight);
//     renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
//     container.appendChild(renderer.domElement);

//     const vertexShader = `
//       varying vec2 vUv;
//       void main() {
//         vUv = uv;
//         gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
//       }
//     `;

//     const fragmentShader = `
//       uniform float uTime;
//       uniform vec2 uResolution;
//       uniform vec3 uColor1;
//       uniform vec3 uColor2;
//       uniform vec3 uColor3;
//       uniform vec3 uColor4;
//       uniform float uDistortion;
//       uniform float uSwirl;
//       uniform float uSpeed;
//       varying vec2 vUv;

//       vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
//       vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
//       vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }
//       vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }

//       float snoise(vec3 v) {
//         const vec2 C = vec2(1.0/6.0, 1.0/3.0);
//         const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);

//         vec3 i  = floor(v + dot(v, C.yyy));
//         vec3 x0 = v - i + dot(i, C.xxx);

//         vec3 g = step(x0.yzx, x0.xyz);
//         vec3 l = 1.0 - g;
//         vec3 i1 = min(g.xyz, l.zxy);
//         vec3 i2 = max(g.xyz, l.zxy);

//         vec3 x1 = x0 - i1 + C.xxx;
//         vec3 x2 = x0 - i2 + C.yyy;
//         vec3 x3 = x0 - D.yyy;

//         i = mod289(i);
//         vec4 p = permute(permute(permute(
//                   i.z + vec4(0.0, i1.z, i2.z, 1.0))
//                 + i.y + vec4(0.0, i1.y, i2.y, 1.0))
//                 + i.x + vec4(0.0, i1.x, i2.x, 1.0));

//         float n_ = 0.142857142857;
//         vec3 ns = n_ * D.wyz - D.xzx;

//         vec4 j = p - 49.0 * floor(p * ns.z * ns.z);

//         vec4 x_ = floor(j * ns.z);
//         vec4 y_ = floor(j - 7.0 * x_);

//         vec4 x = x_ *ns.x + ns.yyyy;
//         vec4 y = y_ *ns.x + ns.yyyy;
//         vec4 h = 1.0 - abs(x) - abs(y);

//         vec4 b0 = vec4(x.xy, y.xy);
//         vec4 b1 = vec4(x.zw, y.zw);

//         vec4 s0 = floor(b0)*2.0 + 1.0;
//         vec4 s1 = floor(b1)*2.0 + 1.0;
//         vec4 sh = -step(h, vec4(0.0));

//         vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;
//         vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;

//         vec3 p0 = vec3(a0.xy, h.x);
//         vec3 p1 = vec3(a0.zw, h.y);
//         vec3 p2 = vec3(a1.xy, h.z);
//         vec3 p3 = vec3(a1.zw, h.w);

//         vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));
//         p0 *= norm.x;
//         p1 *= norm.y;
//         p2 *= norm.z;
//         p3 *= norm.w;

//         vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
//         m = m * m;
//         return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));
//       }

//       void main() {
//         vec2 uv = vUv;
//         float time = uTime * uSpeed * 0.1;

//         vec3 pos1 = vec3(uv * uDistortion, time * 0.3);
//         vec3 pos2 = vec3(uv * uDistortion * 1.5, time * 0.4);

//         float noise1 = snoise(pos1);
//         float noise2 = snoise(pos2);

//         vec2 warpedUv = uv;
//         warpedUv.x += noise1 * 0.15 * uSwirl;
//         warpedUv.y += noise2 * 0.15 * uSwirl;

//         vec3 pos3 = vec3(warpedUv * 2.0, time * 0.2);
//         vec3 pos4 = vec3(warpedUv * 3.0, time * 0.25);

//         float noise3 = snoise(pos3);
//         float noise4 = snoise(pos4);

//         float mixer1 = (noise3 + 1.0) * 0.5;
//         float mixer2 = (noise4 + 1.0) * 0.5;

//         vec3 color = mix(
//           mix(uColor1, uColor2, mixer1),
//           mix(uColor3, uColor4, mixer2),
//           (noise1 + noise2 + 2.0) * 0.25
//         );

//         float brightness = 1.0 + (noise1 * 0.1);
//         color *= brightness;

//         gl_FragColor = vec4(color, 1.0);
//       }
//     `;

//     const hexToRgb = (hex) => {
//       const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
//       return result
//         ? {
//             r: parseInt(result[1], 16) / 255,
//             g: parseInt(result[2], 16) / 255,
//             b: parseInt(result[3], 16) / 255,
//           }
//         : { r: 0.5, g: 0.5, b: 0.5 };
//     };

//     const c1 = hexToRgb(color1);
//     const c2 = hexToRgb(color2);
//     const c3 = hexToRgb(color3);
//     const c4 = hexToRgb(color4);

//     const material = new THREE.ShaderMaterial({
//       vertexShader,
//       fragmentShader,
//       uniforms: {
//         uTime: { value: 0 },
//         uResolution: {
//           value: new THREE.Vector2(window.innerWidth, window.innerHeight),
//         },
//         uColor1: { value: new THREE.Vector3(c1.r, c1.g, c1.b) },
//         uColor2: { value: new THREE.Vector3(c2.r, c2.g, c2.b) },
//         uColor3: { value: new THREE.Vector3(c3.r, c3.g, c3.b) },
//         uColor4: { value: new THREE.Vector3(c4.r, c4.g, c4.b) },
//         uDistortion: { value: distortion },
//         uSwirl: { value: swirl },
//         uSpeed: { value: speed },
//       },
//     });

//     const geometry = new THREE.PlaneGeometry(2, 2);
//     const mesh = new THREE.Mesh(geometry, material);
//     scene.add(mesh);

//     const clock = new THREE.Clock();

//     const animate = () => {
//       material.uniforms.uTime.value = clock.getElapsedTime();
//       renderer.render(scene, camera);
//       requestAnimationFrame(animate);
//     };
//     animate();

//     const handleResize = () => {
//       const width = window.innerWidth;
//       const height = window.innerHeight;
//       renderer.setSize(width, height);
//       material.uniforms.uResolution.value.set(width, height);
//     };

//     window.addEventListener("resize", handleResize);

//     return () => {
//       window.removeEventListener("resize", handleResize);
//       if (container) {
//         container.removeChild(renderer.domElement);
//       }
//       geometry.dispose();
//       material.dispose();
//       renderer.dispose();
//     };
//   }, [color1, color2, color3, color4, speed, distortion, swirl]);

//   return (
//     <div
//       ref={containerRef}
//       style={{
//         position: "fixed",
//         top: 0,
//         left: 0,
//         width: "100%",
//         height: "100%",
//         zIndex: -1,
//       }}
//     />
//   );
// }
</file>

<file path="src/components/Background.module.css">
.gradientContainer {
  position: fixed;
  top: 0;
  left: 0;
  width: 100vw;
  height: 100vh;
  overflow: hidden;
  z-index: -1;
  background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
}

.g1,
.g2,
.g3,
.g4,
.g5 {
  position: absolute;
  mix-blend-mode: soft-light;
  filter: blur(150px);
  opacity: 0.7;
  will-change: transform;
}

.g1 {
  width: 120vw;
  height: 120vw;
  max-width: 1000px;
  max-height: 1000px;
  top: -50vh;
  left: -40vw;
  background: radial-gradient(
    circle at center,
    rgba(212, 175, 55, 0.4) 0%,
    rgba(212, 175, 55, 0) 50%
  );

  animation: float1 25s ease-in-out infinite;
}

.g2 {
  width: 100vw;
  height: 100vw;
  max-width: 900px;
  max-height: 900px;
  top: -30vh;
  right: -30vw;
  background: radial-gradient(
    circle at center,
    rgba(255, 215, 0, 0.35) 0%,
    rgba(255, 215, 0, 0) 50%
  );

  animation: float2 20s ease-in-out infinite;
}

.g3 {
  width: 110vw;
  height: 110vw;
  max-width: 950px;
  max-height: 950px;
  bottom: -40vh;
  left: -20vw;
  background: radial-gradient(
    circle at center,
    rgba(184, 134, 11, 0.3) 0%,
    rgba(184, 134, 11, 0) 50%
  );

  animation: float3 22s ease-in-out infinite;
}

.g4 {
  width: 90vw;
  height: 90vw;
  max-width: 850px;
  max-height: 850px;
  bottom: -35vh;
  right: -25vw;
  background: radial-gradient(
    circle at center,
    rgba(218, 165, 32, 0.28) 0%,
    rgba(218, 165, 32, 0) 50%
  );

  animation: float4 18s ease-in-out infinite;
}

.g5 {
  width: 95vw;
  height: 95vw;
  max-width: 880px;
  max-height: 880px;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background: radial-gradient(
    circle at center,
    rgba(255, 223, 186, 0.25) 0%,
    rgba(255, 223, 186, 0) 50%
  );

  animation: float5 24s ease-in-out infinite;
}

@keyframes float1 {
  0%,
  100% {
    transform: translate(0, 0) scale(1);
  }
  33% {
    transform: translate(8vw, 12vh) scale(1.05);
  }
  66% {
    transform: translate(-5vw, 18vh) scale(0.98);
  }
}

@keyframes float2 {
  0%,
  100% {
    transform: translate(0, 0) scale(1);
  }
  33% {
    transform: translate(-10vw, 8vh) scale(1.08);
  }
  66% {
    transform: translate(6vw, -10vh) scale(0.95);
  }
}

@keyframes float3 {
  0%,
  100% {
    transform: translate(0, 0) scale(1);
  }
  33% {
    transform: translate(-8vw, -15vh) scale(1.06);
  }
  66% {
    transform: translate(12vw, -8vh) scale(0.96);
  }
}

@keyframes float4 {
  0%,
  100% {
    transform: translate(0, 0) scale(1);
  }
  33% {
    transform: translate(12vw, -10vh) scale(1.04);
  }
  66% {
    transform: translate(-10vw, 6vh) scale(0.97);
  }
}

@keyframes float5 {
  0%,
  100% {
    transform: translate(-50%, -50%) scale(1);
  }
  33% {
    transform: translate(calc(-50% + 5vw), calc(-50% + 8vh)) scale(1.03);
  }
  66% {
    transform: translate(calc(-50% - 8vw), calc(-50% - 5vh)) scale(0.99);
  }
}

/* Mobile optimization */
@media (max-width: 768px) {
  .g1,
  .g2,
  .g3,
  .g4,
  .g5 {
    filter: blur(100px);
  }
}

/* Respect reduced motion */
@media (prefers-reduced-motion: reduce) {
  .g1,
  .g2,
  .g3,
  .g4,
  .g5 {
    animation: none !important;
  }
}
</file>

<file path="src/lib/auth.js">
import bcrypt from "bcryptjs";
import jwt from "jsonwebtoken";

export const hashPassword = async (password) => {
  const saltRounds = 12;
  return await bcrypt.hash(password, saltRounds);
};

export const verifyPassword = async (password, hashedPassword) => {
  return await bcrypt.compare(password, hashedPassword);
};

export const generateToken = (userId, role, email) => {
  return jwt.sign({ userId, role, email }, process.env.JWT_SECRET, {
    expiresIn: "7d",
  });
};

export const verifyToken = (token) => {
  try {
    const decoded = jwt.verify(token, process.env.JWT_SECRET);
    console.log("Token decoded successfully:", decoded);
    return decoded;
  } catch (error) {
    console.error("Token verification failed:", error.message);
    return null;
  }
};

export const getLocationFromCoordinates = async (lat, lng) => {
  try {
    // Using reverse geocoding - you might want to use a proper service like Google Maps API
    const response = await fetch(
      `https://nominatim.openstreetmap.org/reverse?format=json&lat=${lat}&lon=${lng}`
    );
    const data = await response.json();
    return {
      address: data.display_name,
      city: data.address?.city || data.address?.town || data.address?.village,
      state: data.address?.state,
      country: data.address?.country,
      postcode: data.address?.postcode,
    };
  } catch (error) {
    console.error("Error getting location:", error);
    return null;
  }
};
</file>

<file path="src/lib/mongodb.js">
// lib/mongodb.js
import { MongoClient, ServerApiVersion } from "mongodb";

const uri = process.env.MONGODB_URI;

const options = {
  serverApi: {
    version: ServerApiVersion.v1,
    strict: true,
    deprecationErrors: true,
  },
  maxPoolSize: 10,
  serverSelectionTimeoutMS: 5000,
  socketTimeoutMS: 45000,
  connectTimeoutMS: 5000,
  maxIdleTimeMS: 30000,
  // REMOVED: bufferMaxEntries - this option is deprecated/not supported
};

if (!uri) {
  throw new Error("Please add your Mongo URI to .env.local (MONGODB_URI)");
}

let client;
let clientPromise;

if (process.env.NODE_ENV === "development") {
  if (!global._mongoClientPromise) {
    client = new MongoClient(uri, options);
    global._mongoClientPromise = client.connect();
  }
  clientPromise = global._mongoClientPromise;
} else {
  client = new MongoClient(uri, options);
  clientPromise = client.connect();
}

export default clientPromise;

export async function connectToDatabase() {
  try {
    const client = await clientPromise;
    const db = client.db(process.env.MONGODB_DB);

    // Test the connection
    await client.db("admin").command({ ping: 1 });
    console.log("✅ Connected to MongoDB!");

    return { client, db };
  } catch (error) {
    console.error("❌ Database connection failed:", error.message);

    // Reset global cache on connection failure
    if (process.env.NODE_ENV === "development") {
      global._mongoClientPromise = null;
    }

    throw error;
  }
}
</file>

<file path="src/pages/api/auth/forgot-password.js">
import clientPromise from "../../../lib/mongodb";
import { generateResetToken } from "../../../lib/resetToken";
import { checkRateLimit } from "../../../lib/rateLimit";
import nodemailer from "nodemailer";

export default async function handler(req, res) {
  if (req.method !== "POST") {
    return res.status(405).json({ message: "Method not allowed" });
  }

  try {
    const { email } = req.body;

    if (!email || !email.includes("@")) {
      return res.status(400).json({ message: "Valid email is required" });
    }

    const normalizedEmail = email.toLowerCase().trim();

    // ✅ RATE LIMITING: 3 requests per hour per email
    const rateCheck = checkRateLimit(normalizedEmail, 3, 60 * 60 * 1000);

    if (!rateCheck.allowed) {
      return res.status(429).json({
        message: `Too many reset attempts. Please try again in ${rateCheck.resetIn} minutes.`,
        retryAfter: rateCheck.resetIn * 60,
      });
    }

    const client = await clientPromise;
    const db = client.db("techtrims");
    const users = db.collection("users");

    const user = await users.findOne({ email: normalizedEmail });

    // ✅ SECURITY: Always return same message regardless of user existence
    if (!user) {
      // Simulate processing delay to prevent email enumeration
      await new Promise((resolve) =>
        setTimeout(resolve, Math.random() * 1000 + 500)
      );
      return res.status(200).json({
        message:
          "If an account exists with this email, a reset link has been sent.",
      });
    }

    // ✅ JWT TOKEN: Stateless, includes password hash validation
    const resetToken = generateResetToken(
      user._id,
      user.email,
      user.hashedPassword
    );

    const resetLink = `${
      process.env.NEXT_PUBLIC_BASE_URL || "http://localhost:3000"
    }/auth/reset-password?token=${resetToken}`;

    // ✅ NODEMAILER SETUP with Gmail
    const transporter = nodemailer.createTransport({
      service: "gmail",
      auth: {
        user: process.env.GMAIL_USER,
        pass: process.env.GMAIL_APP_PASSWORD,
      },
      // ADD THESE OPTIONS
      tls: {
        rejectUnauthorized: false,
      },
    });

    // ✅ SEND EMAIL
    // In forgot-password.js - Update the email HTML
    const mailOptions = {
      from: `"TechTrims Support" <${process.env.GMAIL_USER}>`,
      to: normalizedEmail,
      subject: "Password Reset - TechTrims",
      // ADD THESE HEADERS
      headers: {
        "X-Priority": "1",
        "X-MSMail-Priority": "High",
        Importance: "high",
        "X-Mailer": "TechTrims Mailer",
        "Reply-To": process.env.GMAIL_USER,
      }, // Simpler subject (no emojis)
      html: `
    <!DOCTYPE html>
    <html>
    <head>
      <meta charset="UTF-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
    </head>
    <body style="font-family: Arial, sans-serif; line-height: 1.6; color: #333; margin: 0; padding: 0;">
      <div style="max-width: 600px; margin: 20px auto; background: white; border: 1px solid #ddd;">
        <!-- Header -->
        <div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); padding: 30px; text-align: center;">
          <h1 style="color: white; margin: 0; font-size: 24px;">TechTrims</h1>
        </div>
        
        <!-- Content -->
        <div style="padding: 30px;">
          <p style="font-size: 16px;">Hello ${user.name},</p>
          
          <p style="font-size: 16px;">You requested to reset your password for your TechTrims account.</p>
          
          <p style="text-align: center; margin: 30px 0;">
            <a href="${resetLink}" 
               style="display: inline-block; 
                      padding: 14px 32px; 
                      background: #667eea; 
                      color: white; 
                      text-decoration: none; 
                      border-radius: 6px; 
                      font-size: 16px;
                      font-weight: 600;">
              Reset Password
            </a>
          </p>
          
          <p style="font-size: 14px; color: #666;">
            If the button doesn't work, copy and paste this link into your browser:
          </p>
          
          <p style="font-size: 13px; 
                    color: #667eea; 
                    word-break: break-all; 
                    background: #f5f5f5; 
                    padding: 12px; 
                    border-radius: 4px; 
                    border: 1px solid #e0e0e0;">
            ${resetLink}
          </p>
          
          <div style="background: #fff3cd; 
                      border-left: 4px solid #ffc107; 
                      padding: 12px; 
                      margin: 20px 0; 
                      border-radius: 4px;">
            <p style="margin: 0; font-size: 14px; color: #856404;">
              <strong>Important:</strong> This link expires in 1 hour and can only be used once.
            </p>
          </div>
          
          <p style="font-size: 14px; color: #666; margin-top: 25px;">
            If you did not request this password reset, please ignore this email. 
            Your password will not be changed.
          </p>
          
          <p style="font-size: 14px; color: #666; margin-top: 20px;">
            Best regards,<br>
            <strong>TechTrims Team</strong>
          </p>
        </div>
        
        <!-- Footer -->
        <div style="background: #f5f5f5; 
                    padding: 20px; 
                    text-align: center; 
                    border-top: 1px solid #ddd;">
          <p style="margin: 0; font-size: 12px; color: #999;">
            &copy; ${new Date().getFullYear()} TechTrims. All rights reserved.
          </p>
          <p style="margin: 5px 0 0 0; font-size: 12px; color: #999;">
            This is an automated message, please do not reply to this email.
          </p>
        </div>
      </div>
    </body>
    </html>
  `,
      // ADD PLAIN TEXT VERSION (helps with spam filters)
      text: `
Hello ${user.name},

You requested to reset your password for your TechTrims account.

Click here to reset your password:
${resetLink}

This link expires in 1 hour and can only be used once.

If you did not request this password reset, please ignore this email.

Best regards,
TechTrims Team
  `,
    };

    await transporter.sendMail(mailOptions);

    console.log("✅ Password reset email sent:", {
      email: normalizedEmail,
      remaining: rateCheck.remaining,
    });

    return res.status(200).json({
      message:
        "If an account exists with this email, a reset link has been sent.",
      rateLimitRemaining: rateCheck.remaining,
    });
  } catch (error) {
    console.error("❌ Forgot password error:", error);
    // ✅ NEVER expose internal errors or password hashes
    return res.status(500).json({
      message: "An error occurred. Please try again later.",
    });
  }
}
</file>

<file path="src/pages/api/auth/user/login.js">
import clientPromise from "../../../../lib/mongodb";
import bcrypt from "bcryptjs";
import jwt from "jsonwebtoken";

export default async function handler(req, res) {
  if (req.method !== "POST") {
    return res.status(405).json({ message: "Method not allowed" });
  }

  try {
    const { email, password } = req.body;

    if (!email || !password) {
      return res
        .status(400)
        .json({ message: "Email and password are required" });
    }

    const client = await clientPromise;
    const db = client.db("techtrims");

    // Find user by email
    const user = await db.collection("users").findOne({
      email: email.toLowerCase(),
      role: "user",
    });

    if (!user) {
      return res.status(401).json({ message: "Invalid email or password" });
    }

    // Check if account is active
    if (!user.isActive) {
      return res.status(401).json({ message: "Account is deactivated" });
    }

    // Verify password
    const isValidPassword = await bcrypt.compare(password, user.hashedPassword);
    if (!isValidPassword) {
      return res.status(401).json({ message: "Invalid email or password" });
    }

    // Update last login
    await db.collection("users").updateOne(
      { _id: user._id },
      {
        $set: {
          lastLogin: new Date(),
          updatedAt: new Date(),
        },
      }
    );

    // Create JWT token
    const token = jwt.sign(
      {
        userId: user._id,
        email: user.email,
        role: user.role,
        name: user.name,
      },
      process.env.JWT_SECRET,
      { expiresIn: "7d" }
    );

    // Return user data without sensitive info
    const userResponse = {
      _id: user._id,
      name: user.name,
      email: user.email,
      phone: user.phone,
      gender: user.gender,
      role: user.role,
      bookingHistory: user.bookingHistory || [],
      preferences: user.preferences || {},
      createdAt: user.createdAt,
      lastLogin: new Date(),
    };

    res.status(200).json({
      message: "Login successful",
      token,
      user: userResponse,
    });
  } catch (error) {
    console.error("User login error:", error);
    res.status(500).json({ message: "Internal server error" });
  }
}
</file>

<file path="src/pages/api/bookings/[id].js">
import clientPromise from "../../../lib/mongodb";
import { ObjectId } from "mongodb";

export default async function handler(req, res) {
  if (req.method !== "GET") {
    return res.status(405).json({ message: "Method not allowed" });
  }

  try {
    const { id } = req.query;

    if (!id || !ObjectId.isValid(id)) {
      return res.status(400).json({ message: "Invalid booking ID" });
    }

    const client = await clientPromise;
    const db = client.db("techtrims");

    const booking = await db.collection("bookings").findOne({
      _id: new ObjectId(id),
    });

    if (!booking) {
      return res.status(404).json({ message: "Booking not found" });
    }

    // Get salon name
    if (booking.salonId) {
      const salon = await db.collection("salons").findOne({
        _id: new ObjectId(booking.salonId),
      });
      booking.salonName = salon?.salonName || "Unknown Salon";
    }

    // Convert ObjectId to string
    booking._id = booking._id.toString();
    if (booking.salonId) booking.salonId = booking.salonId.toString();
    if (booking.barberId) booking.barberId = booking.barberId.toString();

    res.status(200).json({ booking });
  } catch (error) {
    console.error("Get booking error:", error);
    res.status(500).json({ message: "Server error", error: error.message });
  }
}
</file>

<file path="src/pages/api/bookings/update.js">
// pages/api/bookings/update.js
import { connectToDatabase } from "../../../lib/mongodb";
import { ObjectId } from "mongodb";

export default async function handler(req, res) {
  if (req.method !== "PUT") {
    return res.status(405).json({ error: "Method not allowed" });
  }

  try {
    const { bookingId, status, feedback } = req.body;

    if (!ObjectId.isValid(bookingId)) {
      return res.status(400).json({ error: "Invalid booking ID" });
    }

    const { db } = await connectToDatabase();

    const updateData = { updatedAt: new Date() };

    if (status) {
      updateData.status = status;
    }

    if (feedback) {
      updateData.feedback = {
        submitted: true,
        ...feedback,
        submittedAt: new Date(),
      };
    }

    const result = await db
      .collection("bookings")
      .updateOne({ _id: new ObjectId(bookingId) }, { $set: updateData });

    if (result.matchedCount === 0) {
      return res.status(404).json({ error: "Booking not found" });
    }

    // If feedback is submitted, update salon ratings
    if (feedback && feedback.ratings) {
      const booking = await db.collection("bookings").findOne({
        _id: new ObjectId(bookingId),
      });

      if (booking) {
        await updateSalonRatings(db, booking.salonId, feedback.ratings);
      }
    }
    if (feedback?.submitted) {
      updateData.feedback = {
        submitted: true,
        ...feedback,
        submittedAt: new Date(),
      };
    }

    const updatedBooking = await db.collection("bookings").findOne({
      _id: new ObjectId(bookingId),
    });

    // ✅ UPDATE SALON RATINGS IN REAL-TIME
    if (feedback?.submitted && updatedBooking?.salonId) {
      await updateSalonRatings(updatedBooking.salonId);

      // ✅ UPDATE BARBER STATS IF BARBER WAS RATED
      if (feedback.ratings?.barberPerformance && updatedBooking.barber) {
        const barber = await db.collection("barbers").findOne({
          name: updatedBooking.barber,
        });
        if (barber) {
          await updateBarberStats(
            barber._id,
            barber.name,
            updatedBooking.salonId
          );
        }
      }
    }
    res.status(200).json({
      success: true,
      message: "Booking updated successfully",
    });
  } catch (error) {
    console.error("Booking update error:", error);
    res.status(500).json({ error: "Internal server error" });
  }
}

// Helper function to update salon ratings
async function updateSalonRatings(db, salonId, newRatings) {
  try {
    // Get all feedback for this salon
    const allFeedback = await db
      .collection("bookings")
      .find({
        salonId,
        "feedback.submitted": true,
      })
      .toArray();

    if (allFeedback.length === 0) return;

    // Calculate average ratings
    const totalRatings = allFeedback.reduce((acc, booking) => {
      const ratings = booking.feedback.ratings;
      Object.keys(ratings).forEach((key) => {
        acc[key] = (acc[key] || 0) + ratings[key];
      });
      return acc;
    }, {});

    const avgRatings = {};
    Object.keys(totalRatings).forEach((key) => {
      avgRatings[key] = parseFloat(
        (totalRatings[key] / allFeedback.length).toFixed(1)
      );
    });

    // Update salon ratings
    await db.collection("salons").updateOne(
      { _id: new ObjectId(salonId) },
      {
        $set: {
          "ratings.overall": avgRatings.overall || 5.0,
          "ratings.serviceQuality": avgRatings.serviceQuality || 5.0,
          "ratings.timing": avgRatings.timing || 5.0,
          "ratings.cleanliness": avgRatings.cleanliness || 5.0,
          "ratings.ambience": avgRatings.ambience || 5.0,
          "ratings.totalReviews": allFeedback.length,
          updatedAt: new Date(),
        },
      }
    );
  } catch (error) {
    console.error("Error updating salon ratings:", error);
  }
}
</file>

<file path="src/pages/api/maps/reverse.js">
export default async function handler(req, res) {
  if (req.method !== "POST") {
    return res.status(405).json({ error: "Method not allowed" });
  }

  const { lat, lng } = req.body ?? {};

  if (lat === undefined || lng === undefined) {
    return res.status(400).json({ error: "lat and lng are required" });
  }

  try {
    const url = `https://nominatim.openstreetmap.org/reverse?format=json&lat=${encodeURIComponent(
      lat
    )}&lon=${encodeURIComponent(lng)}&addressdetails=1`;

    const response = await fetch(url, {
      headers: {
        "User-Agent": "TechTrims/1.0 (techtrims1@gmail.com)",
        "Accept-Language": "en-US,en;q=0.9",
      },
    });

    if (!response.ok) {
      const body = await response.text().catch(() => "");
      console.error("Nominatim returned non-OK:", response.status, body);
      return res
        .status(response.status)
        .json({ error: "Reverse geocoding provider error" });
    }

    const data = await response.json();
    const displayName = data.display_name || null;

    return res.status(200).json({
      address: displayName,
      raw: data,
    });
  } catch (err) {
    console.error("Reverse geocoding error:", err);
    return res.status(500).json({ error: "Internal server error" });
  }
}
</file>

<file path="src/pages/api/salons/bookings/[id].js">
// src/pages/api/salons/bookings/[id].js - Only handle specific booking IDs
import connectToDatabase from "../../../../lib/mongodb";
import Booking from "../../../../models/Booking";
import { ObjectId } from "mongodb";

export default async function handler(req, res) {
  await connectToDatabase();
  const { method } = req;
  const { id } = req.query;

  // Check if id is actually a valid ObjectId
  if (!ObjectId.isValid(id)) {
    return res.status(400).json({ error: "Invalid booking ID format" });
  }

  try {
    if (method === "GET") {
      const booking = await Booking.findById(id);
      if (!booking) {
        return res.status(404).json({ error: "Booking not found" });
      }
      return res.status(200).json(booking);
    }

    if (method === "PUT") {
      const update = req.body;
      const booking = await Booking.findByIdAndUpdate(id, update, {
        new: true,
      });
      if (!booking) {
        return res.status(404).json({ error: "Booking not found" });
      }
      return res.status(200).json(booking);
    }

    if (method === "DELETE") {
      await Booking.findByIdAndDelete(id);
      return res.status(204).end();
    }

    return res
      .setHeader("Allow", ["GET", "PUT", "DELETE"])
      .status(405)
      .end(`Method ${method} Not Allowed`);
  } catch (err) {
    console.error("api/bookings/[id] error:", err);
    return res.status(500).json({ error: "Internal server error" });
  }
}
</file>

<file path="src/pages/api/user/bookings.js">
import clientPromise from "../../../lib/mongodb";
import { verifyToken } from "../../../lib/auth";
import { ObjectId } from "mongodb";

export default async function handler(req, res) {
  if (req.method !== "GET") {
    return res.status(405).json({ message: "Method not allowed" });
  }

  try {
    const token = req.headers.authorization?.replace("Bearer ", "");
    console.log("User bookings API - Token received:", token ? "YES" : "NO");

    if (!token) {
      return res.status(401).json({ message: "No token provided" });
    }

    const decoded = verifyToken(token);
    console.log("User bookings API - Decoded token:", decoded);

    if (!decoded || !decoded.userId) {
      return res.status(401).json({ message: "Invalid token" });
    }

    const client = await clientPromise;
    const db = client.db("techtrims");

    const user = await db
      .collection("users")
      .findOne({ _id: new ObjectId(decoded.userId) });
    console.log("User bookings API - Found user:", user ? "YES" : "NO");
    console.log("User phone:", user?.phone);
    console.log("User name:", user?.name);

    if (!user) {
      return res.status(404).json({ message: "User not found" });
    }

    // Debug: Check all bookings first
    const allBookings = await db.collection("bookings").find({}).toArray();
    console.log("Total bookings in database:", allBookings.length);
    console.log("Sample booking:", allBookings[0]);

    // Try multiple search strategies
    const searchQueries = [
      { userId: new ObjectId(decoded.userId) },
      { customerPhone: user.phone },
      { customerName: user.name },
    ];

    console.log("Search queries:", searchQueries);

    // Get bookings by phone number or userId
    const bookings = await db
      .collection("bookings")
      .find({
        $or: searchQueries,
      })
      .sort({ createdAt: -1 })
      .toArray();

    console.log("Found bookings for user:", bookings.length);
    console.log("Bookings:", bookings);

    // Get salon names for bookings
    // If no bookings found, try fallback searches
    let finalBookings = bookings;

    if (bookings.length === 0) {
      console.log(
        "No bookings found with standard search, trying fallback searches..."
      );

      // Try searching by partial phone match
      const phoneSearch = await db
        .collection("bookings")
        .find({ customerPhone: { $regex: user.phone.slice(-10) } })
        .toArray();
      console.log("Phone fallback search found:", phoneSearch.length);

      // Try searching by partial name match
      const nameSearch = await db
        .collection("bookings")
        .find({ customerName: { $regex: user.name, $options: "i" } })
        .toArray();
      console.log("Name fallback search found:", nameSearch.length);

      finalBookings = [...phoneSearch, ...nameSearch];

      // Remove duplicates
      finalBookings = finalBookings.filter(
        (booking, index, self) =>
          index ===
          self.findIndex((b) => b._id.toString() === booking._id.toString())
      );
    }

    // Get salon names for bookings
    // Get salon names AND barber names for bookings
    const bookingsWithSalons = await Promise.all(
      finalBookings.map(async (booking) => {
        let salonName = "Unknown Salon";
        let barberName = null;

        // Get salon name
        if (booking.salonId) {
          try {
            const salonObjectId =
              typeof booking.salonId === "string"
                ? new ObjectId(booking.salonId)
                : booking.salonId;

            const salon = await db
              .collection("salons")
              .findOne(
                { _id: salonObjectId },
                { projection: { salonName: 1, "salonDetails.name": 1 } }
              );
            salonName =
              salon?.salonName || salon?.salonDetails?.name || "Unknown Salon";
          } catch (error) {
            console.error(
              "Error fetching salon for booking:",
              booking._id,
              error
            );
          }
        }

        // ✅ Get barber name if barberId exists
        if (booking.barberId) {
          try {
            const barberObjectId =
              typeof booking.barberId === "string"
                ? new ObjectId(booking.barberId)
                : booking.barberId;

            const barber = await db
              .collection("barbers")
              .findOne({ _id: barberObjectId }, { projection: { name: 1 } });
            barberName = barber?.name || null;
          } catch (error) {
            console.error(
              "Error fetching barber for booking:",
              booking._id,
              error
            );
          }
        }

        // Use existing barber field if barberName not found
        if (!barberName && booking.barber) {
          barberName = booking.barber;
        }

        return {
          ...booking,
          _id: booking._id.toString(),
          salonName,
          barberName,
        };
      })
    );

    console.log("Final bookings with salon names:", bookingsWithSalons.length);
    res.status(200).json(bookingsWithSalons);
  } catch (error) {
    console.error("User bookings API error:", error);
    res.status(500).json({ message: "Internal server error" });
  }
}
</file>

<file path="src/pages/api/user/profile.js">
import clientPromise from "../../../lib/mongodb";
import { verifyToken } from "../../../lib/auth";
import { ObjectId } from "mongodb";

export default async function handler(req, res) {
  if (req.method !== "GET") {
    return res.status(405).json({ message: "Method not allowed" });
  }

  try {
    const token = req.headers.authorization?.replace("Bearer ", "");
    if (!token) {
      return res.status(401).json({ message: "No token provided" });
    }

    const decoded = verifyToken(token);
    if (!decoded || !decoded.userId) {
      return res.status(401).json({ message: "Invalid token" });
    }

    const client = await clientPromise;
    const db = client.db("techtrims");

    const user = await db
      .collection("users")
      .findOne(
        { _id: new ObjectId(decoded.userId) },
        { projection: { hashedPassword: 0 } }
      );

    if (!user) {
      return res.status(404).json({ message: "User not found" });
    }

    // Return complete user profile with all new fields
    const userProfile = {
      _id: user._id,
      id: user._id,
      name: user.name,
      email: user.email,
      phone: user.phone,
      phoneNumber: user.phoneNumber || user.phone,
      mobile: user.mobile || user.phone || user.phoneNumber,
      gender: user.gender,
      age: user.age || null,
      dateOfBirth: user.dateOfBirth || null,
      location: user.location || null,
      role: user.role || "user",
      bookingHistory: user.bookingHistory || [],
      preferences: user.preferences || {},
      createdAt: user.createdAt,
      updatedAt: user.updatedAt,
      isActive: user.isActive,
      // Keep backward compatibility
      isPhoneVerified: user.isPhoneVerified || true,
    };

    res.status(200).json(userProfile);
  } catch (error) {
    console.error("Profile API error:", error);
    res.status(500).json({ message: "Internal server error" });
  }
}
</file>

<file path="src/pages/auth/salon/login.js">
import { useState } from "react";
import { useRouter } from "next/router";
import styles from "../../../styles/Auth/SalonAuth.module.css";

export default function SalonLogin() {
  const router = useRouter();
  const [formData, setFormData] = useState({
    email: "",
    password: "",
  });
  const [isLoading, setIsLoading] = useState(false);

  const handleLogin = async (e) => {
    e.preventDefault();
    setIsLoading(true);

    try {
      const response = await fetch("/api/auth/salon/login", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(formData),
      });

      const data = await response.json();

      if (response.ok) {
        // Store salon session
        localStorage.setItem("salonSession", JSON.stringify(data.salon));
        localStorage.setItem("salonToken", data.token);
        router.push("/salons/dashboard");
      } else {
        alert(data.message || "Login failed");
      }
    } catch (error) {
      alert("Login error: " + error.message);
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <div className={styles.container}>
      <div className={styles.loginCard}>
        <h1>Salon Owner Login</h1>
        <form onSubmit={handleLogin}>
          <input
            type="email"
            placeholder="Email"
            value={formData.email}
            onChange={(e) =>
              setFormData({ ...formData, email: e.target.value })
            }
            required
          />
          <input
            type="password"
            placeholder="Password"
            value={formData.password}
            onChange={(e) =>
              setFormData({ ...formData, password: e.target.value })
            }
            required
          />
          <button type="submit" disabled={isLoading}>
            {isLoading ? "Logging in..." : "Login"}
          </button>
        </form>
        <p>
          Don&#39;t have an account?
          <a onClick={() => router.push("/auth/salon/register")}>
            {" "}
            Register here
          </a>
        </p>
      </div>
    </div>
  );
}
</file>

<file path="src/pages/auth/salon/register.js">
import SalonRegisterForm from "../../../components/Salon/SalonRegisterForm";

export default function SalonRegisterPage() {
  return <SalonRegisterForm />;
}
</file>

<file path="src/pages/salons/barbers/index.js">
// pages/salons/barbers/index.js
import { useEffect, useState } from "react";
import { useRouter } from "next/router";
import axios from "axios";
import Link from "next/link";

export default function SalonBarbersPage() {
  const router = useRouter();
  const [barbers, setBarbers] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState("");
  const [showForm, setShowForm] = useState(false);
  const [salonId, setSalonId] = useState(null);
  const [newBarber, setNewBarber] = useState({
    name: "",
    experience: 0,
    skills: [],
    bio: "",
    photo: "",
  });

  const availableSkills = [
    "Haircut",
    "Shaving",
    "Hair Styling",
    "Beard Trim",
    "Hair Color",
    "Facial",
  ];

  // Get salonId from localStorage (salon session)
  useEffect(() => {
    if (typeof window !== "undefined") {
      console.log("Checking localStorage for salon session...");

      // Check all possible keys
      const salonSession = localStorage.getItem("salonSession");
      const salonToken = localStorage.getItem("salonToken");

      console.log("Raw salonSession:", salonSession);
      console.log("Raw salonToken:", salonToken);

      if (salonSession) {
        try {
          const salonData = JSON.parse(salonSession);
          console.log("Parsed salon data:", salonData);

          // Try multiple possible id fields
          const id = salonData.id || salonData._id || salonData.salonId;

          if (id) {
            setSalonId(id);
            console.log("Salon ID loaded from session:", id);
          } else {
            console.error("No ID found in salon session data");
            setError("Invalid salon session data");
          }
        } catch (err) {
          console.error("Failed to parse salon session:", err);
          setError("Failed to parse salon session");
        }
      } else {
        console.error("No salon session found in localStorage");
        setError("No salon session found. Please login first.");
        setTimeout(() => {
          router.push("/auth/salon/login");
        }, 2000);
      }
    }
  }, [router]);

  useEffect(() => {
    if (!salonId) {
      console.log("No salonId yet, waiting...");
      return;
    }

    console.log("Fetching barbers for salon:", salonId);
    const fetchBarbers = async () => {
      setLoading(true);
      try {
        // Use the correct API endpoint
        const res = await axios.get(`/api/salons/barbers?salonId=${salonId}`);
        console.log("Barbers API response:", res.data);
        setBarbers(res.data);
        setError("");
      } catch (err) {
        console.error("Fetch barbers error:", err);
        console.error("Error response:", err.response?.data);
        setError(
          `Failed to fetch barbers: ${err.response?.data?.error || err.message}`
        );
      }
      setLoading(false);
    };

    fetchBarbers();
  }, [salonId]);

  // Rest of your component remains the same...
  const handleCreate = async () => {
    if (!newBarber.name) return alert("Name is required");
    if (!salonId) return alert("No salon session found");

    try {
      console.log("Creating barber:", { ...newBarber, salonId });
      const res = await axios.post("/api/salons/barbers", {
        ...newBarber,
        salonId,
      });
      console.log("Create response:", res.data);
      setBarbers([...barbers, res.data]);
      setNewBarber({ name: "", experience: 0, skills: [], bio: "", photo: "" });
      setShowForm(false);
      setError("");
    } catch (err) {
      console.error("Create barber error:", err);
      setError(
        `Failed to create barber: ${err.response?.data?.error || err.message}`
      );
    }
  };

  const handleSkillToggle = (skill) => {
    setNewBarber((prev) => ({
      ...prev,
      skills: prev.skills.includes(skill)
        ? prev.skills.filter((s) => s !== skill)
        : [...prev.skills, skill],
    }));
  };

  const toggleAvailability = async (barberId, currentStatus) => {
    try {
      await axios.put(`/api/salons/barbers/${barberId}`, {
        isAvailable: !currentStatus,
      });
      setBarbers(
        barbers.map((b) =>
          b._id === barberId ? { ...b, isAvailable: !currentStatus } : b
        )
      );
    } catch (err) {
      console.error("Toggle availability error:", err);
      setError("Failed to update barber status");
    }
  };

  // Show debug info while loading
  if (loading || !salonId) {
    return (
      <div className="max-w-6xl mx-auto p-6">
        <div className="mb-4 p-4 bg-blue-50 border border-blue-200 rounded">
          <h3 className="font-semibold text-blue-800 mb-2">
            Loading Barbers...
          </h3>
          <div className="text-sm space-y-1">
            <p>
              <strong>Salon ID:</strong> {salonId || "Loading..."}
            </p>
            <p>
              <strong>Loading:</strong> {loading.toString()}
            </p>
            <p>
              <strong>Error:</strong> {error || "None"}
            </p>
            <p>
              <strong>LocalStorage Keys:</strong>{" "}
              {typeof window !== "undefined"
                ? Object.keys(localStorage).join(", ")
                : "Not available"}
            </p>
            {typeof window !== "undefined" &&
              localStorage.getItem("salonSession") && (
                <p>
                  <strong>Session Data:</strong>{" "}
                  {localStorage.getItem("salonSession")}
                </p>
              )}
          </div>
        </div>
        {error && error.includes("No salon session") && (
          <div className="text-center py-8">
            <p className="text-red-600 mb-4">{error}</p>
            <button
              onClick={() => router.push("/auth/salon/login")}
              className="bg-blue-600 text-white px-6 py-2 rounded hover:bg-blue-700"
            >
              Go to Login
            </button>
          </div>
        )}
      </div>
    );
  }

  return (
    <div className="max-w-6xl mx-auto p-6">
      <div className="flex justify-between items-center mb-6">
        <h1 className="text-3xl font-bold">Barber Management</h1>
        <button
          onClick={() => setShowForm(!showForm)}
          className="bg-amber-600 text-white px-4 py-2 rounded hover:bg-amber-700"
        >
          {showForm ? "Cancel" : "Add New Barber"}
        </button>
      </div>

      {error && <p className="text-red-500 mb-4">{error}</p>}

      {/* Add Barber Form */}
      {showForm && (
        <div className="mb-8 p-6 border rounded-lg shadow bg-gray-50">
          <h2 className="text-xl font-semibold mb-4">Add New Barber</h2>

          <div className="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
            <input
              type="text"
              placeholder="Barber Name"
              value={newBarber.name}
              onChange={(e) =>
                setNewBarber({ ...newBarber, name: e.target.value })
              }
              className="border rounded px-3 py-2 w-full"
            />
            <input
              type="number"
              placeholder="Years of Experience"
              value={newBarber.experience}
              onChange={(e) =>
                setNewBarber({
                  ...newBarber,
                  experience: parseInt(e.target.value) || 0,
                })
              }
              className="border rounded px-3 py-2 w-full"
            />
          </div>

          <div className="mb-4">
            <label className="block font-medium mb-2">
              Skills & Specializations
            </label>
            <div className="grid grid-cols-2 md:grid-cols-3 gap-2">
              {availableSkills.map((skill) => (
                <label key={skill} className="flex items-center">
                  <input
                    type="checkbox"
                    checked={newBarber.skills.includes(skill)}
                    onChange={() => handleSkillToggle(skill)}
                    className="mr-2"
                  />
                  {skill}
                </label>
              ))}
            </div>
          </div>

          <div className="mb-4">
            <label className="block font-medium mb-2">
              Bio/Accomplishments
            </label>
            <textarea
              placeholder="Describe achievements, awards, specialties..."
              value={newBarber.bio}
              onChange={(e) =>
                setNewBarber({ ...newBarber, bio: e.target.value })
              }
              rows={3}
              className="w-full border rounded px-3 py-2"
            />
          </div>

          <button
            onClick={handleCreate}
            className="bg-green-600 text-white px-4 py-2 rounded hover:bg-green-700"
          >
            Add Barber
          </button>
        </div>
      )}

      {/* Barbers List */}
      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
        {barbers.map((barber) => (
          <div
            key={barber._id}
            className="bg-white border rounded-lg shadow-md p-6"
          >
            <div className="flex justify-between items-start mb-4">
              <div>
                <h3 className="text-lg font-semibold">{barber.name}</h3>
                <p className="text-gray-600">
                  {barber.experience} years experience
                </p>
                <div className="flex items-center mt-1">
                  <span className="text-yellow-500">⭐</span>
                  <span className="ml-1">{barber.rating}/5</span>
                  <span className="text-gray-500 ml-2">
                    ({barber.totalBookings} bookings)
                  </span>
                </div>
              </div>

              <button
                onClick={() =>
                  toggleAvailability(barber._id, barber.isAvailable)
                }
                className={`px-3 py-1 rounded text-sm ${
                  barber.isAvailable
                    ? "bg-green-100 text-green-800"
                    : "bg-red-100 text-red-800"
                }`}
              >
                {barber.isAvailable ? "Available" : "Unavailable"}
              </button>
            </div>

            {/* Skills */}
            <div className="mb-3">
              <p className="font-medium text-sm mb-2">Specializations:</p>
              <div className="flex flex-wrap gap-1">
                {barber.skills.map((skill) => (
                  <span
                    key={skill}
                    className="bg-amber-100 text-amber-800 px-2 py-1 rounded text-xs"
                  >
                    {skill}
                  </span>
                ))}
              </div>
            </div>

            {/* Bio */}
            {barber.bio && (
              <div className="mb-3">
                <p className="text-gray-700 text-sm">{barber.bio}</p>
              </div>
            )}

            <div className="flex gap-2 mt-4">
              <Link href={`/salons/barbers/${barber._id}`} className="flex-1">
                <button className="w-full bg-blue-600 text-white py-2 rounded text-sm hover:bg-blue-700">
                  Edit Details
                </button>
              </Link>
            </div>
          </div>
        ))}
      </div>

      {barbers.length === 0 && !loading && (
        <div className="text-center py-12">
          <p className="text-gray-500 mb-4">No barbers found for this salon.</p>
          <button
            onClick={() => setShowForm(true)}
            className="bg-amber-600 text-white px-6 py-3 rounded hover:bg-amber-700"
          >
            Add Your First Barber
          </button>
        </div>
      )}

      {/* Debug Info */}
      <div className="mt-8 p-4 bg-gray-100 rounded">
        <h3 className="font-semibold mb-2">Debug Info:</h3>
        <p>Salon ID: {salonId || "Not loaded"}</p>
        <p>Barbers Count: {barbers.length}</p>
        <p>Loading: {loading.toString()}</p>
        <p>Error: {error || "None"}</p>
      </div>
    </div>
  );
}
</file>

<file path="src/styles/Auth/UserAuth.module.css">
.container {
  min-height: 100vh;
  display: flex;
  align-items: center;
  justify-content: center;
  background: linear-gradient(135deg, var(--gray-50) 0%, var(--gold-50) 100%);
  padding: var(--space-6);
  position: relative;
  overflow: hidden;
}

.container::before {
  content: "";
  position: absolute;
  top: -50%;
  left: -50%;
  width: 100%;
  height: 100%;

  animation: float 25s ease-in-out infinite reverse;
}

.authCard {
  background: var(--background-primary);
  border-radius: var(--radius-3xl);
  padding: var(--space-12);
  max-width: 520px;
  width: 100%;
  box-shadow: var(--shadow-luxury);
  border: 1px solid var(--border-color);
  position: relative;
  z-index: 1;
  animation: scaleIn 0.5s ease-out;
}

.authCard::before {
  content: "";
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  height: 4px;
  background: linear-gradient(
    90deg,
    var(--primary),
    var(--gold-600),
    var(--primary)
  );
  background-size: 200% 100%;
  animation: shimmer 3s linear infinite;
  border-radius: var(--radius-3xl) var(--radius-3xl) 0 0;
}

.header {
  margin-bottom: var(--space-6);
}

.backButton {
  display: inline-flex;
  align-items: center;
  gap: var(--space-2);
  padding: var(--space-2) var(--space-4);
  background: transparent;
  border: 1px solid var(--border-color);
  border-radius: var(--radius-lg);
  color: var(--text-secondary);
  font-size: 0.875rem;
  font-weight: 500;
  cursor: pointer;
  transition: all var(--transition-normal);
}

.backButton:hover {
  background: var(--background-secondary);
  border-color: var(--primary);
  color: var(--primary);
  transform: translateX(-4px);
}

.title {
  font-family: var(--font-display);
  font-size: 2rem;
  font-weight: 700;
  text-align: center;
  margin: var(--space-6) 0 var(--space-2);
  background: linear-gradient(
    135deg,
    var(--primary) 0%,
    var(--primary-dark) 100%
  );
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
}

.subtitle {
  text-align: center;
  color: var(--text-secondary);
  font-size: 0.7rem;
  margin-bottom: var(--space-8);
}

.error {
  background: linear-gradient(
    135deg,
    rgba(239, 68, 68, 0.1),
    rgba(239, 68, 68, 0.05)
  );
  border: 1px solid rgba(239, 68, 68, 0.3);
  border-radius: var(--radius-lg);
  padding: var(--space-4);
  margin-bottom: var(--space-6);
  animation: fadeInDown 0.3s ease-out;
}

.error span {
  color: var(--error);
  font-size: 0.9375rem;
  font-weight: 500;
  display: flex;
  align-items: center;
  gap: var(--space-2);
}

.form {
  margin-top: var(--space-6);
}

.formGroup {
  margin-bottom: var(--space-5);
}

.formGroup label {
  display: block;
  margin-bottom: var(--space-2);
  color: var(--text-primary);
  font-weight: 500;
  font-size: 0.9375rem;
}

.formGroup input,
.formGroup select {
  width: 100%;
  padding: var(--space-2) var(--space-3);
  border: 2px solid var(--border-color);
  border-radius: var(--radius-lg);
  font-size: 1rem;
  font-family: var(--font-body);
  background: var(--background-primary);
  color: var(--text-primary);
  transition: all var(--transition-normal);
}

.formGroup input:focus,
.formGroup select:focus {
  outline: none;
  border-color: var(--primary);
  box-shadow: 0 0 0 4px rgba(212, 175, 55, 0.1);
  transform: translateY(-2px);
}

.formGroup input::placeholder {
  color: var(--text-tertiary);
}

.formGroup select {
  cursor: pointer;
  appearance: none;
  background-image: url("data:image/svg+xml,%3Csvg width='12' height='8' viewBox='0 0 12 8' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M1 1L6 6L11 1' stroke='%23737373' stroke-width='2' stroke-linecap='round'/%3E%3C/svg%3E");
  background-repeat: no-repeat;
  background-position: right var(--space-4) center;
  padding-right: var(--space-12);
}

.submitButton {
  width: 100%;
  padding: var(--space-3) var(--space-4);
  background: linear-gradient(
    135deg,
    var(--primary) 0%,
    var(--primary-dark) 100%
  );
  color: var(--black);
  border: none;
  border-radius: var(--radius-lg);
  font-size: 1rem;
  font-weight: 600;
  font-family: var(--font-body);
  cursor: pointer;
  transition: all var(--transition-luxury);
  box-shadow: var(--shadow-md), 0 0 20px rgba(212, 175, 55, 0.3);
  display: flex;
  align-items: center;
  justify-content: center;
  gap: var(--space-2);
  margin-top: var(--space-6);
}

.submitButton:hover:not(:disabled) {
  transform: translateY(-2px) scale(1.02);
  box-shadow: var(--shadow-xl), 0 0 30px rgba(212, 175, 55, 0.5);
}

.submitButton:disabled {
  opacity: 0.6;
  cursor: not-allowed;
}

.spinner {
  width: 16px;
  height: 16px;
  border: 2px solid rgba(0, 0, 0, 0.3);
  border-top-color: var(--black);
  border-radius: 50%;
  animation: spin 0.8s linear infinite;
}

.authLinks {
  margin-top: var(--space-8);
  text-align: center;
}

.authLink {
  color: var(--text-secondary);
  font-size: 0.9375rem;
  margin: var(--space-4) 0;
}

.linkButton {
  background: none;
  border: none;
  color: var(--primary);
  font-weight: 600;
  font-size: 0.9375rem;
  cursor: pointer;
  padding: 0;
  text-decoration: none;
  transition: all var(--transition-fast);
  display: inline;
}

.linkButton:hover {
  color: var(--primary-dark);
  text-decoration: underline;
}

.divider {
  position: relative;
  text-align: center;
  margin: var(--space-2) 0;
}

.divider::before,
.divider::after {
  content: "";
  position: absolute;
  top: 50%;
  width: 42%;
  height: 1px;
  background: var(--border-color);
}

.divider::before {
  left: 0;
}

.divider::after {
  right: 0;
}

.divider span {
  background: var(--background-primary);
  padding: 0 var(--space-3);
  color: var(--text-tertiary);
  font-size: 0.875rem;
}

.demoInfo {
  margin-top: var(--space-8);
  padding: var(--space-6);
  background: linear-gradient(
    135deg,
    rgba(212, 175, 55, 0.05),
    rgba(212, 175, 55, 0.1)
  );
  border: 1px solid rgba(212, 175, 55, 0.2);
  border-radius: var(--radius-xl);
}

.demoInfo h4 {
  font-family: var(--font-body);
  font-size: 0.875rem;
  font-weight: 600;
  color: var(--text-primary);
  margin-bottom: var(--space-2);
  text-transform: uppercase;
  letter-spacing: 0.05em;
}

.demoInfo p {
  color: var(--text-secondary);
  font-size: 0.875rem;
  margin: var(--space-1) 0;
  font-family: monospace;
}

.prefillInfo {
  background: linear-gradient(
    135deg,
    rgba(212, 175, 55, 0.1),
    rgba(212, 175, 55, 0.05)
  );
  border: 1px solid rgba(212, 175, 55, 0.3);
  border-radius: var(--radius-xl);
  padding: var(--space-5);
  margin-bottom: var(--space-6);
  animation: fadeInDown 0.4s ease-out;
}

.prefillInfo h3 {
  font-family: var(--font-body);
  font-size: 1rem;
  font-weight: 600;
  color: var(--primary);
  margin-bottom: var(--space-1);
}

.prefillInfo p {
  color: var(--text-secondary);
  font-size: 0.875rem;
  margin: 0;
}

/* Dark mode */
[data-theme="dark"] .container {
  background: linear-gradient(135deg, var(--gray-900) 0%, var(--gray-800) 100%);
}

[data-theme="dark"] .authCard {
  background: var(--gray-800);
  border-color: var(--gray-700);
}

[data-theme="dark"] .divider span {
  background: var(--gray-800);
}

@media (max-width: 640px) {
  .authCard {
    padding: var(--space-8);
  }

  .title {
    font-size: 2rem;
  }

  .subtitle {
    font-size: 0.9375rem;
  }
}
</file>

<file path="src/styles/Feedback.module.css">
/* Feedback Page Styles */

.pageContainer {
  min-height: 100vh;
  background: var(--background-primary);
  display: flex;
  align-items: center;
  justify-content: center;
  padding: var(--space-8);
  position: relative;
  overflow: hidden;
}

.pageContainer::before {
  content: "";
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: radial-gradient(
    circle at 20% 20%,
    rgba(212, 175, 55, 0.08) 0%,
    transparent 50%
  );
  pointer-events: none;
}

.content {
  width: 100%;
  max-width: 800px;
  position: relative;
  z-index: 1;
  animation: fadeInUp 0.6s ease-out;
}

/* Card Container */
.card {
  background: var(--background-secondary);
  border: 1px solid var(--border-color);
  border-radius: var(--radius-2xl);
  padding: var(--space-12);
  box-shadow: var(--shadow-luxury);
  transition: all var(--transition-luxury);
  position: relative;
  overflow: hidden;
}

.card::before {
  content: "";
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 3px;
  background: linear-gradient(
    90deg,
    transparent,
    var(--primary),
    var(--primary-dark),
    transparent
  );
}

/* Header Section */
.header {
  text-align: center;
  margin-bottom: var(--space-10);
  padding-bottom: var(--space-6);
  border-bottom: 2px solid var(--border-color);
}

.title {
  font-family: var(--font-display);
  font-size: 2.5rem;
  font-weight: 700;
  color: var(--text-primary);
  margin-bottom: var(--space-3);
  background: linear-gradient(135deg, var(--primary), var(--primary-dark));
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
}

.subtitle {
  font-size: 1.125rem;
  color: var(--text-secondary);
  font-weight: 400;
}

/* Booking Summary */
.bookingSummary {
  background: var(--background-primary);
  border: 1px solid var(--border-color);
  border-radius: var(--radius-xl);
  padding: var(--space-8);
  margin-bottom: var(--space-10);
  transition: all var(--transition-normal);
}

.bookingSummary:hover {
  border-color: var(--primary);
  box-shadow: 0 4px 12px rgba(212, 175, 55, 0.15);
}

.summaryTitle {
  font-family: var(--font-display);
  font-size: 1.5rem;
  font-weight: 700;
  color: var(--text-primary);
  margin-bottom: var(--space-5);
  display: flex;
  align-items: center;
  gap: var(--space-2);
}

.summaryTitle::before {
  content: "📋";
  font-size: 1.5rem;
}

.summaryInfo {
  color: var(--text-secondary);
  font-size: 1rem;
  margin-bottom: var(--space-3);
  line-height: 1.6;
}

.summaryInfo:last-child {
  margin-bottom: 0;
}

.summaryInfo strong {
  color: var(--text-primary);
  font-weight: 600;
  display: inline-block;
  min-width: 120px;
}

/* Ratings Form */
.ratingsForm {
  display: flex;
  flex-direction: column;
  gap: var(--space-8);
}

/* Rating Group */
.ratingGroup {
  display: flex;
  flex-direction: column;
  gap: var(--space-3);
}

.ratingLabel {
  font-size: 1.125rem;
  font-weight: 600;
  color: var(--text-primary);
  display: flex;
  align-items: center;
  gap: var(--space-2);
}

.required {
  color: var(--error);
  font-size: 1.25rem;
}

/* Stars Container */
.starsContainer {
  display: flex;
  align-items: center;
  gap: var(--space-4);
  flex-wrap: wrap;
}

.starButton {
  background: transparent;
  border: none;
  font-size: 2.5rem;
  cursor: pointer;
  transition: all var(--transition-fast);
  padding: var(--space-1);
  line-height: 1;
  filter: grayscale(0);
}

.starButton:hover {
  transform: scale(1.2);
}

.starButton:active {
  transform: scale(1.1);
}

.starEmpty {
  color: var(--gray-300);
  opacity: 0.5;
}

.starFilled {
  color: var(--primary);
  filter: drop-shadow(0 2px 4px rgba(212, 175, 55, 0.4));
  animation: starPop 0.3s ease-out;
}

@keyframes starPop {
  0% {
    transform: scale(0.8);
  }
  50% {
    transform: scale(1.3);
  }
  100% {
    transform: scale(1);
  }
}

/* Rating Info */
.ratingInfo {
  display: flex;
  align-items: center;
  min-width: 150px;
}

.ratingPlaceholder {
  color: var(--text-tertiary);
  font-size: 0.9375rem;
  font-style: italic;
}

.ratingValue {
  color: var(--primary);
  font-size: 1rem;
  font-weight: 700;
  display: flex;
  align-items: center;
  gap: var(--space-2);
}

/* Comment Section */
.commentSection {
  margin-top: var(--space-4);
}

.commentLabel {
  display: block;
  font-size: 1.125rem;
  font-weight: 600;
  color: var(--text-primary);
  margin-bottom: var(--space-3);
}

.textarea {
  width: 100%;
  padding: var(--space-5);
  background: var(--background-primary);
  border: 2px solid var(--border-color);
  border-radius: var(--radius-lg);
  color: var(--text-primary);
  font-size: 1rem;
  font-family: var(--font-body);
  line-height: 1.6;
  resize: vertical;
  min-height: 120px;
  transition: all var(--transition-normal);
}

.textarea:focus {
  outline: none;
  border-color: var(--primary);
  box-shadow: 0 0 0 3px rgba(212, 175, 55, 0.1);
}

.textarea::placeholder {
  color: var(--text-tertiary);
}

/* Submit Section */
.submitSection {
  margin-top: var(--space-8);
  display: flex;
  justify-content: center;
}

.submitButton {
  padding: var(--space-5) var(--space-12);
  background: linear-gradient(135deg, var(--primary), var(--primary-dark));
  color: var(--black);
  border: none;
  border-radius: var(--radius-lg);
  font-size: 1.125rem;
  font-weight: 700;
  cursor: pointer;
  transition: all var(--transition-luxury);
  box-shadow: var(--shadow-lg), 0 0 20px rgba(212, 175, 55, 0.3);
  position: relative;
  overflow: hidden;
  min-width: 280px;
}

.submitButton::before {
  content: "";
  position: absolute;
  top: 0;
  left: -100%;
  width: 100%;
  height: 100%;
  background: linear-gradient(
    90deg,
    transparent,
    rgba(255, 255, 255, 0.3),
    transparent
  );
  transition: left 0.5s ease;
}

.submitButton:hover {
  transform: translateY(-3px) scale(1.02);
  box-shadow: var(--shadow-xl), 0 0 30px rgba(212, 175, 55, 0.5);
}

.submitButton:hover::before {
  left: 100%;
}

.submitButton:active {
  transform: translateY(-1px) scale(1);
}

.submitButton:disabled {
  background: var(--gray-400);
  cursor: not-allowed;
  transform: none;
  box-shadow: var(--shadow-sm);
}

.submitButton:disabled:hover {
  transform: none;
  box-shadow: var(--shadow-sm);
}

/* Loading State */
.loadingContainer {
  min-height: 100vh;
  display: flex;
  align-items: center;
  justify-content: center;
  background: var(--background-primary);
}

.loadingContent {
  text-align: center;
}

.spinner {
  width: 60px;
  height: 60px;
  border: 4px solid var(--border-color);
  border-top: 4px solid var(--primary);
  border-radius: 50%;
  margin: 0 auto var(--space-6);
  animation: spin 1s linear infinite;
}

@keyframes spin {
  0% {
    transform: rotate(0deg);
  }
  100% {
    transform: rotate(360deg);
  }
}

.loadingText {
  font-size: 1.125rem;
  color: var(--text-secondary);
  font-weight: 500;
}

/* Animations */
@keyframes fadeInUp {
  from {
    opacity: 0;
    transform: translateY(30px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

/* Responsive Design */
@media (max-width: 768px) {
  .pageContainer {
    padding: var(--space-6);
  }

  .card {
    padding: var(--space-8);
  }

  .title {
    font-size: 2rem;
  }

  .subtitle {
    font-size: 1rem;
  }

  .summaryTitle {
    font-size: 1.25rem;
  }

  .summaryInfo {
    font-size: 0.9375rem;
  }

  .summaryInfo strong {
    min-width: 100px;
  }

  .ratingLabel {
    font-size: 1rem;
  }

  .starButton {
    font-size: 2rem;
  }

  .starsContainer {
    gap: var(--space-2);
  }

  .commentLabel {
    font-size: 1rem;
  }

  .textarea {
    padding: var(--space-4);
    font-size: 0.9375rem;
  }

  .submitButton {
    width: 100%;
    min-width: auto;
    padding: var(--space-4) var(--space-8);
    font-size: 1rem;
  }
}

@media (max-width: 480px) {
  .pageContainer {
    padding: var(--space-4);
  }

  .card {
    padding: var(--space-6);
  }

  .title {
    font-size: 1.75rem;
  }

  .subtitle {
    font-size: 0.9375rem;
  }

  .bookingSummary {
    padding: var(--space-6);
  }

  .summaryInfo {
    flex-direction: column;
    gap: var(--space-1);
  }

  .summaryInfo strong {
    min-width: auto;
  }

  .starButton {
    font-size: 1.75rem;
  }

  .ratingInfo {
    min-width: auto;
    width: 100%;
    margin-top: var(--space-2);
  }

  .starsContainer {
    align-items: flex-start;
  }
}

/* Dark Mode Specific Adjustments */
[data-theme="dark"] .card {
  background: var(--gray-800);
  border-color: var(--gray-700);
}

[data-theme="dark"] .bookingSummary {
  background: var(--gray-900);
  border-color: var(--gray-700);
}

[data-theme="dark"] .textarea {
  background: var(--gray-900);
  border-color: var(--gray-700);
  color: var(--white);
}

[data-theme="dark"] .textarea:focus {
  border-color: var(--primary);
}

[data-theme="dark"] .starEmpty {
  color: var(--gray-600);
}

[data-theme="dark"] .spinner {
  border-color: var(--gray-700);
  border-top-color: var(--primary);
}

/* Print Styles */
@media print {
  .pageContainer {
    background: white;
  }

  .card {
    box-shadow: none;
    border: 1px solid #000;
  }

  .submitButton {
    display: none;
  }
}
</file>

<file path="src/styles/globals.css">
@import url("https://fonts.googleapis.com/css2?family=Playfair+Display:wght@400;500;600;700;800;900&family=Inter:wght@300;400;500;600;700;800;900&display=swap");
@import "tailwindcss";

* {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
}

:root {
  /* Luxury Color Palette */
  --gold-50: #fffbeb;
  --gold-100: #fef3c7;
  --gold-200: #fde68a;
  --gold-300: #fcd34d;
  --gold-400: #fbbf24;
  --gold-500: #f59e0b;
  --gold-600: #d97706;
  --gold-700: #b45309;
  --gold-800: #92400e;
  --gold-900: #78350f;

  --primary: #d4af37;
  --primary-dark: #b8941f;
  --primary-light: #f5e99b;
  --accent: #8b4513;
  --accent-light: #daa520;

  /* Neutral Colors */
  --white: #ffffff;
  --black: #000000;
  --gray-50: #fafafa;
  --gray-100: #f5f5f5;
  --gray-200: #e5e5e5;
  --gray-300: #d4d4d4;
  --gray-400: #a3a3a3;
  --gray-500: #737373;
  --gray-600: #525252;
  --gray-700: #404040;
  --gray-800: #262626;
  --gray-900: #171717;

  /* Semantic Colors */
  --success: #10b981;
  --warning: #f59e0b;
  --error: #ef4444;
  --info: #3b82f6;

  /* Light Theme */
  --background-primary: var(--white);
  --background-secondary: var(--gray-50);
  --background-tertiary: var(--gray-100);
  --text-primary: var(--gray-900);
  --text-secondary: var(--gray-600);
  --text-tertiary: var(--gray-400);
  --border-color: var(--gray-200);
  --border-color-hover: var(--primary);

  /* Typography */
  --font-display: "Playfair Display", serif;
  --font-body: "Inter", -apple-system, BlinkMacSystemFont, sans-serif;

  /* Spacing Scale */
  --space-1: 0.25rem; /* 4px */
  --space-2: 0.5rem; /* 8px */
  --space-3: 0.75rem; /* 12px */
  --space-4: 1rem; /* 16px */
  --space-5: 1.25rem; /* 20px */
  --space-6: 1.5rem; /* 24px */
  --space-8: 2rem; /* 32px */
  --space-10: 2.5rem; /* 40px */
  --space-12: 3rem; /* 48px */
  --space-16: 4rem; /* 64px */
  --space-20: 5rem; /* 80px */
  --space-24: 6rem; /* 96px */
  --space-32: 8rem; /* 128px */

  /* Border Radius */
  --radius-xs: 0.25rem;
  --radius-sm: 0.375rem;
  --radius-md: 0.5rem;
  --radius-lg: 0.75rem;
  --radius-xl: 1rem;
  --radius-2xl: 1.5rem;
  --radius-3xl: 2rem;
  --radius-full: 9999px;

  /* Shadows */
  --shadow-xs: 0 1px 2px 0 rgb(0 0 0 / 0.05);
  --shadow-sm: 0 1px 3px 0 rgb(0 0 0 / 0.1), 0 1px 2px -1px rgb(0 0 0 / 0.1);
  --shadow-md: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
  --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1),
    0 4px 6px -4px rgb(0 0 0 / 0.1);
  --shadow-xl: 0 20px 25px -5px rgb(0 0 0 / 0.1),
    0 8px 10px -6px rgb(0 0 0 / 0.1);
  --shadow-2xl: 0 25px 50px -12px rgb(0 0 0 / 0.25);
  --shadow-luxury: 0 32px 64px -12px rgba(212, 175, 55, 0.25);

  /* Transitions */
  --transition-fast: 0.15s ease-out;
  --transition-normal: 0.3s ease-out;
  --transition-slow: 0.5s ease-out;
  --transition-luxury: 0.4s cubic-bezier(0.4, 0, 0.2, 1);
}

/* Dark Theme */
[data-theme="dark"] {
  --background-primary: var(--gray-900);
  --background-secondary: var(--gray-800);
  --background-tertiary: var(--gray-700);
  --text-primary: var(--white);
  --text-secondary: var(--gray-300);
  --text-tertiary: var(--gray-500);
  --border-color: var(--gray-700);
  --primary: #ffd700;
  --primary-dark: #e6c200;
  --primary-light: #fff4b3;
}

/* Base Styles */
html {
  scroll-behavior: smooth;
  font-size: 16px;
}

body {
  font-family: var(--font-body);
  line-height: 1.6;
  color: var(--text-primary);
  background-color: var(--background-primary);
  transition: background-color var(--transition-normal),
    color var(--transition-normal);
  overflow-x: hidden;
}

/* Typography Scale */
.text-xs {
  font-size: 0.75rem;
  line-height: 1rem;
}
.text-sm {
  font-size: 0.875rem;
  line-height: 1.25rem;
}
.text-base {
  font-size: 1rem;
  line-height: 1.5rem;
}
.text-lg {
  font-size: 1.125rem;
  line-height: 1.75rem;
}
.text-xl {
  font-size: 1.25rem;
  line-height: 1.75rem;
}
.text-2xl {
  font-size: 1.5rem;
  line-height: 2rem;
}
.text-3xl {
  font-size: 1.875rem;
  line-height: 2.25rem;
}
.text-4xl {
  font-size: 2.25rem;
  line-height: 2.5rem;
}
.text-5xl {
  font-size: 3rem;
  line-height: 1;
}
.text-6xl {
  font-size: 3.75rem;
  line-height: 1;
}

/* Display Typography */
h1,
h2,
h3,
h4,
h5,
h6 {
  font-family: var(--font-display);
  font-weight: 700;
  line-height: 1.2;
  color: var(--text-primary);
}

/* Custom Scrollbar */
::-webkit-scrollbar {
  width: 8px;
  height: 8px;
}

::-webkit-scrollbar-track {
  background: var(--background-secondary);
}

::-webkit-scrollbar-thumb {
  background: linear-gradient(135deg, var(--primary), var(--primary-dark));
  border-radius: var(--radius-full);
}

::-webkit-scrollbar-thumb:hover {
  background: linear-gradient(135deg, var(--primary-dark), var(--accent));
}

/* Luxury Button System */
.btn {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  gap: var(--space-2);
  padding: var(--space-3) var(--space-6);
  border: none;
  border-radius: var(--radius-lg);
  font-family: var(--font-body);
  font-size: 0.875rem;
  font-weight: 600;
  text-decoration: none;
  cursor: pointer;
  transition: all var(--transition-luxury);
  position: relative;
  overflow: hidden;
}

.btn::before {
  content: "";
  position: absolute;
  top: 0;
  left: -100%;
  width: 100%;
  height: 100%;
  background: linear-gradient(
    90deg,
    transparent,
    rgba(255, 255, 255, 0.2),
    transparent
  );
  transition: left 0.5s ease;
}

.btn:hover::before {
  left: 100%;
}

.btn-primary {
  background: linear-gradient(
    135deg,
    var(--primary) 0%,
    var(--primary-dark) 100%
  );
  color: var(--black);
  box-shadow: var(--shadow-lg), 0 0 20px rgba(212, 175, 55, 0.3);
}

.btn-primary:hover {
  transform: translateY(-2px) scale(1.02);
  box-shadow: var(--shadow-xl), 0 0 30px rgba(212, 175, 55, 0.4);
}

.btn-secondary {
  background: transparent;
  color: var(--primary);
  border: 2px solid var(--primary);
}

.btn-secondary:hover {
  background: var(--primary);
  color: var(--black);
  transform: translateY(-2px);
}

.btn-ghost {
  background: rgba(212, 175, 55, 0.1);
  color: var(--primary);
  border: 1px solid rgba(212, 175, 55, 0.2);
}

.btn-ghost:hover {
  background: rgba(212, 175, 55, 0.2);
  transform: translateY(-1px);
}

/* Luxury Card System */
.card {
  background: var(--background-primary);
  border: 1px solid var(--border-color);
  border-radius: var(--radius-2xl);
  padding: var(--space-8);
  box-shadow: var(--shadow-sm);
  transition: all var(--transition-luxury);
  position: relative;
  overflow: hidden;
}

.card::before {
  content: "";
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 1px;
  background: linear-gradient(90deg, transparent, var(--primary), transparent);
  opacity: 0;
  transition: opacity var(--transition-normal);
}

.card:hover {
  transform: translateY(-4px) scale(1.01);
  box-shadow: var(--shadow-luxury);
  border-color: var(--primary);
}

.card:hover::before {
  opacity: 1;
}

/* Form System */
.form-group {
  margin-bottom: var(--space-6);
}

.form-label {
  display: block;
  margin-bottom: var(--space-2);
  font-weight: 500;
  color: var(--text-primary);
  font-size: 0.875rem;
}

.form-input {
  width: 100%;
  padding: var(--space-4) var(--space-4);
  border: 2px solid var(--border-color);
  border-radius: var(--radius-lg);
  font-size: 1rem;
  background-color: var(--background-primary);
  color: var(--text-primary);
  transition: all var(--transition-normal);
}

.form-input:focus {
  outline: none;
  border-color: var(--primary);
  box-shadow: 0 0 0 3px rgba(212, 175, 55, 0.1);
  transform: scale(1.01);
}

.form-input::placeholder {
  color: var(--text-tertiary);
}

/* Animation Keyframes */
@keyframes fadeInUp {
  from {
    opacity: 0;
    transform: translateY(30px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

@keyframes fadeInDown {
  from {
    opacity: 0;
    transform: translateY(-30px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

@keyframes slideInLeft {
  from {
    opacity: 0;
    transform: translateX(-50px);
  }
  to {
    opacity: 1;
    transform: translateX(0);
  }
}

@keyframes slideInRight {
  from {
    opacity: 0;
    transform: translateX(50px);
  }
  to {
    opacity: 1;
    transform: translateX(0);
  }
}

@keyframes scaleIn {
  from {
    opacity: 0;
    transform: scale(0.9);
  }
  to {
    opacity: 1;
    transform: scale(1);
  }
}

@keyframes shimmer {
  0% {
    background-position: -200px 0;
  }
  100% {
    background-position: calc(200px + 100%) 0;
  }
}

@keyframes float {
  0%,
  100% {
    transform: translateY(0px);
  }
  50% {
    transform: translateY(-10px);
  }
}

@keyframes pulse {
  0%,
  100% {
    opacity: 1;
  }
  50% {
    opacity: 0.5;
  }
}

@keyframes spin {
  0% {
    transform: rotate(0deg);
  }
  100% {
    transform: rotate(360deg);
  }
}

/* Utility Classes */
.animate-fadeInUp {
  animation: fadeInUp 0.6s ease-out;
}
.animate-fadeInDown {
  animation: fadeInDown 0.6s ease-out;
}
.animate-slideInLeft {
  animation: slideInLeft 0.6s ease-out;
}
.animate-slideInRight {
  animation: slideInRight 0.6s ease-out;
}
.animate-scaleIn {
  animation: scaleIn 0.6s ease-out;
}
.animate-float {
  animation: float 3s ease-in-out infinite;
}
.animate-pulse {
  animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
}
.animate-spin {
  animation: spin 1s linear infinite;
}

/* Gradient Text */
.gradient-text {
  background: linear-gradient(
    135deg,
    var(--primary) 0%,
    var(--primary-dark) 100%
  );
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
  font-weight: 700;
}

/* Glass Effect */
.glass {
  background: rgba(255, 255, 255, 0.1);
  backdrop-filter: blur(10px);
  border: 1px solid rgba(255, 255, 255, 0.2);
}

[data-theme="dark"] .glass {
  background: rgba(0, 0, 0, 0.3);
  border: 1px solid rgba(255, 255, 255, 0.1);
}

/* Luxury Spinner */
.luxury-spinner {
  position: relative;
  width: 60px;
  height: 60px;
}

.spinner-ring {
  position: absolute;
  width: 100%;
  height: 100%;
  border: 3px solid transparent;
  border-top: 3px solid var(--primary);
  border-radius: 50%;
  animation: spin 1s linear infinite;
}

.spinner-core {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  width: 20px;
  height: 20px;
  background: linear-gradient(135deg, var(--primary), var(--primary-dark));
  border-radius: 50%;
  animation: pulse 1.5s ease-in-out infinite;
}

/* Responsive Typography */
@media (max-width: 768px) {
  .text-6xl {
    font-size: 2.5rem;
  }
  .text-5xl {
    font-size: 2rem;
  }
  .text-4xl {
    font-size: 1.75rem;
  }
  .text-3xl {
    font-size: 1.5rem;
  }
}

/* Mobile Optimizations */
@media (max-width: 640px) {
  :root {
    --space-4: 0.875rem;
    --space-6: 1.25rem;
    --space-8: 1.75rem;
  }

  .btn {
    width: 100%;
    padding: var(--space-4) var(--space-6);
  }

  .card {
    padding: var(--space-6);
  }

  .form-input {
    font-size: 16px; /* Prevents zoom on iOS */
  }
}

/* Ultra Small Screens */
@media (max-width: 360px) {
  :root {
    --space-4: 0.75rem;
    --space-6: 1rem;
    --space-8: 1.5rem;
  }
}

/* Print Styles */
@media print {
  * {
    background: white !important;
    color: black !important;
    box-shadow: none !important;
  }
}
</file>

<file path="src/styles/Onboarding.module.css">
.container {
  min-height: 100vh;
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 20px;
  position: relative;
  background: linear-gradient(
    135deg,
    var(--background-primary) 0%,
    var(--background-secondary) 100%
  );
}

.background {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  overflow: hidden;
  z-index: 0;
}

.goldOrb {
  position: absolute;
  border-radius: 50%;
  background: linear-gradient(
    135deg,
    var(--gold-primary) 0%,
    var(--gold-dark) 100%
  );
  opacity: 0.1;
  filter: blur(60px);
}

.goldOrb:first-child {
  width: 300px;
  height: 300px;
  top: -150px;
  right: -150px;
  animation: float 8s ease-in-out infinite;
}

.goldOrb:last-child {
  width: 200px;
  height: 200px;
  bottom: -100px;
  left: -100px;
  animation: float 8s ease-in-out infinite reverse;
}

@keyframes float {
  0%,
  100% {
    transform: translateY(0px) rotate(0deg);
  }
  50% {
    transform: translateY(-20px) rotate(180deg);
  }
}

.onboardingCard {
  background: var(--background-primary);
  border-radius: 20px;
  box-shadow: 0 20px 60px rgba(0, 0, 0, 0.1);
  padding: 40px;
  width: 100%;
  max-width: 500px;
  position: relative;
  z-index: 1;
  border: 1px solid var(--border-color);
}

.header {
  text-align: center;
  margin-bottom: 40px;
}

.title {
  font-size: 32px;
  font-weight: 700;
  margin-bottom: 8px;
  color: var(--text-primary);
}

.goldText {
  background: linear-gradient(
    135deg,
    var(--gold-primary) 0%,
    var(--gold-dark) 100%
  );
  -webkit-background-clip: text;
  background-clip: text;
}

.subtitle {
  color: var(--text-secondary);
  font-size: 16px;
  margin-bottom: 30px;
}

.progressBar {
  display: flex;
  align-items: center;
  gap: 12px;
}

.progressTrack {
  flex: 1;
  height: 6px;
  background: var(--border-color);
  border-radius: 3px;
  overflow: hidden;
}

.progressFill {
  height: 100%;
  background: linear-gradient(
    135deg,
    var(--gold-primary) 0%,
    var(--gold-dark) 100%
  );
  border-radius: 3px;
  transition: width 0.3s ease;
}

.progressText {
  font-size: 14px;
  font-weight: 600;
  color: var(--gold-primary);
  min-width: 30px;
}

.stepContent {
  min-height: 300px;
  display: flex;
  flex-direction: column;
  justify-content: center;
}

.step {
  text-align: center;
}

.stepIcon {
  font-size: 64px;
  margin-bottom: 24px;
}

.step h2 {
  font-size: 24px;
  font-weight: 600;
  margin-bottom: 12px;
  color: var(--text-primary);
}

.step p {
  color: var(--text-secondary);
  margin-bottom: 32px;
  line-height: 1.5;
}

.formGroup {
  margin-bottom: 24px;
}

.input {
  width: 100%;
  padding: 16px 20px;
  border: 2px solid var(--border-color);
  border-radius: 12px;
  font-size: 16px;
  background: var(--background-primary);
  color: var(--text-primary);
  transition: all 0.3s ease;
  text-align: center;
}

.input:focus {
  outline: none;
  border-color: var(--gold-primary);
  box-shadow: 0 0 0 4px rgba(212, 175, 55, 0.1);
}

.genderOptions {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
  gap: 16px;
  margin-bottom: 20px;
}

.genderButton {
  padding: 20px 16px;
  border: 2px solid var(--border-color);
  border-radius: 12px;
  background: var(--background-primary);
  cursor: pointer;
  transition: all 0.3s ease;
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 8px;
}

.genderButton:hover {
  border-color: var(--gold-primary);
  transform: translateY(-2px);
}

.genderButton.selected {
  border-color: var(--gold-primary);
  background: linear-gradient(135deg, var(--gold-primary), var(--gold-dark));
  color: var(--contrast-dark);
  transform: translateY(-2px);
  box-shadow: 0 8px 25px rgba(212, 175, 55, 0.3);
}

.genderIcon {
  font-size: 32px;
}

.genderButton span {
  font-weight: 600;
  font-size: 14px;
}

.locationSection {
  margin-bottom: 20px;
}

.locationButton {
  width: 100%;
  padding: 16px 20px;
  background: linear-gradient(
    135deg,
    var(--gold-primary) 0%,
    var(--gold-dark) 100%
  );
  color: var(--contrast-dark);
  border: none;
  border-radius: 12px;
  font-size: 16px;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.3s ease;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 8px;
  margin-bottom: 20px;
}

.locationButton:hover {
  transform: translateY(-2px);
  box-shadow: 0 8px 25px rgba(212, 175, 55, 0.4);
}

.divider {
  text-align: center;
  margin: 20px 0;
  position: relative;
}

.divider::before {
  content: "";
  position: absolute;
  top: 50%;
  left: 0;
  right: 0;
  height: 1px;
  background: var(--border-color);
}

.divider span {
  background: var(--background-primary);
  padding: 0 16px;
  color: var(--text-secondary);
  font-size: 14px;
  position: relative;
  z-index: 1;
}

.loadingLocation {
  text-align: center;
  padding: 40px 20px;
}

.loadingLocation p {
  margin-top: 16px;
  color: var(--text-secondary);
}

.locationSuccess {
  display: flex;
  align-items: center;
  gap: 16px;
  padding: 16px;
  background: rgba(34, 197, 94, 0.1);
  border: 2px solid var(--success);
  border-radius: 12px;
}

.locationIcon {
  font-size: 24px;
}

.locationSuccess div {
  flex: 1;
}

.locationSuccess h4 {
  color: var(--success);
  font-size: 16px;
  font-weight: 600;
  margin-bottom: 4px;
}

.locationSuccess p {
  color: var(--text-secondary);
  font-size: 14px;
  margin: 0;
}

.changeLocationButton {
  padding: 8px 16px;
  background: transparent;
  color: var(--gold-primary);
  border: 1px solid var(--gold-primary);
  border-radius: 6px;
  font-size: 14px;
  cursor: pointer;
  transition: all 0.3s ease;
}

.changeLocationButton:hover {
  background: var(--gold-primary);
  color: var(--contrast-dark);
}

.locationError {
  text-align: center;
}

.locationError p {
  color: var(--error);
  margin-bottom: 16px;
}

.navigation {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-top: 40px;
  gap: 16px;
}

.backButton {
  padding: 12px 24px;
  background: transparent;
  color: var(--text-secondary);
  border: 2px solid var(--border-color);
  border-radius: 12px;
  cursor: pointer;
  font-size: 16px;
  font-weight: 600;
  transition: all 0.3s ease;
}

.backButton:hover {
  border-color: var(--gold-primary);
  color: var(--gold-primary);
}

.nextButton {
  flex: 1;
  padding: 14px 28px;
  background: linear-gradient(
    135deg,
    var(--gold-primary) 0%,
    var(--gold-dark) 100%
  );
  color: var(--contrast-dark);
  border: none;
  border-radius: 12px;
  font-size: 16px;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.3s ease;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 8px;
}

.nextButton:hover:not(:disabled) {
  transform: translateY(-2px);
  box-shadow: 0 8px 25px rgba(212, 175, 55, 0.4);
}

.nextButton:disabled {
  opacity: 0.7;
  cursor: not-allowed;
}

.spinner {
  width: 20px;
  height: 20px;
  border: 2px solid transparent;
  border-top: 2px solid currentColor;
  border-radius: 50%;
  animation: spin 1s linear infinite;
}

@keyframes spin {
  0% {
    transform: rotate(0deg);
  }
  100% {
    transform: rotate(360deg);
  }
}

/* Mobile Optimizations */
@media (max-width: 768px) {
  .container {
    padding: 16px;
  }

  .onboardingCard {
    padding: 24px;
    border-radius: 16px;
  }

  .title {
    font-size: 28px;
  }

  .step h2 {
    font-size: 20px;
  }

  .stepIcon {
    font-size: 48px;
  }

  .genderOptions {
    grid-template-columns: 1fr;
    gap: 12px;
  }

  .genderButton {
    flex-direction: row;
    justify-content: flex-start;
    padding: 16px 20px;
  }

  .navigation {
    flex-direction: column;
    gap: 12px;
  }

  .backButton {
    width: 100%;
    order: 2;
  }

  .nextButton {
    order: 1;
  }
}
</file>

<file path="src/styles/OwnerSidebar.module.css">
/* OwnerSidebar.module.css */

.sidebar {
  display: flex;
  flex-direction: column;
  height: 100%;
  background-color: var(--background-primary);
  box-shadow: var(--shadow-md);
}

/* Header Section */
.header {
  padding: 1.25rem 1.5rem;
  border-bottom: 1px solid var(--border-color);
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.logoContainer {
  display: flex;
  flex-direction: column;
}

.logo {
  font-size: 1.25rem;
  font-weight: 700;
  background: linear-gradient(135deg, var(--primary), var(--primary-dark));
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
}

.subtitle {
  font-size: 0.875rem;
  color: var(--text-secondary);
  margin-top: 0.125rem;
}

.closeButton {
  display: block;
  padding: 0.5rem;
  border-radius: var(--radius-md);
  background: none;
  border: none;
  cursor: pointer;
  transition: background-color var(--transition-fast);
  color: var(--text-primary);
  font-size: 1.25rem;
}

@media (min-width: 768px) {
  .closeButton {
    display: none;
  }
}

.closeButton:hover {
  background-color: var(--background-secondary);
}

/* Navigation */
.nav {
  flex: 1;
  overflow-y: auto;
  padding: 1rem;
  display: flex;
  flex-direction: column;
  gap: 0.25rem;
}

.navButton {
  width: 100%;
  display: flex;
  align-items: center;
  gap: 0.75rem;
  padding: 0.625rem 1rem;
  border-radius: var(--radius-lg);
  transition: all var(--transition-normal);
  background: none;
  border: none;
  cursor: pointer;
  text-align: left;
  font-size: 0.9375rem;
}

.navIcon {
  font-size: 1.125rem;
}

.navLabel {
  text-transform: capitalize;
  font-weight: 500;
}

.navButtonActive {
  background: linear-gradient(135deg, var(--primary), var(--primary-dark));
  color: var(--black);
  box-shadow: var(--shadow-md);
  font-weight: 600;
}

.navButtonInactive {
  color: var(--text-primary);
}

.navButtonInactive:hover {
  background-color: var(--background-secondary);
  transform: translateX(4px);
}

/* Footer */
.footer {
  padding: 1rem;
  border-top: 1px solid var(--border-color);
}

.logoutButton {
  width: 100%;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 0.5rem;
  padding: 0.625rem 1rem;
  background: transparent;
  color: var(--primary);
  border: 2px solid var(--primary);
  border-radius: var(--radius-lg);
  font-weight: 600;
  cursor: pointer;
  transition: all var(--transition-luxury);
  font-size: 0.9375rem;
}

.logoutButton:hover {
  background: var(--primary);
  color: var(--black);
  transform: translateY(-2px);
  box-shadow: var(--shadow-md);
}

/* Custom Scrollbar for Nav */
.nav::-webkit-scrollbar {
  width: 6px;
}

.nav::-webkit-scrollbar-track {
  background: var(--background-secondary);
  border-radius: var(--radius-full);
}

.nav::-webkit-scrollbar-thumb {
  background: linear-gradient(135deg, var(--primary), var(--primary-dark));
  border-radius: var(--radius-full);
}

.nav::-webkit-scrollbar-thumb:hover {
  background: linear-gradient(135deg, var(--primary-dark), var(--accent));
}

/* Dark mode adjustments */
[data-theme="dark"] .navButtonActive {
  color: var(--black);
}

[data-theme="dark"] .logoutButton:hover {
  color: var(--black);
}
</file>

<file path="src/styles/SalonDashboard.module.css">
/* Dashboard.module.css */

.dashboardWrapper {
  display: flex;
  min-height: 100vh;
  background-color: var(--background-primary);
}

/* Sidebar */
.sidebarDesktop {
  display: none;
  width: 16rem;
  border-right: 1px solid var(--border-color);
}

@media (min-width: 768px) {
  .sidebarDesktop {
    display: block;
  }
}
/* Time Modal */
.timeInput {
  margin: 20px 0;
}

.timeInput label {
  display: block;
  margin-bottom: 12px;
  font-weight: 600;
}

.timeButtons {
  display: flex;
  gap: 8px;
  flex-wrap: wrap;
  margin-bottom: 16px;
}

.timeOption {
  padding: 12px 20px;
  background: #f5f5f5;
  border: 2px solid #ddd;
  border-radius: 8px;
  cursor: pointer;
  font-weight: 600;
  transition: all 0.2s;
}

.timeOption:hover {
  border-color: #667eea;
}

.timeOption.selected {
  background: #667eea;
  color: white;
  border-color: #667eea;
}

.customTime {
  display: flex;
  align-items: center;
  gap: 12px;
}

.timeNumberInput {
  width: 80px;
  padding: 8px;
  border: 2px solid #ddd;
  border-radius: 8px;
  font-size: 18px;
  text-align: center;
}

.modalSubtext {
  text-align: center;
  color: #666;
  margin-bottom: 20px;
}

/* Barber Accordions */
.unassignedSection {
  margin-bottom: 30px;
  padding: 20px;
  background: #fff3cd;
  border-radius: 12px;
}

.barbersSection {
  margin-top: 20px;
}

.sectionTitle {
  font-size: 20px;
  font-weight: 700;
  margin-bottom: 16px;
  color: #333;
}

.barberAccordion {
  border: 2px solid #e0e0e0;
  border-radius: 12px;
  margin-bottom: 12px;
  overflow: hidden;
}

.barberSummary {
  padding: 16px 20px;
  background: #f5f5f5;
  cursor: pointer;
  display: flex;
  justify-content: space-between;
  align-items: center;
  font-weight: 600;
  font-size: 18px;
  list-style: none;
}

.barberSummary::-webkit-details-marker {
  display: none;
}

.barberName {
  color: #333;
}

.bookingBadge {
  background: #f44336;
  color: white;
  padding: 4px 12px;
  border-radius: 12px;
  font-size: 14px;
  font-weight: 700;
}

.barberBookings {
  padding: 16px;
  background: white;
}

.noBookings {
  text-align: center;
  color: #999;
  padding: 20px;
}

.barberActions {
  display: flex;
  gap: 8px;
  margin-top: 12px;
  flex-wrap: wrap;
}

.timeBtn,
.pauseBtn,
.doneBtn {
  padding: 8px 16px;
  border: none;
  border-radius: 8px;
  font-weight: 600;
  cursor: pointer;
  font-size: 14px;
}

.timeBtn {
  background: #2196f3;
  color: white;
}

.pauseBtn {
  background: #ff9800;
  color: white;
}

.doneBtn {
  background: #4caf50;
  color: white;
}

/* Mobile Sidebar Overlay */
.mobileOverlay {
  position: fixed;
  inset: 0;
  z-index: 40;
  display: flex;
}

@media (min-width: 768px) {
  .mobileOverlay {
    display: none;
  }
}

.overlay {
  position: fixed;
  inset: 0;
  background-color: rgba(0, 0, 0, 0.4);
}

.drawer {
  position: relative;
  display: flex;
  flex-direction: column;
  max-width: 20rem;
  width: 100%;
  background-color: var(--background-primary);
  box-shadow: var(--shadow-2xl);
  animation: slideInLeft 0.3s ease-out;
}

@keyframes slideInLeft {
  from {
    transform: translateX(-100%);
  }
  to {
    transform: translateX(0);
  }
}

/* Main Content */
.mainContent {
  flex: 1;
  padding: 1rem;
}

@media (min-width: 768px) {
  .mainContent {
    padding: 1.5rem;
  }
}

.contentContainer {
  max-width: 80rem;
  margin: 0 auto;
  display: flex;
  flex-direction: column;
  gap: 1.25rem;
  animation: fadeInUp 0.5s ease-out;
}

@keyframes fadeInUp {
  from {
    opacity: 0;
    transform: translateY(20px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

/* Loading State */
.loadingContainer {
  display: flex;
  align-items: center;
  justify-content: center;
  height: 100vh;
}

.loadingContent {
  display: flex;
  align-items: center;
  gap: 0.5rem;
}

.spinner {
  width: 2rem;
  height: 2rem;
  border: 3px solid var(--border-color);
  border-top-color: var(--primary);
  border-radius: 50%;
  animation: spin 1s linear infinite;
}

@keyframes spin {
  to {
    transform: rotate(360deg);
  }
}

/* Mobile Top Bar */
.mobileTopBar {
  display: flex;
  align-items: center;
  justify-content: space-between;
  background-color: var(--background-primary);
  padding: 0.75rem;
  border-radius: var(--radius-lg);
  box-shadow: var(--shadow-sm);
  position: sticky;
  top: 0;
  z-index: 30;
  border: 1px solid var(--border-color);
}

@media (min-width: 768px) {
  .mobileTopBar {
    display: none;
  }
}

.menuButton {
  padding: 0.5rem;
  border-radius: var(--radius-md);
  transition: background-color var(--transition-fast);
  background: none;
  border: none;
  cursor: pointer;
  color: var(--text-primary);
  font-size: 1.25rem;
}

.menuButton:hover {
  background-color: var(--background-secondary);
}

.mobileTitle {
  font-weight: 700;
  font-size: 1.125rem;
  background: linear-gradient(135deg, var(--primary), var(--primary-dark));
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
}

/* Card Component */
.card {
  background-color: var(--background-primary);
  border: 1px solid var(--border-color);
  border-radius: var(--radius-xl);
  padding: 1.25rem;
  box-shadow: var(--shadow-sm);
  transition: all var(--transition-normal);
}

@media (min-width: 768px) {
  .card {
    padding: 1.5rem;
  }
}

/* Salon Info */
.salonTitle {
  font-size: 1.5rem;
  font-weight: 700;
  background: linear-gradient(135deg, var(--primary), var(--primary-dark));
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
  margin-bottom: 0.25rem;
}

.salonOwner {
  color: var(--text-secondary);
  font-size: 0.9375rem;
}

/* Filter Section */
.filterHeader {
  display: flex;
  flex-direction: column;
  gap: 1rem;
  align-items: flex-start;
}

@media (min-width: 640px) {
  .filterHeader {
    flex-direction: row;
    align-items: center;
    justify-content: space-between;
  }
}

.filterTitle {
  font-size: 1.125rem;
  font-weight: 600;
  color: var(--text-primary);
}

.filterButtons {
  display: flex;
  flex-wrap: wrap;
  gap: 0.5rem;
}

.filterButton {
  padding: 0.5rem 1rem;
  border-radius: var(--radius-lg);
  font-size: 0.875rem;
  font-weight: 500;
  transition: all var(--transition-fast);
  border: none;
  cursor: pointer;
}

.filterButtonActive {
  background: linear-gradient(135deg, var(--primary), var(--primary-dark));
  color: var(--black);
  box-shadow: var(--shadow-lg);
  transform: scale(1.05);
}

.filterButtonInactive {
  background-color: var(--background-secondary);
  color: var(--text-primary);
  border: 1px solid var(--border-color);
}

.filterButtonInactive:hover {
  background-color: var(--background-tertiary);
  box-shadow: var(--shadow-md);
}

/* Bookings Section */
.bookingsHeader {
  display: flex;
  flex-direction: column;
  gap: 1rem;
  align-items: flex-start;
  margin-bottom: 1.5rem;
}

@media (min-width: 640px) {
  .bookingsHeader {
    flex-direction: row;
    align-items: center;
    justify-content: space-between;
  }
}

.bookingsInfo {
  display: flex;
  flex-direction: column;
}

.bookingsTitle {
  font-size: 1.25rem;
  font-weight: 600;
  margin-bottom: 0.25rem;
  color: var(--text-primary);
}
/* Date Picker Styles */
.datePickerContainer {
  display: flex;
  align-items: center;
  gap: 12px;
  margin-top: 20px;
  padding: 16px;
  background: #f9fafb;
  border-radius: 8px;
}

.datePickerLabel {
  font-size: 14px;
  font-weight: 600;
  color: #374151;
}

.datePickerInput {
  padding: 10px 16px;
  border: 2px solid #d1d5db;
  border-radius: 8px;
  font-size: 14px;
  font-weight: 500;
  color: #1f2937;
  background: white;
  cursor: pointer;
  transition: all 0.2s;
}

.datePickerInput:focus {
  outline: none;
  border-color: #f59e0b;
  box-shadow: 0 0 0 3px rgba(245, 158, 11, 0.1);
}

.datePickerInput:hover {
  border-color: #9ca3af;
}

.currentDateDisplay {
  margin-top: 16px;
  padding: 12px 16px;
  background: #fef3c7;
  border-left: 4px solid #f59e0b;
  border-radius: 8px;
  display: flex;
  align-items: center;
  gap: 10px;
}

.currentDateIcon {
  font-size: 20px;
}

.currentDateText {
  font-size: 14px;
  font-weight: 700;
  color: #92400e;
}

/* Responsive */
@media (max-width: 768px) {
  .datePickerContainer {
    flex-direction: column;
    align-items: flex-start;
  }

  .datePickerInput {
    width: 100%;
  }
}

.bookingsDate {
  font-size: 0.875rem;
  color: var(--text-secondary);
}

.refreshButton {
  margin-top: 0.5rem;
  padding: 0.5rem 1rem;
  background-color: rgba(59, 130, 246, 0.1);
  color: #3b82f6;
  border-radius: var(--radius-lg);
  font-size: 0.875rem;
  font-weight: 500;
  border: none;
  cursor: pointer;
  transition: background-color var(--transition-fast);
}

@media (min-width: 640px) {
  .refreshButton {
    margin-top: 0;
  }
}

.refreshButton:hover {
  background-color: rgba(59, 130, 246, 0.2);
}

.refreshButton:disabled {
  opacity: 0.6;
  cursor: not-allowed;
}

/* Error Message */
.errorBox {
  background-color: rgba(239, 68, 68, 0.1);
  border: 1px solid var(--error);
  color: var(--error);
  padding: 0.75rem 1rem;
  border-radius: var(--radius-md);
  margin-bottom: 1rem;
}

/* Empty State */
.emptyState {
  text-align: center;
  padding: 3rem 1rem;
}

.emptyIcon {
  font-size: 4rem;
  margin-bottom: 1rem;
}

.emptyText {
  color: var(--text-secondary);
  font-size: 1.125rem;
  margin-bottom: 1rem;
}

.viewAllButton {
  margin-top: 0.75rem;
  padding: 0.5rem 1rem;
  background: linear-gradient(135deg, var(--primary), var(--primary-dark));
  color: var(--black);
  border-radius: var(--radius-lg);
  font-size: 0.875rem;
  font-weight: 500;
  border: none;
  cursor: pointer;
  transition: all var(--transition-luxury);
}

.viewAllButton:hover {
  transform: translateY(-2px);
  box-shadow: var(--shadow-lg);
}

/* Bookings Grid */
.bookingsGrid {
  display: grid;
  gap: 1rem;
}

.bookingCard {
  display: flex;
  flex-direction: column;
  justify-content: space-between;
  background-color: var(--background-primary);
  border: 1px solid var(--border-color);
  border-radius: var(--radius-xl);
  padding: 1rem;
  box-shadow: var(--shadow-sm);
  transition: all var(--transition-normal);
}

@media (min-width: 768px) {
  .bookingCard {
    flex-direction: row;
    align-items: center;
  }
}

.bookingCard:hover {
  box-shadow: var(--shadow-md);
  border-color: var(--primary);
}

.bookingDetails {
  display: flex;
  flex-direction: column;
  gap: 0.25rem;
}

.customerName {
  font-weight: 600;
  font-size: 1.125rem;
  color: var(--text-primary);
}

.bookingInfo {
  color: var(--text-secondary);
  font-size: 0.9375rem;
}

/* Booking Actions */
.bookingActions {
  margin-top: 0.75rem;
  display: flex;
  flex-direction: column;
  gap: 0.5rem;
}

@media (min-width: 768px) {
  .bookingActions {
    margin-top: 0;
  }
}

.statusBadge {
  padding: 0.25rem 0.75rem;
  border-radius: var(--radius-full);
  font-size: 0.875rem;
  font-weight: 500;
  align-self: flex-start;
}

@media (min-width: 768px) {
  .statusBadge {
    align-self: flex-end;
  }
}

.statusConfirmed {
  background-color: rgba(59, 130, 246, 0.1);
  color: #1e40af;
}

.statusStarted {
  background-color: rgba(245, 158, 11, 0.1);
  color: #b45309;
}

.statusCompleted {
  background-color: rgba(16, 185, 129, 0.2);
  color: var(--success);
}

.statusCancelled {
  background-color: rgba(239, 68, 68, 0.2);
  color: var(--error);
}

.statusDefault {
  background-color: var(--background-secondary);
  color: var(--text-secondary);
}

.actionButtons {
  display: flex;
  flex-wrap: wrap;
  gap: 0.5rem;
}

.actionButton {
  padding: 0.5rem 1rem;
  background: linear-gradient(135deg, var(--primary), var(--primary-dark));
  color: var(--black);
  border: none;
  border-radius: var(--radius-lg);
  font-size: 0.875rem;
  font-weight: 600;
  cursor: pointer;
  transition: all var(--transition-luxury);
  box-shadow: var(--shadow-sm);
}

.actionButton:hover {
  transform: translateY(-2px);
  box-shadow: var(--shadow-md);
}

.cancelButton {
  background: transparent;
  color: var(--primary);
  border: 2px solid var(--primary);
}

.cancelButton:hover {
  background: var(--primary);
  color: var(--black);
}

/* Dark mode adjustments */
[data-theme="dark"] .filterButtonActive {
  color: var(--black);
}

[data-theme="dark"] .actionButton {
  color: var(--black);
}

[data-theme="dark"] .statusConfirmed {
  background-color: rgba(59, 130, 246, 0.2);
  color: #60a5fa;
}

[data-theme="dark"] .statusStarted {
  background-color: rgba(245, 158, 11, 0.2);
  color: #fbbf24;
}
</file>

<file path="next.config.js">
/** @type {import('next').NextConfig} */
const nextConfig = {
  reactStrictMode: true,
  swcMinify: true,
  trailingSlash: false,
  experimental: {
    swcTraceProfiling: false, // 🚫 disables trace file
  },
  images: {
    domains: [
      "localhost",
      "your-domain.com",
      "tile.openstreetmap.org",
      "images.unsplash.com",
    ],
    unoptimized: true,
  },
  env: {
    MONGODB_URI: process.env.MONGODB_URI,
    JWT_SECRET: process.env.JWT_SECRET,
  },

  webpack: (config) => {
    // Handle Leaflet in SSR
    config.resolve.fallback = {
      ...config.resolve.fallback,
      fs: false,
      net: false,
      tls: false,
    };
    return config;
  },
};

export default nextConfig;
</file>

<file path="src/components/Layout/Layout.js">
// import Link from "next/link";

// export default function Layout({ children }) {
//   return (
//     <div className={"layout"}>
//       <header className={"header"}>
//         <div className={"logo"}>
//           <h2>💈 SalonBook</h2>
//         </div>
//         <nav>
//           <Link href="/">Home</Link>
//           <Link href="/bookings">My Bookings</Link>
//           <Link href="/profile">Profile</Link>
//         </nav>
//       </header>
//       <main className={"main"}>{children}</main>
//       <footer className={"footer"}>
//         <p>&copy; 2024 SalonBook. All rights reserved.</p>
//       </footer>
//     </div>
//   );
// }
</file>

<file path="src/components/Maps/LocationMap.js">
// techtrims/src/components/Maps/LocationMap.js
import React, { useEffect, useState } from "react";
import {
  MapContainer,
  TileLayer,
  Marker,
  Popup,
  Polyline,
} from "react-leaflet";
import L from "leaflet";
import "leaflet/dist/leaflet.css";
import styles from "../../styles/LocationMap.module.css";

// Fix for default markers
delete L.Icon.Default.prototype._getIconUrl;
L.Icon.Default.mergeOptions({
  iconRetinaUrl:
    "https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.7.1/images/marker-icon-2x.png",
  iconUrl:
    "https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.7.1/images/marker-icon.png",
  shadowUrl:
    "https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.7.1/images/marker-shadow.png",
});

// Custom icons
const salonIcon = new L.Icon({
  iconUrl:
    "data:image/svg+xml;base64," +
    btoa(`
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="#f59e0b" width="35" height="35">
      <path d="M12 2C8.13 2 5 5.13 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.87-3.13-7-7-7zm0 9.5c-1.38 0-2.5-1.12-2.5-2.5s1.12-2.5 2.5-2.5 2.5 1.12 2.5 2.5-1.12 2.5-2.5 2.5z"/>
    </svg>
  `),
  iconSize: [35, 35],
  iconAnchor: [17.5, 35],
  popupAnchor: [0, -35],
});

const userIcon = new L.Icon({
  iconUrl:
    "data:image/svg+xml;base64," +
    btoa(`
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="#3b82f6" width="25" height="25">
      <circle cx="12" cy="12" r="8" stroke="#fff" stroke-width="2"/>
      <circle cx="12" cy="12" r="4"/>
    </svg>
  `),
  iconSize: [25, 25],
  iconAnchor: [12.5, 12.5],
});

const LocationMap = ({ salonLocation, userLocation, salonName, address }) => {
  const [routeCoordinates, setRouteCoordinates] = useState([]);
  const [distance, setDistance] = useState(null);
  const [duration, setDuration] = useState(null);
  const [loading, setLoading] = useState(false);

  const center = salonLocation || [19.076, 72.8777];

  const calculateDirectRoute = useCallback(() => {
    if (userLocation && salonLocation) {
      const route = [
        [userLocation.lat, userLocation.lng],
        [salonLocation[0], salonLocation[1]],
      ];
      setRouteCoordinates(route);

      const R = 6371;
      const dLat = ((salonLocation[0] - userLocation.lat) * Math.PI) / 180;
      const dLon = ((salonLocation[1] - userLocation.lng) * Math.PI) / 180;
      const a =
        Math.sin(dLat / 2) * Math.sin(dLat / 2) +
        Math.cos((userLocation.lat * Math.PI) / 180) *
          Math.cos((salonLocation[0] * Math.PI) / 180) *
          Math.sin(dLon / 2) *
          Math.sin(dLon / 2);
      const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
      const dist = R * c;

      setDistance(dist.toFixed(1));
      setDuration(Math.round(dist * 3));
    }
  }, [userLocation, salonLocation]);

  const getAdvancedDirections = async () => {
    if (!userLocation || !salonLocation) return;

    setLoading(true);
    try {
      // Using OpenRouteService for routing (free alternative to Google)
      const response = await fetch(
        `https://api.openrouteservice.org/v2/directions/driving-car?api_key=YOUR_API_KEY&start=${userLocation.lng},${userLocation.lat}&end=${salonLocation[1]},${salonLocation[0]}`
      );

      if (response.ok) {
        const data = await response.json();
        const coordinates = data.features[0].geometry.coordinates.map(
          (coord) => [coord[1], coord[0]]
        );
        setRouteCoordinates(coordinates);

        const route = data.features[0].properties.segments[0];
        setDistance((route.distance / 1000).toFixed(1));
        setDuration(Math.round(route.duration / 60));
      } else {
        // Fallback to direct route
        calculateDirectRoute();
      }
    } catch (error) {
      calculateDirectRoute();
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    if (userLocation && salonLocation) {
      calculateDirectRoute();
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [calculateDirectRoute]);

  // In SalonMap.js or LocationMap.js
  const openInGoogleMaps = () => {
    if (salonLocation) {
      const [salonLat, salonLng] = salonLocation;
      let url;

      if (userLocation) {
        // Directions from user location to salon
        url = `https://www.google.com/maps/dir/${userLocation.lat},${userLocation.lng}/${salonLat},${salonLng}`;
      } else {
        // Just show salon location
        url = `https://www.google.com/maps/search/?api=1&query=${salonLat},${salonLng}`;
      }

      // Use location.href instead of window.open for better mobile compatibility
      window.location.href = url;
    }
  };

  return (
    <div className={styles.mapContainer}>
      <div className={styles.mapHeader}>
        <div className={styles.mapInfo}>
          <h3>{salonName}</h3>
          <p>{address}</p>
          {distance && (
            <div className={styles.routeInfo}>
              <span>📍 {distance} km</span>
              {duration && <span>🕐 ~{duration} min</span>}
            </div>
          )}
        </div>
        <div className={styles.mapActions}>
          <button className={styles.directionsBtn} onClick={openInGoogleMaps}>
            Get Directions
          </button>
          {userLocation && (
            <button
              className={styles.routeBtn}
              onClick={getAdvancedDirections}
              disabled={loading}
            >
              {loading ? "Loading..." : "Show Route"}
            </button>
          )}
        </div>
      </div>

      <MapContainer
        center={center}
        zoom={userLocation ? 13 : 15}
        className={styles.map}
      >
        <TileLayer
          url="https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png"
          attribution='&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
        />

        {/* Salon marker */}
        {salonLocation && (
          <Marker position={salonLocation} icon={salonIcon}>
            <Popup>
              <div className={styles.popupContent}>
                <strong>{salonName}</strong>
                <p>{address}</p>
                <button onClick={openInGoogleMaps} className={styles.popupBtn}>
                  Get Directions
                </button>
              </div>
            </Popup>
          </Marker>
        )}

        {/* User location marker */}
        {userLocation && (
          <Marker
            position={[userLocation.lat, userLocation.lng]}
            icon={userIcon}
          >
            <Popup>
              <div className={styles.popupContent}>
                <strong>Your Location</strong>
              </div>
            </Popup>
          </Marker>
        )}

        {/* Route polyline */}
        {routeCoordinates.length > 0 && (
          <Polyline
            positions={routeCoordinates}
            color="#f59e0b"
            weight={4}
            opacity={0.7}
            dashArray="10, 10"
          />
        )}
      </MapContainer>
    </div>
  );
};

export default LocationMap;
</file>

<file path="src/components/Maps/LocationPicker.js">
// components/Maps/LocationPicker.js - Leaflet location picker
import React, { useState, useEffect, useRef } from "react";
import {
  MapContainer,
  TileLayer,
  Marker,
  Popup,
  useMapEvents,
} from "react-leaflet";
import { MapPin, Search, Navigation } from "lucide-react";
import { geocodeAddress, reverseGeocode } from "../../lib/maps";

// Fix for Leaflet icons in Next.js
import L from "leaflet";
delete L.Icon.Default.prototype._getIconUrl;
L.Icon.Default.mergeOptions({
  iconRetinaUrl:
    "https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/images/marker-icon-2x.png",
  iconUrl:
    "https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/images/marker-icon.png",
  shadowUrl:
    "https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/images/marker-shadow.png",
});

// Custom marker icon for salons
const salonIcon = new L.Icon({
  iconUrl:
    "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHBhdGggZD0iTTIuNSAxNi41QzIuNSAxNi41IDYuNSAxMi41IDEyIDEyLjVTMjEuNSAxNi41IDIxLjUgMTYuNSIgc3Ryb2tlPSIjRjU5RTBCIiBzdHJva2Utd2lkdGg9IjIiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCIvPgo8cGF0aCBkPSJNMTIgMjJWMTIuNSIgc3Ryb2tlPSIjRjU5RTBCIiBzdHJva2Utd2lkdGg9IjIiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCIvPgo8L3N2Zz4K",
  iconSize: [32, 32],
  iconAnchor: [16, 32],
  popupAnchor: [0, -32],
});

function LocationMarker({ position, setPosition, setAddress, isDarkMode }) {
  const map = useMapEvents({
    click(e) {
      const newPos = [e.latlng.lat, e.latlng.lng];
      setPosition(newPos);

      // Get address for the clicked position
      reverseGeocode(e.latlng.lat, e.latlng.lng)
        .then((address) => setAddress(address))
        .catch(console.error);
    },
  });

  return position ? (
    <Marker position={position}>
      <Popup>
        <div
          className={`p-2 ${isDarkMode ? "text-gray-800" : "text-gray-900"}`}
        >
          📍 Selected Location
        </div>
      </Popup>
    </Marker>
  ) : null;
}

const LocationPicker = ({
  onLocationSelect = () => {},
  initialPosition = [19.076, 72.8777], // Mumbai center
  isDarkMode = false,
}) => {
  const [position, setPosition] = useState(initialPosition);
  const [address, setAddress] = useState("");
  const [searchQuery, setSearchQuery] = useState("");
  const [loading, setLoading] = useState(false);
  const mapRef = useRef();

  const handleSearch = async () => {
    if (!searchQuery.trim()) return;

    setLoading(true);
    try {
      const result = await geocodeAddress(searchQuery);
      const newPos = [result.coordinates[1], result.coordinates[0]]; // lat, lng for Leaflet
      setPosition(newPos);
      setAddress(result.formattedAddress);

      // Fly to the new position
      if (mapRef.current) {
        mapRef.current.flyTo(newPos, 15);
      }
    } catch (error) {
      alert("Location not found. Please try a different search term.");
    } finally {
      setLoading(false);
    }
  };

  const getCurrentLocation = () => {
    if (navigator.geolocation) {
      setLoading(true);
      navigator.geolocation.getCurrentPosition(
        async (pos) => {
          const newPos = [pos.coords.latitude, pos.coords.longitude];
          setPosition(newPos);

          try {
            const address = await reverseGeocode(
              pos.coords.latitude,
              pos.coords.longitude
            );
            setAddress(address);
          } catch (error) {
            console.error("Error getting address:", error);
          }

          if (mapRef.current) {
            mapRef.current.flyTo(newPos, 15);
          }
          setLoading(false);
        },
        (error) => {
          console.error("Geolocation error:", error);
          alert("Unable to get your location");
          setLoading(false);
        }
      );
    }
  };

  const handleConfirm = () => {
    if (position && address && onLocationSelect) {
      onLocationSelect({
        lat: position[0],
        lng: position[1],
        address: address,
      });
    } else {
    }
  };

  return (
    <div className="space-y-4">
      {/* Search Controls */}
      <div className="space-y-3">
        <div className="flex space-x-2">
          <div className="flex-1 relative">
            <Search
              className={`absolute left-3 top-1/2 transform -translate-y-1/2 w-5 h-5 ${
                isDarkMode ? "text-gray-400" : "text-gray-500"
              }`}
            />
            <input
              type="text"
              placeholder="Search for an address..."
              value={searchQuery}
              onChange={(e) => setSearchQuery(e.target.value)}
              onKeyPress={(e) => e.key === "Enter" && handleSearch()}
              className={`w-full pl-10 pr-4 py-3 rounded-xl border transition-all duration-300 focus:ring-2 focus:ring-opacity-50 ${
                isDarkMode
                  ? "bg-gray-700 border-gray-600 text-white placeholder-gray-400 focus:border-yellow-500 focus:ring-yellow-500"
                  : "bg-white border-gray-300 text-gray-900 placeholder-gray-500 focus:border-amber-500 focus:ring-amber-500"
              }`}
            />
          </div>
          <button
            onClick={handleSearch}
            disabled={loading}
            className={`px-4 py-3 rounded-xl font-medium transition-all duration-300 ${
              isDarkMode
                ? "bg-yellow-500 text-gray-900 hover:bg-yellow-400"
                : "bg-amber-500 text-white hover:bg-amber-600"
            } disabled:opacity-50`}
          >
            {loading ? "..." : "Search"}
          </button>
        </div>

        <button
          onClick={getCurrentLocation}
          disabled={loading}
          className={`w-full py-3 px-4 rounded-xl border-2 border-dashed transition-all duration-300 flex items-center justify-center ${
            isDarkMode
              ? "border-gray-600 text-gray-300 hover:border-gray-500"
              : "border-gray-300 text-gray-600 hover:border-gray-400"
          } disabled:opacity-50`}
        >
          <Navigation className="w-5 h-5 mr-2" />
          {loading ? "Getting location..." : "Use Current Location"}
        </button>
      </div>

      {/* Map Container */}
      <div
        className={`rounded-xl overflow-hidden border-2 ${
          isDarkMode ? "border-gray-600" : "border-gray-300"
        }`}
        style={{ height: "400px" }}
      >
        <MapContainer
          center={position}
          zoom={13}
          style={{ height: "100%", width: "100%" }}
          ref={mapRef}
        >
          <TileLayer
            attribution='&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
            url="https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png"
          />
          <LocationMarker
            position={position}
            setPosition={setPosition}
            setAddress={setAddress}
            isDarkMode={isDarkMode}
          />
        </MapContainer>
      </div>

      {/* Selected Address Display */}
      {address && (
        <div
          className={`p-4 rounded-xl ${
            isDarkMode ? "bg-gray-700" : "bg-gray-100"
          }`}
        >
          <div className="flex items-start">
            <MapPin
              className={`w-5 h-5 mr-3 mt-0.5 flex-shrink-0 ${
                isDarkMode ? "text-yellow-400" : "text-amber-600"
              }`}
            />
            <div>
              <p
                className={`font-medium ${
                  isDarkMode ? "text-white" : "text-gray-900"
                }`}
              >
                Selected Location:
              </p>
              <p
                className={`text-sm mt-1 ${
                  isDarkMode ? "text-gray-300" : "text-gray-600"
                }`}
              >
                {address}
              </p>
            </div>
          </div>
        </div>
      )}

      {/* Confirm Button */}
      <button
        onClick={handleConfirm}
        disabled={!position || !address}
        className={`w-full py-3 px-6 rounded-xl font-medium transition-all duration-300 transform hover:scale-105 disabled:transform-none disabled:opacity-50 ${
          isDarkMode
            ? "bg-gradient-to-r from-yellow-500 to-amber-500 text-gray-900 hover:from-yellow-400 hover:to-amber-400"
            : "bg-gradient-to-r from-amber-500 to-yellow-600 text-white hover:from-amber-600 hover:to-yellow-700"
        }`}
      >
        Confirm Location
      </button>
    </div>
  );
};

export default LocationPicker;
</file>

<file path="src/models/Barber.js">
// models/Barber.js
import mongoose from "mongoose";

const BarberSchema = new mongoose.Schema(
  {
    salonId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "Salon",
      required: true,
    },
    name: { type: String, required: true },
    experience: { type: Number, default: 0 },
    skills: [{ type: String }],
    bio: { type: String, default: "" },
    photo: { type: String, default: "" },
    isAvailable: { type: Boolean, default: true },

    // ============ NEW FIELDS FOR WALK-IN SYSTEM ============
    chairNumber: {
      type: Number,
      required: true,
      index: true,
    },

    currentStatus: {
      type: String,
      enum: ["AVAILABLE", "OCCUPIED", "BREAK"],
      default: "AVAILABLE",
    },

    currentBookingId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "WalkinBooking",
      default: null,
    },

    currentServiceStartTime: {
      type: Date,
      default: null,
    },

    currentServiceEndTime: {
      type: Date,
      default: null,
    },

    queueLength: {
      type: Number,
      default: 0,
    },
    // ============ END NEW FIELDS ============

    // Keep existing fields
    totalBookings: { type: Number, default: 0 },
    rating: { type: Number, default: 5.0 },
    earnings: { type: Number, default: 0 },
  },
  { timestamps: true }
);

export default mongoose.models.Barber || mongoose.model("Barber", BarberSchema);
</file>

<file path="src/models/Booking.js">
// src/models/Booking.js - Match your actual database structure
import mongoose from "mongoose";

const BookingSchema = new mongoose.Schema(
  {
    salonId: { type: ObjectId, required: true, index: true },
    customerName: { type: String, required: true },
    service: { type: String, required: true },
    barberId: { type: ObjectId, ref: "Barber", required: true, index: true },
    date: { type: String, required: true, index: true },
    time: { type: String, required: true },

    // NEW FIELDS FOR WALKIN WORKFLOW
    bookingType: {
      type: String,
      enum: ["WALKIN_ONLINE"],
      default: "WALKIN_ONLINE",
      index: true,
    },

    // Queue & Status Management
    queueStatus: {
      type: String,
      enum: ["RED", "ORANGE", "GREEN", "EXPIRED", "COMPLETED"],
      default: "RED",
    },
    queuePosition: { type: Number, default: null },

    // Unique Booking Identifier & QR
    bookingCode: {
      type: String,
      unique: true,
      required: true,
      index: true,
    },
    qrCodeUrl: { type: String },

    // Expiry Management
    expiresAt: { type: Date, required: true },
    arrivedAt: { type: Date, default: null },
    isExpired: { type: Boolean, default: false },

    // Service Duration Tracking
    estimatedDuration: { type: Number, required: true }, // in minutes
    actualDuration: { type: Number, default: null },
    serviceStartedAt: { type: Date, default: null },
    serviceEndedAt: { type: Date, default: null },

    // Barber Selection Tracking
    selectedDuration: { type: Number, default: null },

    // Real-time Updates
    lastUpdated: { type: Date, default: Date.now },

    // Previous status tracking
    status: {
      enum: [
        "confirmed",
        "arrived",
        "in_service",
        "completed",
        "cancelled",
        "expired",
      ],
      default: "confirmed",
    },
  },
  { timestamps: true }
);

export default mongoose.models.Booking ||
  mongoose.model("Booking", BookingSchema);
</file>

<file path="src/pages/api/auth/salon/register.js">
import clientPromise from "../../../../lib/mongodb";
import {
  hashPassword,
  generateToken,
  getLocationFromCoordinates,
} from "../../../../lib/auth";

export default async function handler(req, res) {
  if (req.method !== "POST") {
    return res.status(405).json({ message: "Method not allowed" });
  }
  const client = await clientPromise;
  const db = client.db("techtrims");
  const salons = db.collection("salons");
  const barbersCollection = db.collection("barbers");

  // ADD DATABASE CONNECTION VERIFICATION
  console.log("=== DATABASE CONNECTION DEBUG ===");
  console.log("Client connected:", !!client);
  console.log("Database name:", db.databaseName);
  console.log("Collections initialized:", !!salons && !!barbersCollection);

  // Test database write access
  try {
    await db.admin().ping();
    console.log("Database ping successful");
  } catch (pingError) {
    console.error("Database ping failed:", pingError);
  }

  console.log("=== END CONNECTION DEBUG ===");
  try {
    let {
      salonName,
      ownerName,
      email,
      phone,
      password,
      address,
      latitude,
      longitude,
      services,
      barbers = [],
      operatingHours,
      description,
      amenities,
      salonImages,
    } = req.body;

    console.log("Registration request:", {
      salonName,
      ownerName,
      barbers: barbers,
      barbersCount: barbers.length,
    });

    // Ensure latitude/longitude are numbers
    latitude = parseFloat(latitude);
    longitude = parseFloat(longitude);

    // Validate required fields
    const requiredFields = {
      salonName: "Salon name",
      ownerName: "Owner name",
      email: "Email",
      phone: "Phone number",
      password: "Password",
      address: "Address",
      latitude: "Location (latitude)",
      longitude: "Location (longitude)",
    };

    for (const [field, label] of Object.entries(requiredFields)) {
      if (!req.body[field]) {
        return res.status(400).json({
          message: `${label} is required`,
        });
      }
    }

    // Validate email format
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    if (!emailRegex.test(email)) {
      return res.status(400).json({ message: "Invalid email format" });
    }

    // Validate phone format (Indian format)
    const phoneRegex = /^[6-9]\d{9}$/;
    if (!phoneRegex.test(phone)) {
      return res
        .status(400)
        .json({ message: "Invalid phone number. Use 10-digit Indian format" });
    }

    // Validate password strength
    if (password.length < 6) {
      return res
        .status(400)
        .json({ message: "Password must be at least 6 characters long" });
    }

    // Validate coordinates
    if (isNaN(latitude) || isNaN(longitude)) {
      return res
        .status(400)
        .json({ message: "Location (latitude) is required" });
    }

    const client = await clientPromise;
    const db = client.db("techtrims");
    const salons = db.collection("salons");
    const barbersCollection = db.collection("barbers"); // ADD THIS LINE

    // Check if salon already exists
    const existingSalon = await salons.findOne({
      $or: [
        { email: email.toLowerCase() },
        { phone: phone },
        { salonName: salonName.trim() },
      ],
    });

    if (existingSalon) {
      return res.status(409).json({
        message: "Salon already exists with this email, phone number, or name",
      });
    }

    // Hash password
    const hashedPassword = await hashPassword(password);

    // Get location details from coordinates
    let locationDetails = {};
    try {
      let locationDetails = {};
      try {
        locationDetails = await getLocationFromCoordinates(latitude, longitude);
      } catch (err) {
        console.warn("Geocoding failed:", err.message);
        locationDetails = {
          city: "",
          state: "",
          country: "India",
          postcode: "",
        };
      }
    } catch (err) {
      console.warn("Geocoding failed, falling back to defaults:", err);
      locationDetails = { city: "", state: "", country: "India", postcode: "" };
    }

    // Default services if not provided
    const defaultServices = services || [
      { name: "Haircut", price: 200, duration: 30, gender: ["Male", "Female"] },
      {
        name: "Hair Wash",
        price: 100,
        duration: 15,
        gender: ["Male", "Female"],
      },
      { name: "Beard Trim", price: 150, duration: 20, gender: ["Male"] },
      { name: "Facial", price: 500, duration: 60, gender: ["Female"] },
    ];

    // Default operating hours if not provided
    const defaultOperatingHours = operatingHours || {
      monday: { open: "09:00", close: "20:00", closed: false },
      tuesday: { open: "09:00", close: "20:00", closed: false },
      wednesday: { open: "09:00", close: "20:00", closed: false },
      thursday: { open: "09:00", close: "20:00", closed: false },
      friday: { open: "09:00", close: "20:00", closed: false },
      saturday: { open: "09:00", close: "21:00", closed: false },
      sunday: { open: "10:00", close: "19:00", closed: false },
    };

    // Create new salon
    const newSalon = {
      salonName: salonName.trim(),
      ownerName: ownerName.trim(),
      email: email.toLowerCase(),
      phone: phone,
      hashedPassword,
      role: "salon",
      location: {
        type: "Point",
        coordinates: [parseFloat(longitude), parseFloat(latitude)],
        address: address.trim(),
        city: locationDetails?.city || "",
        state: locationDetails?.state || "",
        country: locationDetails?.country || "India",
        postcode: locationDetails?.postcode || "",
      },
      services: defaultServices,
      operatingHours: defaultOperatingHours,
      description: description || "",
      amenities: amenities || ["WiFi", "Air Conditioning", "Parking"],
      salonImages: salonImages || [],
      barbers: [],
      ratings: {
        overall: 0,
        serviceQuality: 0,
        timing: 0,
        ambience: 0,
        cleanliness: 0,
        totalReviews: 0,
      },
      stats: {
        totalBookings: 0,
        completedBookings: 0,
        repeatCustomers: 0,
        averageWaitTime: 0,
      },
      achievements: [],
      isVerified: false,
      isActive: true,
      createdAt: new Date(),
      updatedAt: new Date(),
    };

    const result = await salons.insertOne(newSalon);
    console.log("Creating salon with data:", newSalon);
    console.log("Salon created with ID:", result.insertedId);

    // CREATE BARBERS IF PROVIDED - ADD THIS SECTION
    let barbersCreatedCount = 0;
    let barberIds = [];

    if (barbers && barbers.length > 0) {
      console.log("Creating barbers for salon:", result.insertedId);

      try {
        const barberDocuments = barbers.map((barber) => ({
          salonId: result.insertedId, // Link to the salon
          name: barber.name || "",
          experience: parseInt(barber.experience) || 0,
          skills: Array.isArray(barber.skills) ? barber.skills : [],
          bio: barber.bio || "",
          photo: barber.photo || "",
          isAvailable: barber.isAvailable !== false, // Default to true
          workingHours: {
            start: "09:00",
            end: "21:00",
          },
          totalBookings: 0,
          rating: 5.0,
          accomplishments: [],
          earnings: 0,
          lastActiveAt: new Date(),
          createdAt: new Date(),
          updatedAt: new Date(),
        }));

        console.log("Inserting barbers:", barberDocuments);

        // Insert all barbers at once
        const barberResult = await barbersCollection.insertMany(
          barberDocuments
        );

        barbersCreatedCount = barberResult.insertedCount || 0;
        barberIds = Object.values(barberResult.insertedIds || {});

        console.log("Barbers created:", barbersCreatedCount);
        console.log("Barber IDs:", barberIds);

        // UPDATE SALON DOCUMENT WITH BARBER IDS
        console.log("Updating salon document with barber IDs...");
        const salonUpdateResult = await salons.updateOne(
          { _id: result.insertedId },
          {
            $set: {
              barbers: barberIds, // Add barber IDs to salon
              updatedAt: new Date(),
            },
          }
        );

        console.log("Salon update result:", salonUpdateResult);
      } catch (barberError) {
        console.error("Error creating barbers:", barberError);
        barbersCreatedCount = 0;
      }
    } else {
      console.log("No barbers provided");
    }

    // Generate JWT token
    const token = generateToken(result.insertedId, "salon", email);

    // Remove password from response
    const { hashedPassword: _, ...salonResponse } = newSalon;
    salonResponse._id = result.insertedId;
    console.log("Final barbersCreatedCount to send:", barbersCreatedCount);

    res.status(201).json({
      message: "Salon registered successfully",
      salon: salonResponse,
      barbersCreated: barbersCreatedCount, // ADD THIS LINE

      token,
    });
  } catch (error) {
    console.error("Salon registration error:", error);
    console.error("Salon registration error:", error.stack || error);
    res.status(500).json({ message: error.message || "Internal server error" });
  }
}
</file>

<file path="src/pages/api/auth/user/register.js">
import clientPromise from "../../../../lib/mongodb";
import { hashPassword, generateToken } from "../../../../lib/auth";

export default async function handler(req, res) {
  if (req.method !== "POST") {
    return res.status(405).json({ message: "Method not allowed" });
  }

  try {
    const { name, email, phone, gender, password, age, dateOfBirth, location } =
      req.body;

    // Validate required fields
    if (!name || !email || !phone || !gender || !password) {
      return res.status(400).json({
        message: "All fields are required",
        required: ["name", "email", "phone", "gender", "password"],
      });
    }

    // Validate email format
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    if (!emailRegex.test(email)) {
      return res.status(400).json({ message: "Invalid email format" });
    }

    // Validate phone format (Indian format)
    const phoneRegex = /^[6-9]\d{9}$/;
    if (!phoneRegex.test(phone)) {
      return res
        .status(400)
        .json({ message: "Invalid phone number. Use 10-digit Indian format" });
    }

    // Validate password strength
    if (password.length < 6) {
      return res
        .status(400)
        .json({ message: "Password must be at least 6 characters long" });
    }

    const client = await clientPromise;
    const db = client.db("techtrims");
    const users = db.collection("users");

    // Check if user already exists
    const existingUser = await users.findOne({
      $or: [{ email: email.toLowerCase() }, { phone: phone }],
    });

    if (existingUser) {
      return res.status(409).json({
        message: "User already exists with this email or phone number",
      });
    }

    // Hash password
    const hashedPassword = await hashPassword(password);

    // Create new user
    // Check for existing bookings by phone/name before creating user
    const existingBookings = await db
      .collection("bookings")
      .find({
        $or: [
          { customerPhone: phone },
          { customerName: { $regex: name, $options: "i" } },
        ],
      })
      .toArray();

    console.log(
      `Found ${existingBookings.length} existing bookings for this user`
    );

    const newUser = {
      name,
      email,
      phone,
      gender,
      age: age || null,
      dateOfBirth: dateOfBirth || null,
      location: location || null,
      role: "user",
      hashedPassword,
      bookingHistory: [],
      preferences: {},
      resetPasswordToken: null,
      resetPasswordExpires: null,
      createdAt: new Date(),
      updatedAt: new Date(),
      isActive: true,
    };
    const result = await db.collection("users").insertOne(newUser);

    // Update existing bookings with userId
    if (existingBookings.length > 0) {
      await db
        .collection("bookings")
        .updateMany(
          { _id: { $in: existingBookings.map((b) => b._id) } },
          { $set: { userId: result.insertedId } }
        );
      console.log(
        `Updated ${existingBookings.length} bookings with new userId`
      );
    }

    // Generate JWT token
    const token = generateToken(result.insertedId, "user", email);

    // Remove password from response
    const { hashedPassword: _, ...userResponse } = newUser;
    userResponse._id = result.insertedId;

    res.status(201).json({
      message: "User registered successfully",
      user: userResponse,
      token,
    });
  } catch (error) {
    console.error("User registration error:", error);
    res.status(500).json({ message: "Internal server error" });
  }
}
</file>

<file path="src/pages/api/bookings.js">
// pages/api/bookings.js
import { connectToDatabase, clientPromise } from "../../lib/mongodb";
import { ObjectId } from "mongodb";

/**
 * This version uses a MongoDB transaction (when available) to insert booking,
 * update salon, and create/find user atomically. It also publishes a simple
 * in-memory SSE notification for subscribed salon dashboards.
 */

// simple in-memory pubsub for SSE (dev only)
const subscribers = {}; // { salonId: [res, ...] }

function publishNotification(salonId, payload) {
  // store for any connected subscribers
  const list = subscribers[salonId] || [];
  list.forEach((res) => {
    try {
      res.write(`data: ${JSON.stringify(payload)}\n\n`);
    } catch (e) {
      // ignore writes errors
    }
  });
}

export default async function handler(req, res) {
  if (req.method !== "POST")
    return res.status(405).json({ message: "Method not allowed" });
  try {
    const body = req.body || {};
    const { salonId, service, barber, date, time, user } = body;

    if (!salonId || !service || !date || !time) {
      return res.status(400).json({ message: "Missing required fields" });
    }

    const { db, client } = await connectToDatabase();
    const session = client.startSession ? client.startSession() : null;
    let bookingId = null;
    let userId = null;

    const bookingDate = new Date(date);
    if (isNaN(bookingDate.getTime()))
      return res.status(400).json({ message: "Invalid date" });

    const bookingDoc = {
      salonId: ObjectId.isValid(salonId) ? new ObjectId(salonId) : salonId,
      service,
      barber: barber || null,
      date,
      time,
      customerName: user?.name || body.customerName || "Guest",
      customerPhone: user?.mobile || body.customerPhone || "Unknown",
      price: body.price || 0,
      paymentStatus: "pending",
      status: "confirmed",
      createdAt: new Date(),
    };

    const transactionFn = async (session) => {
      // double booking check inside transaction
      const existing = await db.collection("bookings").findOne(
        {
          salonId: bookingDoc.salonId,
          date,
          time,
          barber: bookingDoc.barber,
          status: { $ne: "cancelled" },
        },
        { session }
      );
      if (existing) throw new Error("Slot already booked");

      const insertResult = await db
        .collection("bookings")
        .insertOne(bookingDoc, { session });
      bookingId = insertResult.insertedId;

      // Create or find user - Enhanced user handling
      if (user && user.mobile) {
        let existingUser = await db
          .collection("users")
          .findOne({ mobile: user.mobile }, { session });
        if (!existingUser) {
          const newUser = {
            name: user.name || "Guest",
            mobile: user.mobile,
            email: user.email || null,
            gender: user.gender || "other",
            location: user.location || null,
            bookingHistory: [bookingId],
            preferences: user.preferences || {},
            createdAt: new Date(),
            updatedAt: new Date(),
            isActive: true,
          };
          const ur = await db
            .collection("users")
            .insertOne(newUser, { session });
          userId = ur.insertedId;
        } else {
          userId = existingUser._id;
          // Update existing user's booking history and preserve location data
          await db.collection("users").updateOne(
            { _id: userId },
            {
              $push: { bookingHistory: bookingId },
              $set: {
                updatedAt: new Date(),
                // Update location if new location data is provided
                ...(user.location && { location: user.location }),
              },
            },
            { session }
          );
        }

        // Always link booking to user
        await db
          .collection("bookings")
          .updateOne({ _id: bookingId }, { $set: { userId } }, { session });
      }

      // If userId from token is available, also link the booking
      if (body.userId) {
        await db
          .collection("bookings")
          .updateOne(
            { _id: bookingId },
            { $set: { userId: new ObjectId(body.userId) } },
            { session }
          );

        // Update user's booking history
        await db.collection("users").updateOne(
          { _id: new ObjectId(body.userId) },
          {
            $push: { bookingHistory: bookingId },
            $set: { updatedAt: new Date() },
          },
          { session }
        );
      }

      // update salon bookings array AND stats
      await db.collection("salons").updateOne(
        { _id: bookingDoc.salonId },
        {
          $push: {
            bookings: {
              id: bookingId,
              date,
              time,
              service,
              barber,
            },
          },
          $inc: { "stats.totalBookings": 1 },
          $set: { updatedAt: new Date() },
        },
        { session }
      );

      // Calculate and update repeat customers
      const repeatCustomers = await db.collection("bookings").distinct(
        "userId",
        {
          salonId: bookingDoc.salonId,
          userId: { $ne: null },
        },
        { session }
      );

      await db
        .collection("salons")
        .updateOne(
          { _id: bookingDoc.salonId },
          { $set: { "stats.repeatCustomers": repeatCustomers.length } },
          { session }
        );
    };

    if (session) {
      try {
        await session.withTransaction(async () => {
          await transactionFn(session);
        });
      } finally {
        await session.endSession();
      }
    } else {
      // fallback: not a replica set / no sessions available
      await transactionFn(null);
    }

    // Publish SSE notification (dev-time)
    try {
      publishNotification(String(salonId), {
        type: "new_booking",
        bookingId: String(bookingId),
        date,
        time,
        service,
        barber,
      });
    } catch (e) {
      console.warn("Publish failed", e.message);
    }

    return res.status(201).json({ bookingId, userId: userId || null });
  } catch (e) {
    if (e.message && e.message.includes("Slot already booked")) {
      return res.status(409).json({ message: "Slot already booked" });
    }
    console.error("Booking API error:", e);
    return res
      .status(500)
      .json({ message: e.message || "Internal server error" });
  }
}

// Expose a helper to allow SSE subscription (imported by /api/salon/notifications)
export function _subscribe(salonId, res) {
  subscribers[salonId] = subscribers[salonId] || [];
  subscribers[salonId].push(res);
  // Remove on close
  reqClose(res);
}

function reqClose(res) {
  res.on("close", () => {
    for (const sid of Object.keys(subscribers)) {
      subscribers[sid] = subscribers[sid].filter((r) => r !== res);
    }
  });
}
</file>

<file path="src/pages/api/salons/barbers/available.js">
// pages/api/salons/barbers/available.js
import clientPromise from "../../../../lib/mongodb";
import { ObjectId } from "mongodb";

export default async function handler(req, res) {
  if (req.method !== "GET") {
    return res.status(405).json({ error: "Method not allowed" });
  }

  const { salonId, service } = req.query;

  console.log("=== AVAILABLE BARBERS API (SALON-BASED) ===");
  console.log("SalonId:", salonId);
  console.log("Service requested:", service);

  if (!salonId) {
    return res.status(400).json({ error: "salonId required" });
  }

  try {
    const client = await clientPromise;
    const db = client.db("techtrims");

    // Convert salonId to ObjectId
    let salonObjectId;
    try {
      salonObjectId = new ObjectId(salonId);
    } catch (objIdError) {
      console.error("Invalid salonId format:", objIdError);
      return res.status(400).json({ error: "Invalid salonId format" });
    }

    // STEP 1: Get the salon and its barber IDs
    const salon = await db
      .collection("salons")
      .findOne(
        { _id: salonObjectId },
        { projection: { barbers: 1, salonName: 1 } }
      );

    if (!salon) {
      console.log("Salon not found");
      return res.status(404).json({ error: "Salon not found" });
    }

    console.log("Found salon:", salon.salonName);
    console.log("Salon barber IDs:", salon.barbers);

    if (!salon.barbers || salon.barbers.length === 0) {
      console.log("No barbers assigned to this salon");
      return res.status(200).json([]);
    }

    // STEP 2: Get barber details using the salon's barber array
    const barberObjectIds = salon.barbers.map((id) =>
      typeof id === "string" ? new ObjectId(id) : id
    );

    const barberQuery = {
      _id: { $in: barberObjectIds },
    };

    console.log("Barber query:", JSON.stringify(barberQuery, null, 2));

    const allBarbers = await db
      .collection("barbers")
      .find(barberQuery)
      .toArray();

    console.log("Found available barbers:", allBarbers.length);
    allBarbers.forEach((barber) => {
      console.log(
        `- ${barber.name}: skills = [${barber.skills?.join(", ") || "none"}]`
      );
    });

    // If no service specified, return all available barbers
    if (!service) {
      return res
        .status(200)
        .json(allBarbers.sort((a, b) => b.rating - a.rating));
    }

    // STEP 3: Filter by skills if service is specified
    const getMatchingSkills = (serviceName) => {
      const serviceMap = {
        haircut: ["Haircut"],
        Shave: ["Shaving"],
        HairStyling: ["Hair Styling"],
        HairColor: ["Hair Color"],
        Facial: ["Facial"],
        HairWash: ["Hair Wash"],
      };

      // Try exact match first
      if (serviceMap[serviceName]) {
        return serviceMap[serviceName];
      }

      // Try case-insensitive match
      const lowerService = serviceName.toLowerCase();
      for (const [key, skills] of Object.entries(serviceMap)) {
        if (key.toLowerCase() === lowerService) {
          return skills;
        }
      }

      return [serviceName];
    };

    const matchingSkills = getMatchingSkills(service);
    console.log(`Service "${service}" mapped to skills:`, matchingSkills);

    const filteredBarbers = allBarbers.filter((barber) => {
      if (!barber.skills || !Array.isArray(barber.skills)) {
        return false;
      }

      const hasMatchingSkill = barber.skills.some((skill) =>
        matchingSkills.some(
          (reqSkill) =>
            skill.toLowerCase().includes(reqSkill.toLowerCase()) ||
            reqSkill.toLowerCase().includes(skill.toLowerCase())
        )
      );

      console.log(
        `Barber ${barber.name} has matching skill for "${service}":`,
        hasMatchingSkill
      );
      return hasMatchingSkill;
    });

    // Return skilled barbers first, or all barbers if none skilled
    const result = filteredBarbers.length > 0 ? filteredBarbers : allBarbers;

    console.log("Returning barbers:", result.length);
    return res.status(200).json(result.sort((a, b) => b.rating - a.rating));
  } catch (err) {
    console.error("Available barbers API error:", err);
    return res.status(500).json({
      error: "Internal server error",
      details: err.message,
    });
  }
}
</file>

<file path="src/pages/api/salons/bookings.js">
import clientPromise from "../../../lib/mongodb";
import { ObjectId } from "mongodb";

export default async function handler(req, res) {
  if (req.method !== "GET") {
    return res.status(405).json({ message: "Method not allowed" });
  }

  try {
    const { salonId, date, from } = req.query;

    if (!salonId) {
      return res.status(400).json({ message: "Salon ID is required" });
    }

    const client = await clientPromise;
    const db = client.db("techtrims");

    const query = { salonId: new ObjectId(salonId) };

    // ✅ Include walk-ins (they don't have date field)
    if (date && date !== "all" && !req.query.includeWalkins) {
      query.date = date;
    } else if (date && date !== "all" && req.query.includeWalkins) {
      // For specific date, show both prebook for that date AND walk-ins
      query.$or = [
        { date: date },
        {
          bookingType: "WALKIN",
          createdAt: {
            $gte: new Date(date + "T00:00:00"),
            $lte: new Date(date + "T23:59:59"),
          },
        },
      ];
    }

    const bookings = await db
      .collection("bookings")
      .find(query)
      .sort({ createdAt: -1 })
      .toArray();

    // Format bookings with additional info
    const formattedBookings = bookings.map((booking) => ({
      ...booking,
      _id: booking._id.toString(),
      salonId: booking.salonId.toString(),
      userId: booking.userId?.toString(),
    }));

    res.status(200).json(formattedBookings);
  } catch (error) {
    console.error("Error fetching salon bookings:", error);
    res.status(500).json({ message: "Internal server error" });
  }
}
</file>

<file path="src/pages/api/salons/nearby.js">
import { connectToDatabase } from "../../../lib/mongodb";

export default async function handler(req, res) {
  if (req.method !== "GET") {
    return res.status(405).json({ message: "Method Not Allowed" });
  }

  const { latitude, longitude, radius = 30 } = req.query;

  if (!latitude || !longitude) {
    return res.status(400).json({ message: "latitude and longitude required" });
  }

  const lat = parseFloat(latitude);
  const lng = parseFloat(longitude);
  const radiusKm = parseFloat(radius);

  let retryCount = 0;
  const maxRetries = 3;

  while (retryCount < maxRetries) {
    try {
      const { db } = await connectToDatabase();

      console.log("=== DEBUGGING SALON SEARCH ===");
      console.log("Search coordinates:", { lat, lng });
      console.log("Search radius:", radiusKm, "km");

      // Get all salons with timeout
      const allSalons = await db
        .collection("salons")
        .find({})
        .maxTimeMS(30000)
        .toArray();

      console.log(`Found ${allSalons.length} total salons in database`);

      // Filter salons by distance
      const nearbySalons = [];

      for (const salon of allSalons) {
        if (
          !salon.location?.coordinates ||
          salon.location.coordinates.length !== 2
        ) {
          continue;
        }

        const [salonLng, salonLat] = salon.location.coordinates;

        if (isNaN(salonLat) || isNaN(salonLng)) {
          continue;
        }

        const distance = calculateDistance(lat, lng, salonLat, salonLng);

        if (distance <= radiusKm) {
          nearbySalons.push({
            ...salon,
            calculatedDistance: distance,
          });
        }
      }

      // Process salon data
      const processedSalons = nearbySalons.map((salon) => ({
        ...salon,
        id: salon._id.toString(),
        distance: Number(salon.calculatedDistance.toFixed(2)),
        topServices: salon.services
          ? Object.entries(salon.services)
              .filter(([key, service]) => service.enabled)
              .slice(0, 3)
              .map(([key, service]) => ({
                name: key,
                price: Number(service.price || 0),
              }))
          : [],
        stats: {
          ...salon.stats,
          totalBookings: Number(salon.stats?.totalBookings || 0),
          rating: Number(salon.stats?.rating || 4.5),
          totalRatings: Number(salon.stats?.totalRatings || 0),
        },
      }));

      processedSalons.sort((a, b) => a.distance - b.distance);

      return res.status(200).json({
        success: true,
        salons: processedSalons,
      });
    } catch (err) {
      console.error(`Attempt ${retryCount + 1} failed:`, err.message);
      retryCount++;

      if (retryCount >= maxRetries) {
        console.error("Max retries reached. Final error:", err);
        return res.status(500).json({
          message: "Database connection failed after retries",
          error: err.message,
        });
      }

      // Wait before retrying
      await new Promise((resolve) => setTimeout(resolve, 1000 * retryCount));
    }
  }
}

function calculateDistance(lat1, lon1, lat2, lon2) {
  const R = 6371;
  const dLat = ((lat2 - lat1) * Math.PI) / 180;
  const dLon = ((lon2 - lon1) * Math.PI) / 180;
  const a =
    Math.sin(dLat / 2) * Math.sin(dLat / 2) +
    Math.cos((lat1 * Math.PI) / 180) *
      Math.cos((lat2 * Math.PI) / 180) *
      Math.sin(dLon / 2) *
      Math.sin(dLon / 2);
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
  return R * c;
}
</file>

<file path="src/pages/salons/book.js">
// pages/salons/book.js
import { useRouter } from "next/router";
import { useState, useEffect } from "react";
import styles from "../../styles/Booking.module.css";

export default function BookingPage() {
  const router = useRouter();
  const { salonId, serviceId, serviceName, price } = router.query;

  const [mobile, setMobile] = useState("");
  const [barbers, setBarbers] = useState([]);
  const [selectedBarber, setSelectedBarber] = useState("");
  const [selectedDate, setSelectedDate] = useState("");
  const [selectedSlot, setSelectedSlot] = useState("");
  const [slots, setSlots] = useState([]);
  const [userInfo, setUserInfo] = useState(null);

  useEffect(() => {
    // Get user info from session
    const sessionData = sessionStorage.getItem("userSession");
    if (sessionData) {
      const userData = JSON.parse(sessionData);
      setUserInfo(userData);
    }

    // Fetch barbers
    fetchBarbers();
  }, []);

  useEffect(() => {
    if (selectedBarber && selectedDate) {
      fetchAvailableSlots();
    }
  }, [selectedBarber, selectedDate]);

  const fetchBarbers = async () => {
    // Mock data - in production, fetch from API
    setBarbers([
      {
        id: "1",
        name: "Raj Kumar",
        rating: 4.5,
        specialization: "Hair Styling",
        bookings: 1250,
      },
      {
        id: "2",
        name: "Amit Singh",
        rating: 4.8,
        specialization: "Beard Expert",
        bookings: 980,
      },
      {
        id: "3",
        name: "Priya Sharma",
        rating: 4.7,
        specialization: "Color Specialist",
        bookings: 850,
      },
    ]);
  };

  const fetchAvailableSlots = async () => {
    // Generate time slots
    const allSlots = [];
    for (let hour = 9; hour < 21; hour++) {
      for (let min = 0; min < 60; min += 30) {
        const time = `${hour.toString().padStart(2, "0")}:${min
          .toString()
          .padStart(2, "0")}`;
        allSlots.push({
          time,
          available: Math.random() > 0.3, // Mock availability
          waitTime: Math.floor(Math.random() * 15),
        });
      }
    }
    setSlots(allSlots);
  };

  const handleBooking = async () => {
    if (!mobile || !selectedBarber || !selectedDate || !selectedSlot) {
      alert("Please fill all required fields");
      return;
    }

    const bookingData = {
      salonId,
      serviceId,
      barberId: selectedBarber,
      date: selectedDate,
      timeSlot: selectedSlot,
      userDetails: {
        name: userInfo?.name || "Guest",
        mobile,
        gender: userInfo?.gender || "other",
      },
    };

    try {
      const response = await fetch("/api/bookings/create", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(bookingData),
      });

      if (response.ok) {
        const result = await response.json();
        // Show success and redirect to confirmation
        alert("Booking Confirmed!");
        const bookingId = result?.booking?.id || result?.bookingId;
        if (bookingId) router.push(`/bookings?id=${bookingId}`);
        else router.push("/bookings");
      } else {
        alert("Booking failed. Please try again.");
      }
    } catch (error) {
      console.error("Booking error:", error);
      alert("Something went wrong. Please try again.");
    }
  };

  return (
    <div className={styles.container}>
      <h1>Book Appointment</h1>
      <div className={styles.serviceInfo}>
        <h2>{serviceName}</h2>
        <span className={styles.price}>₹{price}</span>
      </div>

      <div className={styles.form}>
        <div className={styles.formGroup}>
          <label>📱 Mobile Number</label>
          <input
            type="tel"
            value={mobile}
            onChange={(e) => setMobile(e.target.value)}
            placeholder="Enter your mobile number"
            maxLength="10"
          />
        </div>

        <div className={styles.formGroup}>
          <label>👨‍🦱 Select Barber</label>
          <div className={styles.barberGrid}>
            {barbers.map((barber) => (
              <div
                key={barber.id}
                className={`${styles.barberCard} ${
                  selectedBarber === barber.id ? styles.selected : ""
                }`}
                onClick={() => setSelectedBarber(barber.id)}
              >
                <div className={styles.barberInfo}>
                  <h3>{barber.name}</h3>
                  <p>
                    ⭐ {barber.rating} | {barber.specialization}
                  </p>
                  <p>{barber.bookings} bookings</p>
                </div>
              </div>
            ))}
          </div>
        </div>

        <div className={styles.formGroup}>
          <label>📅 Select Date</label>
          <input
            type="date"
            value={selectedDate}
            onChange={(e) => setSelectedDate(e.target.value)}
            min={new Date().toISOString().split("T")[0]}
          />
        </div>

        {slots.length > 0 && (
          <div className={styles.formGroup}>
            <label>⏰ Select Time Slot</label>
            <div className={styles.slotGrid}>
              {slots.map((slot) => (
                <button
                  key={slot.time}
                  className={`${styles.slotBtn} 
                      ${!slot.available ? styles.unavailable : ""} 
                      ${selectedSlot === slot.time ? styles.selected : ""}`}
                  onClick={() => slot.available && setSelectedSlot(slot.time)}
                  disabled={!slot.available}
                >
                  {slot.time}
                  {slot.available && slot.waitTime > 0 && (
                    <span className={styles.waitTime}>
                      ~{slot.waitTime}min wait
                    </span>
                  )}
                </button>
              ))}
            </div>
          </div>
        )}

        <div className={styles.userDetails}>
          <p>Booking for: {userInfo?.name || "Guest"}</p>
          <p>Gender: {userInfo?.gender || "Not specified"}</p>
        </div>

        <button className={styles.confirmBtn} onClick={handleBooking}>
          Confirm Booking
        </button>
      </div>
    </div>
  );
}
</file>

<file path="src/styles/SalonMap.module.css">
.mapContainer {
  position: relative;
  height: 600px;
  width: 100%;
  border-radius: 20px;
  overflow: hidden;
  box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
}
/* CHANGE FROM: (doesn't exist)
/* CHANGE TO: */
.liveLocationBtn {
  position: absolute;
  bottom: 100px;
  right: 10px;
  z-index: 1000;
  background: white;
  border: 2px solid rgba(0, 0, 0, 0.2);
  border-radius: 8px;
  padding: 10px 15px;
  display: flex;
  align-items: center;
  gap: 8px;
  box-shadow: 0 2px 6px rgba(0, 0, 0, 0.15);
  cursor: pointer;
  font-weight: 600;
  transition: all 0.3s;
}

.liveLocationBtn:hover:not(:disabled) {
  background: #f59e0b;
  color: white;
  transform: scale(1.05);
}

.liveLocationBtn:disabled {
  opacity: 0.6;
  cursor: not-allowed;
}

.spinning {
  animation: spin 1s linear infinite;
}

@keyframes spin {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}

.custom-popup .leaflet-popup-content-wrapper {
  border-radius: 8px !important;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2) !important;
  padding: 0 !important;
  min-width: 50px !important;
  width: max-content !important;
  font-size: 14px;
}
@media (max-width: 768px) {
  .custom-popup .leaflet-popup-content-wrapper {
    max-width: 220px !important;
    font-size: 12px;
  }
}
.custom-popup .leaflet-popup-content {
  margin: 0 !important;
  padding: 0 !important;
  width: auto !important;
}
/* CHANGE FROM: (existing behavior)
/* CHANGE TO: */
.fixed-marker-icon,
.fixed-user-icon {
  transition: none !important;
  transform: none !important;
}

.leaflet-zoom-animated .fixed-marker-icon,
.leaflet-zoom-animated .fixed-user-icon {
  transform: translate3d(0, 0, 0) !important;
  will-change: transform;
}

.custom-popup .leaflet-popup-tip {
  background: white !important;
}

.map {
  height: 100%;
  width: 100%;
  z-index: 1;
}

.mapLoading {
  height: 600px;
  display: flex;
  align-items: center;
  justify-content: center;
  background: linear-gradient(45deg, #f3f4f6, #e5e7eb);
  border-radius: 20px;
  font-size: 18px;
  color: #6b7280;
}
/* Salon Popup Overlay */
.salonPopupOverlay {
  position: fixed;
  inset: 0;
  background: rgba(0, 0, 0, 0.7);
  z-index: 2000;
  display: flex;
  align-items: flex-end;
  justify-content: center;
}

.salonPopupCard {
  background: white;
  width: 100%;
  max-width: 500px;
  max-height: 85vh;
  overflow-y: auto;
  border-radius: 20px 20px 0 0;
  padding: 20px;
  position: relative;
  animation: slideUp 0.3s ease-out;
}

@media (min-width: 768px) {
  .salonPopupOverlay {
    align-items: center;
    justify-content: flex-start;
    padding-left: 20px;
  }

  .salonPopupCard {
    border-radius: 20px;
    max-width: 450px;
    max-height: 90vh;
    animation: slideInLeft 0.3s ease-out;
  }
}

@keyframes slideUp {
  from {
    transform: translateY(100%);
    opacity: 0;
  }
  to {
    transform: translateY(0);
    opacity: 1;
  }
}

@keyframes slideInLeft {
  from {
    transform: translateX(-100%);
    opacity: 0;
  }
  to {
    transform: translateX(0);
    opacity: 1;
  }
}

.popupClose {
  position: absolute;
  top: 15px;
  right: 15px;
  width: 35px;
  height: 35px;
  border-radius: 50%;
  border: none;
  background: rgba(0, 0, 0, 0.1);
  font-size: 24px;
  cursor: pointer;
  z-index: 10;
  transition: all 0.2s;
}

.popupClose:hover {
  background: rgba(0, 0, 0, 0.2);
  transform: scale(1.1);
}
.fixed-marker-icon,
.fixed-user-icon {
  transition: none !important;
}

.leaflet-zoom-animated .fixed-marker-icon,
.leaflet-zoom-animated .fixed-user-icon {
  will-change: transform;
}

/* Side Panel for Selected Salon */
.sidePanel {
  position: absolute;
  top: 20px;
  right: 20px;
  width: 350px;
  max-height: calc(100% - 40px);
  background: white;
  border-radius: 16px;
  box-shadow: 0 20px 40px rgba(0, 0, 0, 0.15);
  z-index: 1000;
  overflow-y: auto;
  animation: slideIn 0.3s ease-out;
}

@keyframes slideIn {
  from {
    transform: translateX(100%);
    opacity: 0;
  }
  to {
    transform: translateX(0);
    opacity: 1;
  }
}

.closeButton {
  position: absolute;
  top: 12px;
  right: 12px;
  width: 30px;
  height: 30px;
  border: none;
  background: rgba(0, 0, 0, 0.1);
  border-radius: 50%;
  font-size: 18px;
  font-weight: bold;
  cursor: pointer;
  z-index: 1001;
  transition: all 0.2s;
}

.closeButton:hover {
  background: rgba(0, 0, 0, 0.2);
  transform: scale(1.1);
}

/* Salon Card Styles */
.salonCard {
  background: white;
  border-radius: 16px;
  overflow: hidden;
}

.cardHeader {
  position: relative;
  height: 180px;
}

.salonImage {
  width: 100%;
  height: 100%;
  object-fit: cover;
}

.badges {
  position: absolute;
  top: 12px;
  left: 12px;
  display: flex;
  gap: 8px;
}

.badge {
  background: rgba(245, 158, 11, 0.9);
  color: white;
  padding: 4px 8px;
  border-radius: 12px;
  font-size: 12px;
  font-weight: 600;
  backdrop-filter: blur(10px);
}

.cardContent {
  padding: 20px;
}

.salonName {
  font-size: 20px;
  font-weight: 700;
  color: #1f2937;
  margin: 0 0 8px 0;
}

.address {
  color: #6b7280;
  font-size: 14px;
  margin: 0 0 16px 0;
  line-height: 1.4;
}

.stats {
  display: flex;
  gap: 16px;
  margin-bottom: 20px;
}

.stat {
  display: flex;
  align-items: center;
  gap: 4px;
  font-size: 14px;
  color: #374151;
}

.icon {
  font-size: 16px;
}

.services h4 {
  font-size: 16px;
  font-weight: 600;
  color: #1f2937;
  margin: 0 0 12px 0;
}

.serviceGrid {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 8px;
  margin-bottom: 20px;
}

.serviceItem {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 8px;
  background: #f9fafb;
  border-radius: 8px;
  border: 1px solid #e5e7eb;
}

.serviceIcon {
  font-size: 16px;
}

.serviceItem div {
  display: flex;
  flex-direction: column;
  gap: 2px;
}

.serviceName {
  font-size: 12px;
  font-weight: 500;
  color: #374151;
}

.servicePrice {
  font-size: 12px;
  font-weight: 700;
  color: #f59e0b;
}

.bookButton {
  width: 100%;
  background: linear-gradient(135deg, #f59e0b, #d97706);
  color: white;
  border: none;
  padding: 12px 24px;
  border-radius: 12px;
  font-size: 16px;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.3s;
}

.bookButton:hover {
  background: linear-gradient(135deg, #d97706, #b45309);
  transform: translateY(-2px);
  box-shadow: 0 8px 20px rgba(245, 158, 11, 0.3);
}

/* Popup Styles */
.popupContent {
  min-width: 200px;
  padding: 8px;
}

.popupContent strong {
  display: block;
  margin-bottom: 4px;
  color: #1f2937;
}

.popupContent p {
  margin: 4px 0;
  font-size: 13px;
  color: #6b7280;
}

.popupButton {
  background: #f59e0b;
  color: white;
  border: none;
  padding: 6px 12px;
  border-radius: 6px;
  font-size: 12px;
  font-weight: 600;
  cursor: pointer;
  margin-top: 8px;
  width: 100%;
  transition: background 0.2s;
}

.popupButton:hover {
  background: #d97706;
}

.userPopup {
  text-align: center;
  padding: 4px;
}

.userPopup strong {
  color: #3b82f6;
  font-size: 14px;
}

/* Dark mode support */
[data-theme="dark"] .salonCard,
[data-theme="dark"] .sidePanel {
  background: #1f2937;
  color: white;
}

[data-theme="dark"] .salonName {
  color: white;
}

[data-theme="dark"] .address {
  color: #9ca3af;
}

[data-theme="dark"] .stat {
  color: #d1d5db;
}

[data-theme="dark"] .services h4 {
  color: white;
}

[data-theme="dark"] .serviceItem {
  background: #374151;
  border-color: #4b5563;
}

[data-theme="dark"] .serviceName {
  color: #d1d5db;
}

[data-theme="dark"] .closeButton {
  background: rgba(255, 255, 255, 0.1);
  color: white;
}

[data-theme="dark"] .closeButton:hover {
  background: rgba(255, 255, 255, 0.2);
}

/* Responsive */
@media (max-width: 768px) {
  .sidePanel {
    width: calc(100% - 40px);
    height: 400px;
    top: auto;
    bottom: 20px;
    right: 20px;
    left: 20px;
  }

  .mapContainer {
    height: 500px;
  }

  .serviceGrid {
    grid-template-columns: 1fr;
  }
}
</file>

<file path="src/styles/User.module.css">
/* User Dashboard Styles */

.dashboard {
  display: flex;
  min-height: 100vh;
  background-color: var(--background-primary);
  color: var(--text-primary);
}

/* Sidebar Styles */
.sidebar {
  width: 280px;
  background: var(--background-secondary);
  border-right: 1px solid var(--border-color);
  padding: var(--space-8);
  display: flex;
  flex-direction: column;
  position: sticky;
  top: 0;
  height: 100vh;
  overflow-y: auto;
  transition: all var(--transition-luxury);
}

.userProfile {
  padding: var(--space-6);
  background: var(--background-primary);
  border: 1px solid var(--border-color);
  border-radius: var(--radius-xl);
  margin-bottom: var(--space-8);
  text-align: center;
  transition: all var(--transition-normal);
}

.userProfile h2 {
  font-family: var(--font-display);
  font-size: 1.5rem;
  color: var(--text-primary);
  margin-bottom: var(--space-2);
  font-weight: 700;
}

.userProfile p {
  color: var(--text-secondary);
  font-size: 0.875rem;
  word-break: break-word;
}

/* Navigation Styles */
.nav {
  display: flex;
  flex-direction: column;
  gap: var(--space-2);
  flex: 1;
  margin-bottom: var(--space-6);
}

.navItem {
  display: flex;
  align-items: center;
  gap: var(--space-3);
  padding: var(--space-4) var(--space-5);
  background: transparent;
  border: 1px solid transparent;
  border-radius: var(--radius-lg);
  color: var(--text-secondary);
  font-size: 0.9375rem;
  font-weight: 500;
  cursor: pointer;
  transition: all var(--transition-luxury);
  text-align: left;
  position: relative;
  overflow: hidden;
}

.navItem::before {
  content: "";
  position: absolute;
  left: 0;
  top: 0;
  width: 3px;
  height: 100%;
  background: linear-gradient(180deg, var(--primary), var(--primary-dark));
  transform: scaleY(0);
  transition: transform var(--transition-normal);
}

.navItem:hover {
  background: rgba(212, 175, 55, 0.05);
  color: var(--text-primary);
  border-color: var(--border-color);
  transform: translateX(4px);
}

.navItem.active {
  background: linear-gradient(
    135deg,
    rgba(212, 175, 55, 0.15),
    rgba(212, 175, 55, 0.05)
  );
  color: var(--primary);
  border-color: var(--primary);
  font-weight: 600;
}

.navItem.active::before {
  transform: scaleY(1);
}

.logoutButton {
  padding: var(--space-4) var(--space-5);
  background: transparent;
  border: 2px solid var(--error);
  border-radius: var(--radius-lg);
  color: var(--error);
  font-size: 0.9375rem;
  font-weight: 600;
  cursor: pointer;
  transition: all var(--transition-luxury);
  display: flex;
  align-items: center;
  justify-content: center;
  gap: var(--space-2);
}

.logoutButton:hover {
  background: var(--error);
  color: white;
  transform: translateY(-2px);
  box-shadow: 0 4px 12px rgba(239, 68, 68, 0.3);
}

/* Content Area */
.content {
  flex: 1;
  padding: var(--space-8);
  overflow-y: auto;
  background-color: var(--background-primary);
}

/* Overview Section */
.overview {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: var(--space-8);
}

.overview h1 {
  font-family: var(--font-display);
  font-size: 2.5rem;
  color: var(--text-primary);
  font-weight: 700;
}

.backLink {
  padding: var(--space-3) var(--space-6);
  background: linear-gradient(135deg, var(--primary), var(--primary-dark));
  color: var(--black);
  border-radius: var(--radius-lg);
  text-decoration: none;
  font-weight: 600;
  font-size: 0.875rem;
  transition: all var(--transition-luxury);
  box-shadow: var(--shadow-md);
}

.backLink:hover {
  transform: translateY(-2px);
  box-shadow: var(--shadow-xl), 0 0 20px rgba(212, 175, 55, 0.4);
}

/* Stats Grid */
.stats {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
  gap: var(--space-6);
  margin-bottom: var(--space-12);
}

.statCard {
  background: var(--background-secondary);
  border: 1px solid var(--border-color);
  border-radius: var(--radius-2xl);
  padding: var(--space-8);
  text-align: center;
  transition: all var(--transition-luxury);
  position: relative;
  overflow: hidden;
}

.statCard::before {
  content: "";
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 2px;
  background: linear-gradient(90deg, transparent, var(--primary), transparent);
  opacity: 0;
  transition: opacity var(--transition-normal);
}

.statCard:hover {
  transform: translateY(-6px) scale(1.02);
  box-shadow: var(--shadow-luxury);
  border-color: var(--primary);
}

.statCard:hover::before {
  opacity: 1;
}

.statCard h3 {
  font-size: 0.875rem;
  color: var(--text-secondary);
  text-transform: uppercase;
  letter-spacing: 0.5px;
  margin-bottom: var(--space-3);
  font-weight: 600;
  font-family: var(--font-body);
}

.statCard p {
  font-family: var(--font-display);
  font-size: 2.5rem;
  font-weight: 700;
  background: linear-gradient(135deg, var(--primary), var(--primary-dark));
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
}

/* Recent Section */
.recentSection {
  margin-top: var(--space-10);
}

.recentSection h2 {
  font-family: var(--font-display);
  font-size: 1.875rem;
  color: var(--text-primary);
  margin-bottom: var(--space-6);
  font-weight: 700;
}

/* Bookings Section */
.bookings h1,
.payments h1,
.feedback h1,
.profile h1 {
  font-family: var(--font-display);
  font-size: 2.5rem;
  color: var(--text-primary);
  margin-bottom: var(--space-8);
  font-weight: 700;
}

.bookingsList,
.paymentsList,
.feedbackList {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(380px, 1fr));
  gap: var(--space-6);
}

/* Booking Card */
.bookingCard {
  background: var(--background-secondary);
  border: 1px solid var(--border-color);
  border-radius: var(--radius-2xl);
  padding: var(--space-8);
  transition: all var(--transition-luxury);
  position: relative;
  overflow: hidden;
}

.bookingCard::before {
  content: "";
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 2px;
  background: linear-gradient(90deg, transparent, var(--primary), transparent);
  opacity: 0;
  transition: opacity var(--transition-normal);
}

.bookingCard:hover {
  transform: translateY(-4px);
  box-shadow: var(--shadow-luxury);
  border-color: var(--primary);
}

.bookingCard:hover::before {
  opacity: 1;
}

.bookingHeader {
  display: flex;
  justify-content: space-between;
  align-items: flex-start;
  margin-bottom: var(--space-5);
}

.bookingHeader h3 {
  font-family: var(--font-display);
  font-size: 1.5rem;
  color: var(--text-primary);
  font-weight: 700;
  flex: 1;
}

.statusBadge {
  padding: var(--space-2) var(--space-4);
  border-radius: var(--radius-full);
  font-size: 0.75rem;
  font-weight: 700;
  text-transform: uppercase;
  letter-spacing: 0.5px;
}

.statusBadge.confirmed {
  background: rgba(16, 185, 129, 0.15);
  color: var(--success);
  border: 1px solid var(--success);
}

.statusBadge.completed {
  background: rgba(59, 130, 246, 0.15);
  color: var(--info);
  border: 1px solid var(--info);
}

.statusBadge.pending {
  background: rgba(245, 158, 11, 0.15);
  color: var(--warning);
  border: 1px solid var(--warning);
}

.statusBadge.cancelled {
  background: rgba(239, 68, 68, 0.15);
  color: var(--error);
  border: 1px solid var(--error);
}

.bookingDetails p {
  color: var(--text-secondary);
  margin-bottom: var(--space-3);
  font-size: 0.9375rem;
  display: flex;
  align-items: center;
  gap: var(--space-2);
}

.bookingDetails strong {
  color: var(--text-primary);
  font-weight: 600;
}

.feedbackButton {
  margin-top: var(--space-5);
  width: 100%;
  padding: var(--space-4);
  background: linear-gradient(135deg, var(--primary), var(--primary-dark));
  color: var(--black);
  border: none;
  border-radius: var(--radius-lg);
  font-weight: 600;
  font-size: 0.9375rem;
  cursor: pointer;
  transition: all var(--transition-luxury);
  display: flex;
  align-items: center;
  justify-content: center;
  gap: var(--space-2);
}

.feedbackButton:hover {
  transform: translateY(-2px);
  box-shadow: var(--shadow-xl), 0 0 20px rgba(212, 175, 55, 0.4);
}

/* Payment Card */
.paymentCard {
  background: var(--background-secondary);
  border: 1px solid var(--border-color);
  border-radius: var(--radius-2xl);
  padding: var(--space-8);
  transition: all var(--transition-luxury);
}

.paymentCard:hover {
  transform: translateY(-4px);
  box-shadow: var(--shadow-luxury);
  border-color: var(--primary);
}

.paymentHeader {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: var(--space-5);
}

.paymentHeader h3 {
  font-family: var(--font-display);
  font-size: 2rem;
  color: var(--primary);
  font-weight: 700;
}

.paymentDetails p {
  color: var(--text-secondary);
  margin-bottom: var(--space-3);
  font-size: 0.9375rem;
}

.paymentDetails strong {
  color: var(--text-primary);
  font-weight: 600;
}

/* Feedback Card */
.feedbackCard {
  background: var(--background-secondary);
  border: 1px solid var(--border-color);
  border-radius: var(--radius-2xl);
  padding: var(--space-8);
  transition: all var(--transition-luxury);
}

.feedbackCard:hover {
  transform: translateY(-4px);
  box-shadow: var(--shadow-luxury);
  border-color: var(--primary);
}

.feedbackHeader {
  display: flex;
  justify-content: space-between;
  align-items: flex-start;
  margin-bottom: var(--space-5);
}

.feedbackHeader h3 {
  font-family: var(--font-display);
  font-size: 1.5rem;
  color: var(--text-primary);
  font-weight: 700;
}

.rating {
  display: flex;
  align-items: center;
  gap: var(--space-2);
}

.rating span {
  font-size: 1.125rem;
  font-weight: 700;
  color: var(--primary);
}

.feedbackDetails p {
  color: var(--text-secondary);
  margin-bottom: var(--space-3);
  font-size: 0.9375rem;
}

.feedbackDetails strong {
  color: var(--text-primary);
  font-weight: 600;
}

.comment {
  margin-top: var(--space-5);
  padding: var(--space-5);
  background: var(--background-primary);
  border-left: 3px solid var(--primary);
  border-radius: var(--radius-md);
}

.comment p:first-child {
  margin-bottom: var(--space-2);
  color: var(--text-primary);
}

.comment p:last-child {
  font-style: italic;
  color: var(--text-secondary);
}

/* Profile Section */
.profileCard {
  background: var(--background-secondary);
  border: 1px solid var(--border-color);
  border-radius: var(--radius-2xl);
  padding: var(--space-10);
  max-width: 600px;
  transition: all var(--transition-luxury);
}

.profileCard:hover {
  box-shadow: var(--shadow-luxury);
  border-color: var(--primary);
}

.profileForm {
  display: flex;
  flex-direction: column;
  gap: var(--space-6);
  margin-bottom: var(--space-8);
}

.formGroup {
  display: flex;
  flex-direction: column;
  gap: var(--space-2);
}

.formGroup label {
  font-weight: 600;
  color: var(--text-primary);
  font-size: 0.875rem;
  text-transform: uppercase;
  letter-spacing: 0.5px;
}

.formGroup input {
  padding: var(--space-4);
  background: var(--background-primary);
  border: 2px solid var(--border-color);
  border-radius: var(--radius-lg);
  color: var(--text-primary);
  font-size: 1rem;
  transition: all var(--transition-normal);
}

.formGroup input:focus {
  outline: none;
  border-color: var(--primary);
  box-shadow: 0 0 0 3px rgba(212, 175, 55, 0.1);
}

.formGroup input[readonly] {
  background: var(--background-tertiary);
  cursor: not-allowed;
  opacity: 0.7;
}

.profileActions {
  text-align: center;
}

.note {
  color: var(--text-secondary);
  font-size: 0.9375rem;
  font-style: italic;
}

/* Empty State */
.emptyState {
  text-align: center;
  padding: var(--space-16) var(--space-8);
}

.emptyState p {
  font-size: 1.125rem;
  color: var(--text-secondary);
  margin-bottom: var(--space-6);
}

.bookNowButton {
  padding: var(--space-4) var(--space-8);
  background: linear-gradient(135deg, var(--primary), var(--primary-dark));
  color: var(--black);
  border: none;
  border-radius: var(--radius-lg);
  font-weight: 600;
  font-size: 1rem;
  cursor: pointer;
  transition: all var(--transition-luxury);
}

.bookNowButton:hover {
  transform: translateY(-2px);
  box-shadow: var(--shadow-xl), 0 0 20px rgba(212, 175, 55, 0.4);
}

.noData {
  color: var(--text-secondary);
  font-size: 0.9375rem;
  text-align: center;
  padding: var(--space-8);
}

.noData a {
  color: var(--primary);
  text-decoration: underline;
  font-weight: 600;
}

/* Loading State */
.loading {
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  min-height: 100vh;
  background-color: var(--background-primary);
  color: var(--text-primary);
}

.loading p {
  margin-top: var(--space-4);
  font-size: 1.125rem;
  color: var(--text-secondary);
}

/* Error State */
.error {
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  min-height: 100vh;
  background-color: var(--background-primary);
  padding: var(--space-8);
}

.error p {
  color: var(--error);
  font-size: 1.125rem;
  margin-bottom: var(--space-6);
  text-align: center;
}

.error button {
  padding: var(--space-4) var(--space-8);
  background: var(--error);
  color: white;
  border: none;
  border-radius: var(--radius-lg);
  font-weight: 600;
  cursor: pointer;
  transition: all var(--transition-luxury);
}

.error button:hover {
  transform: translateY(-2px);
  box-shadow: 0 4px 12px rgba(239, 68, 68, 0.3);
}
.badges {
  display: flex;
  gap: 8px;
  flex-wrap: wrap;
}

.typeBadge {
  padding: 4px 12px;
  border-radius: 12px;
  font-size: 12px;
  font-weight: 600;
}

.typeBadge.walkin {
  background: #e8f5e9;
  color: #2e7d32;
  border: 1px solid #4caf50;
}

.typeBadge.prebook {
  background: #e3f2fd;
  color: #1565c0;
  border: 1px solid #2196f3;
}

/* Responsive Design */
@media (max-width: 1024px) {
  .sidebar {
    width: 240px;
  }

  .bookingsList,
  .paymentsList,
  .feedbackList {
    grid-template-columns: 1fr;
  }

  .stats {
    grid-template-columns: repeat(2, 1fr);
  }
}

@media (max-width: 768px) {
  .dashboard {
    flex-direction: column;
  }

  .sidebar {
    width: 100%;
    height: auto;
    position: static;
    border-right: none;
    border-bottom: 1px solid var(--border-color);
    padding: var(--space-6);
  }

  .nav {
    flex-direction: row;
    overflow-x: auto;
    margin-bottom: var(--space-4);
  }

  .navItem {
    flex-shrink: 0;
    white-space: nowrap;
  }

  .content {
    padding: var(--space-6);
  }

  .overview {
    flex-direction: column;
    gap: var(--space-4);
    align-items: flex-start;
  }

  .overview h1 {
    font-size: 2rem;
  }

  .stats {
    grid-template-columns: 1fr;
  }

  .bookingsList,
  .paymentsList,
  .feedbackList {
    grid-template-columns: 1fr;
  }

  .profileCard {
    max-width: 100%;
  }
}

@media (max-width: 480px) {
  .sidebar {
    padding: var(--space-4);
  }

  .content {
    padding: var(--space-4);
  }

  .overview h1,
  .bookings h1,
  .payments h1,
  .feedback h1,
  .profile h1 {
    font-size: 1.75rem;
  }

  .statCard {
    padding: var(--space-6);
  }

  .statCard p {
    font-size: 2rem;
  }

  .bookingCard,
  .paymentCard,
  .feedbackCard {
    padding: var(--space-6);
  }

  .profileCard {
    padding: var(--space-6);
  }
}

/* Dark Mode Specific Adjustments */
[data-theme="dark"] .sidebar {
  background: var(--gray-800);
  border-color: var(--gray-700);
}

[data-theme="dark"] .userProfile {
  background: var(--gray-900);
  border-color: var(--gray-700);
}

[data-theme="dark"] .statCard,
[data-theme="dark"] .bookingCard,
[data-theme="dark"] .paymentCard,
[data-theme="dark"] .feedbackCard,
[data-theme="dark"] .profileCard {
  background: var(--gray-800);
  border-color: var(--gray-700);
}

[data-theme="dark"] .comment {
  background: var(--gray-900);
}

[data-theme="dark"] .formGroup input {
  background: var(--gray-900);
  border-color: var(--gray-700);
  color: var(--white);
}

[data-theme="dark"] .formGroup input[readonly] {
  background: var(--gray-800);
}
</file>

<file path="src/components/Maps/SalonMap.js">
//pages/src/components/Maps/SalonMap.js
import React, { useEffect, useRef, useState, useMemo } from "react";
import { useRouter } from "next/router";
import { MapContainer, TileLayer, Marker, Popup, useMap } from "react-leaflet";
import { Navigation } from "lucide-react";
import L from "leaflet";
import "leaflet/dist/leaflet.css";
import styles from "../../styles/SalonMap.module.css";
// import SalonCard from "../Salon/SalonCard";

// Fix for default markers in react-leaflet
delete L.Icon.Default.prototype._getIconUrl;
L.Icon.Default.mergeOptions({
  iconRetinaUrl:
    "https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.7.1/images/marker-icon-2x.png",
  iconUrl:
    "https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.7.1/images/marker-icon.png",
  shadowUrl:
    "https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.7.1/images/marker-shadow.png",
});

// Custom salon marker icon
const salonIcon = new L.Icon({
  iconUrl:
    "data:image/svg+xml;base64," +
    btoa(`
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="#f59e0b" width="30" height="30">
      <path d="M12 2C8.13 2 5 5.13 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.87-3.13-7-7-7zm0 9.5c-1.38 0-2.5-1.12-2.5-2.5s1.12-2.5 2.5-2.5 2.5 1.12 2.5 2.5-1.12 2.5-2.5 2.5z"/>
    </svg>
  `),
  iconSize: [35, 35], // Fixed size
  iconAnchor: [17.5, 35],
  popupAnchor: [0, -35],
  className: "fixed-marker-icon",
});

// User location marker
const userIcon = new L.Icon({
  iconUrl: "/maps/usericon.png", // Put your icon here
  iconSize: [25, 25], // Fixed size
  iconAnchor: [12.5, 12.5],
  className: "fixed-user-icon",
});

const SalonCard = ({
  salon,
  userLocation,
  selectedSalon,
  onSalonSelect,
  onBookNow,
  userGender,
}) => {
  const getGenderServices = (gender) => {
    const maleServices = [
      { name: "Haircut", price: 200, icon: "✂️" },
      { name: "Beard Trim", price: 150, icon: "🧔" },
      { name: "Hair Styling", price: 250, icon: "💇‍♂️" },
      { name: "Face Cleanup", price: 300, icon: "🧴" },
    ];

    const femaleServices = [
      { name: "Haircut & Style", price: 400, icon: "💇‍♀️" },
      { name: "Hair Coloring", price: 800, icon: "🎨" },
      { name: "Facial Treatment", price: 600, icon: "✨" },
      { name: "Manicure", price: 350, icon: "💅" },
    ];

    return gender === "Male" ? maleServices : femaleServices;
  };

  const services =
    salon.topServices?.length > 0
      ? salon.topServices.slice(0, 4)
      : getGenderServices(userGender).slice(0, 4);

  return (
    <div className={styles.salonCard}>
      <div className={styles.cardHeader}>
        <img
          src={
            typeof salon.salonImages?.[0] === "string"
              ? salon.salonImages[0]
              : salon.salonImages?.[0]?.url ||
                "https://images.unsplash.com/photo-1560066984-138dadb4c035?w=300&h=200&fit=crop"
          }
          alt={salon.salonName}
          className={styles.salonImage}
        />
        <div className={styles.badges}>
          {salon.distance < 2 && (
            <span className={styles.badge}>Very Close</span>
          )}
          {salon.isVerified && <span className={styles.badge}>Verified</span>}
        </div>
      </div>

      <div className={styles.cardContent}>
        <h3 className={styles.salonName}>{salon.salonName}</h3>
        <p className={styles.address}>{salon.location.address}</p>

        <div className={styles.stats}>
          <div className={styles.stat}>
            <span className={styles.icon}>⭐</span>
            <span>
              {(salon.ratings?.overall ?? salon.rating ?? 4.5).toFixed(1)}
            </span>
          </div>
          <div className={styles.stat}>
            <span className={styles.icon}>📍</span>
            <span>{salon.distance?.toFixed(1) || "1.2"} km</span>
          </div>
          <div className={styles.stat}>
            <span className={styles.icon}>👥</span>
            <span>{salon.stats?.totalBookings || 0} bookings</span>
          </div>
        </div>

        <div className={styles.services}>
          <h4>Popular Services</h4>
          <div className={styles.serviceGrid}>
            {services.map((service, idx) => (
              <div key={idx} className={styles.serviceItem}>
                <span className={styles.serviceIcon}>
                  {service.icon || "✂️"}
                </span>
                <div>
                  <span className={styles.serviceName}>{service.name}</span>
                  <span className={styles.servicePrice}>₹{service.price}</span>
                </div>
              </div>
            ))}
          </div>
        </div>

        <button
          className={styles.bookButton}
          onClick={() => onBookNow(salon._id)}
        >
          Book Now
        </button>
      </div>
    </div>
  );
};

const MapUpdater = ({ selectedSalon, salons }) => {
  const map = useMap();

  useEffect(() => {
    if (selectedSalon) {
      const salon = salons.find((s) => s._id === selectedSalon);
      if (salon && salon.location?.coordinates) {
        map.setView(
          [salon.location.coordinates[1], salon.location.coordinates[0]],
          16
        );
      }
    }
  }, [selectedSalon, salons, map]);

  return null;
};

// const AutoOpenPopup = ({ children, position, ...props }) => {
//   const map = useMap();

//   const popupOptions = useMemo(() => props, [props]);

//   useEffect(() => {
//     const marker = L.marker(position, { icon: salonIcon }).addTo(map);
//     const popup = L.popup(popupOptions).setContent(children);
//     marker.bindPopup(popup).openPopup();

//     return () => {
//       map.removeLayer(marker);
//     };
//   }, [map, position, children, popupOptions]);

//   return null;
// };
// Live Location Control Component
const LiveLocationControl = ({ userLocation, map }) => {
  const [locating, setLocating] = useState(false);

  const centerOnUser = () => {
    if (userLocation?.lat && userLocation?.lng && map) {
      setLocating(true);
      map.flyTo([userLocation.lat, userLocation.lng], 16, {
        animate: true,
        duration: 1.5,
      });
      setTimeout(() => setLocating(false), 1500);
    } else {
      // Request live location
      if (navigator.geolocation) {
        setLocating(true);
        navigator.geolocation.getCurrentPosition(
          (position) => {
            const newPos = [
              position.coords.latitude,
              position.coords.longitude,
            ];
            map.flyTo(newPos, 16, { animate: true, duration: 1.5 });
            setTimeout(() => setLocating(false), 1500);
          },
          (error) => {
            alert("Unable to get location");
            setLocating(false);
          }
        );
      }
    }
  };

  return (
    <button
      className={styles.liveLocationBtn}
      onClick={centerOnUser}
      disabled={locating}
      title="Center on my location"
    >
      <span className={locating ? styles.spinning : ""}>📍</span>
      {locating ? "Locating..." : "My Location"}
    </button>
  );
};

const SalonMap = ({
  salons,
  userLocation,
  selectedSalon,
  onSalonSelect,
  onBookNow,
  userGender,
}) => {
  const [mapLoaded, setMapLoaded] = useState(false);
  const selectedSalonData = salons.find((s) => s._id === selectedSalon);
  const router = useRouter();
  const [mapTheme, setMapTheme] = useState("standard");
  const [selectedSalonPopup, setSelectedSalonPopup] = useState(null);
  const [mapInstance, setMapInstance] = useState(null);
  const [mapRef, setMapRef] = useState(null);

  const mapThemes = {
    standard: {
      url: "https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png",
      name: "Standard",
    },
    dark: {
      url: "https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png",
      name: "Dark",
    },
    light: {
      url: "https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png",
      name: "Light",
    },
    satellite: {
      url: "https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}",
      name: "Satellite",
    },
    terrain: {
      url: "https://stamen-tiles-{s}.a.ssl.fastly.net/terrain/{z}/{x}/{y}{r}.png",
      name: "Terrain",
    },
  };

  const defaultCenter =
    userLocation?.lat && userLocation?.lng
      ? [userLocation.lat, userLocation.lng]
      : [19.076, 72.8777]; // Mumbai default
  const ThemeSelector = () => (
    <div className="absolute top-4 right-4 z-[1000] bg-white rounded-lg shadow-lg p-2 text-black">
      <select
        value={mapTheme}
        onChange={(e) => setMapTheme(e.target.value)}
        className="text-sm border rounded px-2 py-1 focus:outline-none focus:ring-2 focus:ring-blue-500"
      >
        {Object.entries(mapThemes).map(([key, theme]) => (
          <option key={key} value={key}>
            {theme.name}
          </option>
        ))}
      </select>
    </div>
  );
  // Add this component inside the MapContainer, after TileLayer
  const PopupOpener = ({ salons }) => {
    const map = useMap();

    useEffect(() => {
      const timer = setTimeout(() => {
        map.eachLayer((layer) => {
          if (layer instanceof L.Marker && layer.getPopup()) {
            layer.openPopup();
          }
        });
      }, 100);

      return () => clearTimeout(timer);
    }, [map, salons]);

    return null;
  };

  return (
    <div className={styles.mapContainer}>
      <ThemeSelector />
      <MapContainer
        center={defaultCenter}
        zoom={15}
        maxZoom={20}
        className={styles.map}
        ref={setMapRef}
        whenReady={(map) => setMapRef(map.target)}
        whenCreated={setMapInstance}
      >
        <TileLayer
          url={mapThemes[mapTheme].url}
          attribution="&copy; Map Data"
        />
        <PopupOpener salons={salons} />
        <MapUpdater selectedSalon={selectedSalon} salons={salons} />

        {/* User location marker */}
        {userLocation?.lat && userLocation?.lng && (
          <Marker
            position={[userLocation.lat, userLocation.lng]}
            icon={userIcon}
          >
            <Popup>
              <div className={styles.userPopup}>
                <strong>Your Location</strong>
              </div>
            </Popup>
          </Marker>
        )}

        {/* Salon markers with always-open popups */}
        {salons.map((salon) => (
          <Marker
            key={salon._id}
            position={[
              salon.location.coordinates[1],
              salon.location.coordinates[0],
            ]}
            icon={salonIcon}
            eventHandlers={{
              click: () => onSalonSelect(salon),
            }}
          >
            <Popup
              autoClose={false}
              closeButton={false}
              closeOnClick={false}
              closeOnEscapeKey={false}
              autoPan={false}
              className="custom-popup"
            >
              <div className="text-center p-2 min-w-[20px]">
                <h3 className="font-bold text-sm mb-1">{salon.salonName}</h3>
                <p className="text-xs font-medium text-blue-600 ">
                  {salon.distance?.toFixed(1)}km away
                </p>
                <div className="flex flex-col gap-1">
                  <button
                    className="text-xs bg-orange-500 text-white rounded px-4 py-1 font-medium hover:bg-orange-600"
                    onClick={(e) => {
                      e.stopPropagation();
                      setSelectedSalonPopup(salon);
                    }}
                  >
                    View Details
                  </button>
                  <button
                    className="text-xs bg-blue-500 text-white rounded px-2 py-1 font-medium hover:bg-blue-600"
                    onClick={(e) => {
                      e.stopPropagation();
                      window.open(
                        `https://maps.google.com/maps?daddr=${salon.location.coordinates[1]},${salon.location.coordinates[0]}`
                      );
                    }}
                  >
                    Get Directions
                  </button>
                </div>
              </div>
            </Popup>
          </Marker>
        ))}

        {salons.map((salon) => (
          <Marker
            key={`marker-${salon._id}`}
            position={[
              salon.location.coordinates[1],
              salon.location.coordinates[0],
            ]}
            icon={salonIcon}
            eventHandlers={{
              click: () => onSalonSelect(salon),
            }}
          />
        ))}
      </MapContainer>
      {userLocation && mapRef && (
        <LiveLocationControl userLocation={userLocation} map={mapRef} />
      )}
      {/* Salon Details Card */}
      {selectedSalonPopup && (
        <div
          className={styles.salonPopupOverlay}
          onClick={() => setSelectedSalonPopup(null)}
        >
          <div
            className={styles.salonPopupCard}
            onClick={(e) => e.stopPropagation()}
          >
            <button
              className={styles.popupClose}
              onClick={() => setSelectedSalonPopup(null)}
            >
              ×
            </button>
            <SalonCard
              salon={selectedSalonPopup}
              userLocation={userLocation}
              onSalonSelect={onSalonSelect}
              onBookNow={onBookNow}
              userGender={userGender}
            />
          </div>
        </div>
      )}
    </div>
  );
};

export default SalonMap;
</file>

<file path="src/components/Salon/SalonCard.js">
import { useRouter } from "next/router";
import styles from "../../styles/SalonCard.module.css";
import Image from "next/image";

export default function SalonCard({ salon, gender }) {
  const router = useRouter();
  if (!salon) {
    return null; // or return a loading/error placeholder
  }

  const handleBookNow = () => {
    router.push({ pathname: "/salons/[id]", query: { id: salon.id } });
  };

  return (
    <div className={styles.card}>
      <div className={styles.imageContainer}>
        <Image
          src={salon.images?.front || "/salon-placeholder.jpg"}
          alt={salon.name}
        />
        <div className={styles.popularityBadge}>
          {salon.totalBookings > 100 && "🔥 Most Booked"}
        </div>
      </div>

      <div className={styles.content}>
        <h3>{salon.name}</h3>

        <div className={styles.metrics}>
          <span>⭐ {salon.rating}/5</span>
          <span>📍 {salon.location?.distance || "1.2"} km</span>
          <span>🎯 {salon.customerServiceScore}% satisfaction</span>
        </div>

        <div className={styles.services}>
          <h4>Popular Services</h4>
          <div className={styles.serviceList}>
            {salon.topServices?.map((service, index) => (
              <div key={index} className={styles.serviceItem}>
                <span>{service.name}</span>
                <span className={styles.price}>₹{service.price}</span>
              </div>
            ))}
          </div>
        </div>

        <button onClick={handleBookNow} className={styles.bookBtn}>
          Book Now →
        </button>
      </div>
    </div>
  );
}
</file>

<file path="src/lib/userData.js">
// lib/userData.js
export class UserDataManager {
  static getStoredUserData() {
    if (typeof window === "undefined") return null;

    try {
      // First try to get authenticated user data
      const userToken = localStorage.getItem("userToken");
      if (userToken) {
        const storedUserData = localStorage.getItem("authenticatedUserData");
        if (storedUserData) {
          const userData = JSON.parse(storedUserData);
          // Always preserve onboarding location data for authenticated users
          const onboardingData = localStorage.getItem("userOnboardingData");
          if (onboardingData) {
            try {
              const onboarding = JSON.parse(onboardingData);
              return {
                ...userData,
                location: onboarding.location || userData.location,
                preferences: {
                  ...userData.preferences,
                  ...onboarding.preferences,
                },
              };
            } catch (e) {
              return userData;
            }
          }
          return userData;
        }
      }

      // Fallback to onboarding data
      const onboardingData = localStorage.getItem("userOnboardingData");
      if (onboardingData) return JSON.parse(onboardingData);

      return null;
    } catch (error) {
      console.error("Error getting stored user data:", error);
      return null;
    }
  }

  static async fetchAndStoreUserData() {
    if (typeof window === "undefined") return null;

    const userToken = localStorage.getItem("userToken");
    if (!userToken) return this.getStoredUserData();

    try {
      const response = await fetch("/api/user/profile", {
        headers: { Authorization: `Bearer ${userToken}` },
      });

      if (response.ok) {
        const userData = await response.json();
        console.log("API user data:", userData);

        // Always merge with onboarding data to preserve location and other fields
        const onboardingData = localStorage.getItem("userOnboardingData");
        console.log("Raw onboarding data:", onboardingData);

        let mergedData = userData;
        if (onboardingData) {
          try {
            const onboarding = JSON.parse(onboardingData);
            console.log("Parsed onboarding data:", onboarding);

            // Merge onboarding data with user data properly
            mergedData = {
              ...userData,
              // Always preserve onboarding location and other critical data
              location: onboarding.location || userData.location,
              gender: userData.gender || onboarding.gender,
              age: userData.age || onboarding.age || null,
              dateOfBirth:
                userData.dateOfBirth || onboarding.dateOfBirth || null,
              phoneNumber:
                userData.phoneNumber ||
                userData.phone ||
                onboarding.phoneNumber,
              phone: userData.phone || onboarding.phoneNumber,
              mobile: userData.mobile || onboarding.phoneNumber,
              preferences: {
                ...userData.preferences,
                ...onboarding.preferences,
              },
            };
            console.log("Merged data result:", mergedData);
          } catch (parseError) {
            console.error("Error parsing onboarding data:", parseError);
            mergedData = userData;
          }
        }

        // Store the merged data
        localStorage.setItem(
          "authenticatedUserData",
          JSON.stringify(mergedData)
        );

        // Update booking history after login
        await this.syncBookingHistory();

        return mergedData;
      } else {
        // If API fails, return stored data
        return this.getStoredUserData();
      }
    } catch (error) {
      console.error("Error fetching user data:", error);
      return this.getStoredUserData();
    }
  }

  static async syncBookingHistory() {
    const userToken = localStorage.getItem("userToken");
    if (!userToken) return;

    try {
      await fetch("/api/user/sync-booking-history", {
        method: "POST",
        headers: { Authorization: `Bearer ${userToken}` },
      });
    } catch (error) {
      console.error("Error syncing booking history:", error);
    }
  }

  static clearUserData() {
    if (typeof window === "undefined") return;
    // Clear user-specific data
    localStorage.removeItem("userToken");
    localStorage.removeItem("authenticatedUserData");
    localStorage.removeItem("userPrefillData");
    localStorage.removeItem("userData");

    // Clear society/member data if exists
    localStorage.removeItem("authToken");
    localStorage.removeItem("authUser");
    localStorage.removeItem("selectedSocietyId");

    // Keep onboarding data for future use
    console.log("User data cleared successfully");
  }

  static clearSalonData() {
    if (typeof window === "undefined") return;
    // Clear salon-specific data
    localStorage.removeItem("salonToken");
    localStorage.removeItem("salonSession");
    localStorage.removeItem("ownerToken");

    console.log("Salon data cleared successfully");
  }

  static clearAllData() {
    if (typeof window === "undefined") return;
    // Nuclear option - clear everything except hasOnboarded
    const hasOnboarded = localStorage.getItem("hasOnboarded");
    const userOnboardingData = localStorage.getItem("userOnboardingData");

    localStorage.clear();

    // Restore onboarding data
    if (hasOnboarded) localStorage.setItem("hasOnboarded", hasOnboarded);
    if (userOnboardingData)
      localStorage.setItem("userOnboardingData", userOnboardingData);

    console.log("All data cleared except onboarding");
  }

  static isUserLoggedIn() {
    if (typeof window === "undefined") return false;
    const userToken = localStorage.getItem("userToken");
    const authenticatedUserData = localStorage.getItem("authenticatedUserData");
    return !!(userToken && authenticatedUserData);
  }

  static preserveUserInfoForBooking(bookingData) {
    if (typeof window === "undefined") return;
    const currentUser = this.getStoredUserData();
    if (currentUser) {
      // Store prefill data with user info for feedback
      const prefillData = {
        name: currentUser.name || "Anonymous",
        phone: currentUser.phone || "",
        lastBookings: {
          salonId: bookingData.salonId,
          service: bookingData.service,
          date: bookingData.date,
          time: bookingData.time,
        },
        timestamp: Date.now(),
      };
      localStorage.setItem("userPrefillData", JSON.stringify(prefillData));
    }
  }

  static isLoggedIn() {
    if (typeof window === "undefined") return false;
    return !!localStorage.getItem("userToken");
  }

  static hasOnboarded() {
    if (typeof window === "undefined") return false;
    return localStorage.getItem("hasOnboarded") === "true";
  }
}
</file>

<file path="src/pages/auth/user/register.js">
import { useState, useEffect } from "react";
import { useRouter } from "next/router";
import styles from "../../../styles/Auth/UserAuth.module.css";

export default function UserRegisterPage() {
  const router = useRouter();
  const [formData, setFormData] = useState({
    name: "",
    email: "",
    phone: "",
    gender: "",
    password: "",
  });
  const [prefillData, setPrefillData] = useState(null);
  const [isLoading, setIsLoading] = useState(false);

  useEffect(() => {
    // Check for prefill data from feedback or onboarding
    const onboardingData = localStorage.getItem("userOnboardingData");
    const savedPrefillData = localStorage.getItem("userPrefillData");

    console.log("Checking localStorage data:");
    console.log("onboardingData:", onboardingData);
    console.log("savedPrefillData:", savedPrefillData);

    let prefillInfo = null;

    if (savedPrefillData) {
      try {
        const data = JSON.parse(savedPrefillData);
        prefillInfo = {
          name: data.name || "",
          phone: data.phone || "",
          phoneNumber: data.phoneNumber || data.phone || "",
          gender: data.gender || "",
          age: data.age || null,
          lastBooking: data.lastBookings || {},
          source: "feedback",
        };
        setPrefillData(prefillInfo);
        setFormData((prev) => ({
          ...prev,
          name: data.name || prev.name,
          phone: data.phoneNumber || data.phone || prev.phone,
          age: data.age || prev.age,
          gender: data.gender || prev.gender,
        }));
      } catch (error) {
        console.error("Error parsing prefill data:", error);
      }
    } else if (onboardingData) {
      try {
        const data = JSON.parse(onboardingData);
        prefillInfo = {
          name: data.name || "",
          gender: data.gender || "",
          location: data.location || null,
          source: "onboarding",
        };
        setPrefillData(prefillInfo);
        setFormData((prev) => ({
          ...prev,
          name: data.name || prev.name,
          phone: data.phone || prev.phone,
          gender: data.gender || prev.gender,
        }));
      } catch (error) {
        console.error("Error parsing prefill data:", error);
      }
    }
  }, []);

  const handleSubmit = async (e) => {
    e.preventDefault();
    setIsLoading(true);

    try {
      // Include location data from onboarding if available
      const onboardingData = localStorage.getItem("userOnboardingData");
      let locationData = null;
      if (onboardingData) {
        try {
          const data = JSON.parse(onboardingData);
          locationData = data.location;
        } catch (e) {
          console.error("Error parsing onboarding location:", e);
        }
      }

      const registrationData = {
        name: formData.name,
        email: formData.email,
        phone: formData.phone,
        phoneNumber: formData.phone,
        gender: formData.gender,
        password: formData.password,
        age: formData.age || null,
        dateOfBirth: formData.dateOfBirth || null,
        location: locationData,
      };

      const response = await fetch("/api/auth/user/register", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(registrationData),
      });

      if (response.ok) {
        const result = await response.json();

        // Store authentication data
        localStorage.setItem("userToken", result.token);
        localStorage.setItem(
          "authenticatedUserData",
          JSON.stringify(result.user)
        );

        // Clean up temporary data but keep onboarding for location
        localStorage.removeItem("userPrefillData");

        alert("Registration successful! Welcome to TechTrims!");
        router.push("/user/dashboard");
      } else {
        const error = await response.json();
        alert("Registration failed: " + error.message);
      }
    } catch (error) {
      console.error("Registration error:", error);
      alert("Registration failed. Please try again.");
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <div className={styles.container}>
      <div className={styles.authCard}>
        <h1 className={styles.title}>Create Account</h1>

        {prefillData && (
          <div className={styles.prefillInfo}>
            <h3>Complete your registration</h3>
            <p>
              {prefillData.source === "onboarding"
                ? "Based on your preferences"
                : `From your recent booking${
                    prefillData.lastBooking
                      ? ` on ${prefillData.lastBooking}`
                      : ""
                  }`}
            </p>
          </div>
        )}

        <form onSubmit={handleSubmit} className={styles.form}>
          <div className={styles.formGroup}>
            <input
              type="text"
              placeholder="Full Name"
              value={formData.name}
              onChange={(e) =>
                setFormData({ ...formData, name: e.target.value })
              }
              required
            />
          </div>

          <div className={styles.formGroup}>
            <input
              type="email"
              placeholder="Email Address"
              value={formData.email}
              onChange={(e) =>
                setFormData({ ...formData, email: e.target.value })
              }
              required
            />
          </div>

          <div className={styles.formGroup}>
            <input
              type="tel"
              placeholder="Phone Number"
              value={formData.phone}
              onChange={(e) =>
                setFormData({ ...formData, phone: e.target.value })
              }
              required
            />
          </div>

          <div className={styles.formGroup}>
            <select
              value={formData.gender}
              onChange={(e) =>
                setFormData({ ...formData, gender: e.target.value })
              }
              required
            >
              <option value="">Select Gender</option>
              <option value="male">Male</option>
              <option value="female">Female</option>
              <option value="other">Other</option>
            </select>
          </div>

          <div className={styles.formGroup}>
            <input
              type="password"
              placeholder="Password (min 6 characters)"
              value={formData.password}
              onChange={(e) =>
                setFormData({ ...formData, password: e.target.value })
              }
              required
            />
          </div>

          <button
            type="submit"
            className={styles.submitButton}
            disabled={isLoading}
          >
            {isLoading ? "Creating Account..." : "Create Account"}
          </button>
        </form>

        <p className={styles.authLink}>
          Already have an account?{" "}
          <button
            type="button"
            onClick={() => router.push("/auth/user/login")}
            className={styles.linkButton}
          >
            Login here
          </button>
        </p>
      </div>
    </div>
  );
}
</file>

<file path="src/pages/booking/confirmed.js">
import { useRouter } from "next/router";
import { useEffect, useState } from "react";
import styles from "../../styles/BookingConfirmed.module.css";

export default function BookingConfirmed() {
  const router = useRouter();
  const { id } = router.query;
  const [booking, setBooking] = useState(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    if (!id) return;

    const loadBooking = async () => {
      try {
        const res = await fetch("/api/bookings/" + id);
        if (res.ok) {
          const data = await res.json();
          setBooking(data.booking);
        }
      } catch (error) {
        console.error("Error loading booking:", error);
      } finally {
        setLoading(false);
      }
    };

    loadBooking();
    const interval = setInterval(loadBooking, 10000);
    return () => clearInterval(interval);
  }, [id]);

  const proceedToFeedback = () => {
    router.push(`/feedback?bookingId=${id}`);
  };

  if (loading) return <div style={{ padding: 20 }}>Loading...</div>;
  if (!booking) return <div style={{ padding: 20 }}>Booking not found.</div>;

  return (
    <div className={styles.container}>
      <h2 className={styles.heading}>Booking Status</h2>
      <div className={styles.bookingCard}>
        <p className={styles.bookingInfo}>
          <strong>Customer:</strong> {booking.customerName}
          {booking.customerAge && ` (${booking.customerAge} years)`}
        </p>
        <p className={styles.bookingInfo}>
          <strong>Phone:</strong> {booking.customerPhone}
        </p>
        {booking.customerLocation && (
          <p className={styles.bookingInfo}>
            <strong>Location:</strong> {booking.customerLocation.address}
          </p>
        )}

        <p>
          <strong>Service:</strong> {booking.service}
        </p>
        {booking.barber && (
          <p>
            <strong>Barber:</strong> {booking.barber}
          </p>
        )}
        <p>
          <strong>Date:</strong> {booking.date}
        </p>
        <p>
          <strong>Time:</strong> {booking.time}
        </p>
        <p>
          <strong>Customer:</strong> {booking.customerName}
        </p>
      </div>

      <div className={styles.statusSection}>
        <h3 className={styles.statusHeading}>Service Status</h3>
        <div className={styles.statusTracker}>
          <StatusStep
            label="Confirmed"
            active={true}
            completed={booking.status !== "confirmed"}
          />
          <StatusStep
            label="Customer Arrived"
            active={
              booking.status === "arrived" ||
              isAfterStatus("arrived", booking.status)
            }
            completed={isAfterStatus("arrived", booking.status)}
          />
          <StatusStep
            label="Service Started"
            active={
              booking.status === "started" ||
              isAfterStatus("started", booking.status)
            }
            completed={isAfterStatus("started", booking.status)}
          />
          <StatusStep
            label="Service Done"
            active={booking.status === "completed"}
            completed={booking.status === "completed"}
          />
        </div>
      </div>

      {booking.status === "completed" && (
        <div className={styles.completedAlert}>
          <h3 className={styles.completedTitle}>Service Completed!</h3>
          <p className={styles.completedText}>
            Your service has been completed...
          </p>
          <button onClick={proceedToFeedback} className={styles.feedbackButton}>
            Give Feedback
          </button>
        </div>
      )}

      {booking.status !== "completed" && (
        <div className={styles.pendingAlert}>
          <p className={styles.pendingText}>
            {getStatusMessage(booking.status)}
          </p>
        </div>
      )}
    </div>
  );
}

function StatusStep({ label, active, completed }) {
  return (
    <div
      className={`${styles.statusStep} ${
        active || completed ? styles.active : styles.inactive
      }`}
    >
      <div
        className={`${styles.statusIcon} ${
          completed
            ? styles.completed
            : active
            ? styles.active
            : styles.inactive
        }`}
      >
        {completed ? "✓" : active ? "⏳" : "⏸"}
      </div>
      <div className={styles.statusLabel}>{label}</div>
    </div>
  );
}

function isAfterStatus(checkStatus, currentStatus) {
  const statusOrder = ["confirmed", "arrived", "started", "completed"];
  return statusOrder.indexOf(currentStatus) > statusOrder.indexOf(checkStatus);
}

function getStatusMessage(status) {
  switch (status) {
    case "confirmed":
      return "Your booking is confirmed. Please arrive on time.";
    case "arrived":
      return "You have arrived. Waiting for service to start.";
    case "started":
      return "Your service is in progress. Please wait.";
    case "completed":
      return "Service completed! Please provide feedback.";
    default:
      return "Unknown status";
  }
}
</file>

<file path="src/pages/onboarding.js">
import { useState, useEffect } from "react";
import { useRouter } from "next/router";
import { motion } from "framer-motion";
import styles from "../styles/Onboarding.module.css";

export default function Onboarding() {
  const router = useRouter();
  const [formData, setFormData] = useState({
    name: "",
    gender: "",
    dateOfBirth: "",
    age: null,
    phoneNumber: "",
    isPhoneVerified: false,
    location: { latitude: null, longitude: null, address: "" },
  });
  const [currentStep, setCurrentStep] = useState(1); // 5 steps total
  const [otp, setOtp] = useState("");
  const [otpSent, setOtpSent] = useState(false);
  const [generatedOtp, setGeneratedOtp] = useState("");

  const [isLoading, setIsLoading] = useState(false);
  const [locationStatus, setLocationStatus] = useState("pending"); // pending, loading, success, error

  useEffect(() => {
    // Check if user has already completed onboarding
    const hasOnboarded = localStorage.getItem("hasOnboarded");
    if (hasOnboarded) {
      router.push("/");
    }
  }, [router]);

  const handleInputChange = (field, value) => {
    setFormData((prev) => ({
      ...prev,
      [field]: value,
    }));
  };

  const getCurrentLocation = () => {
    setLocationStatus("loading");

    if (!navigator.geolocation) {
      setLocationStatus("error");
      alert("Geolocation is not supported by this browser.");
      return;
    }

    navigator.geolocation.getCurrentPosition(
      async (position) => {
        const latitude = position.coords.latitude;
        const longitude = position.coords.longitude;
        console.log("🔍 ACTUAL GPS COORDINATES:", { latitude, longitude });

        try {
          // Reverse geocoding to get address
          const response = await fetch("/api/maps/reverse", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ lat: latitude, lng: longitude }),
          });

          if (!response.ok) {
            throw new Error("Failed to reverse geocode");
          }

          const data = await response.json();

          setFormData((prev) => ({
            ...prev,
            location: {
              latitude,
              longitude,
              address: data.address || `${latitude}, ${longitude}`,
            },
          }));
          setLocationStatus("success");
        } catch (error) {
          console.error("Error getting address:", error);
          setFormData((prev) => ({
            ...prev,
            location: {
              latitude,
              longitude,
              address: `${latitude}, ${longitude}`,
            },
          }));
          setLocationStatus("success");
        }
      },
      (error) => {
        console.error("Error getting location:", error);
        setLocationStatus("error");
        alert(
          "Unable to get your location. Please enter manually or try again."
        );
      },
      {
        enableHighAccuracy: true,
        timeout: 10000,
        maximumAge: 600000,
      }
    );
  };

  const handleManualLocation = (address) => {
    setFormData((prev) => ({
      ...prev,
      location: {
        latitude: null,
        longitude: null,
        address,
      },
    }));
    setLocationStatus("success");
  };

  const handleSendOtp = () => {
    // Generate 6-digit OTP (client-side for free solution)
    const generated = Math.floor(100000 + Math.random() * 900000).toString();
    setGeneratedOtp(generated);
    setOtpSent(true);

    // Store OTP with expiry (5 minutes)
    const otpData = {
      otp: generated,
      phone: formData.phoneNumber,
      expiresAt: Date.now() + 5 * 60 * 1000,
    };
    localStorage.setItem("tempOtp", JSON.stringify(otpData));

    alert(`OTP sent! (Development mode - OTP: ${generated})`);
  };

  const handleVerifyOtp = () => {
    const storedData = JSON.parse(localStorage.getItem("tempOtp"));

    if (!storedData || Date.now() > storedData.expiresAt) {
      alert("OTP expired! Please request a new one.");
      setOtpSent(false);
      setOtp("");
      return;
    }

    if (otp === storedData.otp && formData.phoneNumber === storedData.phone) {
      handleInputChange("isPhoneVerified", true);
      localStorage.removeItem("tempOtp");
      alert("Phone verified successfully!");
      setCurrentStep((prev) => prev + 1);
    } else {
      alert("Invalid OTP! Please try again.");
    }
  };

  const nextStep = () => {
    if (currentStep === 1 && formData.name.trim().length < 2) {
      alert("Please enter a valid name");
      return;
    }
    if (currentStep === 2 && !formData.gender) {
      alert("Please select your gender");
      return;
    }
    if (currentStep === 3 && (!formData.age || formData.age < 13)) {
      alert("You must be at least 13 years old");
      return;
    }
    if (currentStep === 4 && !formData.isPhoneVerified) {
      alert("Please verify your phone number");
      return;
    }
    if (currentStep === 5 && locationStatus !== "success") {
      alert("Please set your location");
      return;
    }
    if (currentStep < 5) {
      setCurrentStep((prev) => prev + 1);
    } else {
      completeOnboarding();
    }
  };

  const prevStep = () => {
    if (currentStep > 1) {
      setCurrentStep((prev) => prev - 1);
    }
  };

  const completeOnboarding = () => {
    setIsLoading(true);

    // Store onboarding data in localStorage
    localStorage.setItem("userOnboardingData", JSON.stringify(formData));
    localStorage.setItem("hasOnboarded", "true");

    setTimeout(() => {
      setIsLoading(false);
      router.push("/");
    }, 1500);
  };

  const stepVariants = {
    hidden: { opacity: 0, x: 50 },
    visible: { opacity: 1, x: 0 },
    exit: { opacity: 0, x: -50 },
  };

  return (
    <div className={styles.container}>
      <div className={styles.background}>
        <div className={styles.goldOrb}></div>
        <div className={styles.goldOrb}></div>
      </div>

      <div className={styles.onboardingCard}>
        <div className={styles.header}>
          <h1 className={styles.title}>
            Welcome to <span className={styles.goldText}>TechTrims</span>
          </h1>
          <p className={styles.subtitle}>
            Let&apos;s personalize your experience
          </p>

          <div className={styles.progressBar}>
            <div className={styles.progressTrack}>
              <div
                className={styles.progressFill}
                style={{ width: `${(currentStep / 5) * 100}%` }}
              ></div>
            </div>
            <span className={styles.progressText}>{currentStep}/5</span>
          </div>
        </div>

        <motion.div
          key={currentStep}
          initial="hidden"
          animate="visible"
          exit="exit"
          variants={stepVariants}
          transition={{ duration: 0.3 }}
          className={styles.stepContent}
        >
          {currentStep === 1 && (
            <div className={styles.step}>
              <div className={styles.stepIcon}>👋</div>
              <h2>What&apos;s your name?</h2>
              <p>We&apos;ll use this to personalize your booking experience</p>

              <div className={styles.formGroup}>
                <input
                  type="text"
                  placeholder="Enter your full name"
                  value={formData.name}
                  onChange={(e) => handleInputChange("name", e.target.value)}
                  className={styles.input}
                  autoFocus
                />
              </div>
            </div>
          )}

          {currentStep === 2 && (
            <div className={styles.step}>
              <div className={styles.stepIcon}>⚧️</div>
              <h2>How do you identify?</h2>
              <p>This helps us show relevant services and pricing</p>

              <div className={styles.genderOptions}>
                {["Male", "Female", "Other"].map((gender) => (
                  <button
                    key={gender}
                    type="button"
                    className={`${styles.genderButton} ${
                      formData.gender === gender ? styles.selected : ""
                    }`}
                    onClick={() => handleInputChange("gender", gender)}
                  >
                    <div className={styles.genderIcon}>
                      {gender === "Male"
                        ? "👨"
                        : gender === "Female"
                        ? "👩"
                        : "🧑"}
                    </div>
                    <span>{gender}</span>
                  </button>
                ))}
              </div>
            </div>
          )}

          {currentStep === 3 && (
            <div className={styles.step}>
              <div className={styles.stepIcon}>🎂</div>
              <h2>When were you born?</h2>
              <p>We&apos;ll use this to provide age-appropriate services</p>
              <div className={styles.formGroup}>
                <input
                  type="date"
                  max={
                    new Date(
                      new Date().setFullYear(new Date().getFullYear() - 13)
                    )
                      .toISOString()
                      .split("T")[0]
                  }
                  value={formData.dateOfBirth}
                  onChange={(e) => {
                    const birthDate = new Date(e.target.value);
                    const today = new Date();
                    let age = today.getFullYear() - birthDate.getFullYear();
                    const monthDiff = today.getMonth() - birthDate.getMonth();
                    if (
                      monthDiff < 0 ||
                      (monthDiff === 0 && today.getDate() < birthDate.getDate())
                    ) {
                      age--;
                    }
                    handleInputChange("dateOfBirth", e.target.value);
                    handleInputChange("age", age);
                  }}
                  className={styles.input}
                  autoFocus
                />
                {formData.age && (
                  <p className={styles.ageDisplay}>Age: {formData.age} years</p>
                )}
              </div>
            </div>
          )}

          {currentStep === 4 && (
            <div className={styles.step}>
              <div className={styles.stepIcon}>📱</div>
              <h2>Verify your phone number</h2>
              <p>We&apos;ll send you a verification code</p>
              <div className={styles.formGroup}>
                <input
                  type="tel"
                  placeholder="Enter 10-digit mobile number"
                  value={formData.phoneNumber}
                  onChange={(e) =>
                    handleInputChange(
                      "phoneNumber",
                      e.target.value.replace(/\D/g, "").slice(0, 10)
                    )
                  }
                  className={styles.input}
                  maxLength="10"
                  disabled={otpSent}
                />
                {!otpSent && (
                  <button
                    type="button"
                    className={styles.sendOtpButton}
                    onClick={handleSendOtp}
                    disabled={formData.phoneNumber.length !== 10}
                  >
                    Send OTP
                  </button>
                )}
              </div>
              {otpSent && (
                <div className={styles.otpSection}>
                  <input
                    type="text"
                    placeholder="Enter 6-digit OTP"
                    value={otp}
                    onChange={(e) =>
                      setOtp(e.target.value.replace(/\D/g, "").slice(0, 6))
                    }
                    className={styles.input}
                    maxLength="6"
                    autoFocus
                  />
                  <p className={styles.otpNote}>
                    OTP (for development): {generatedOtp}
                  </p>
                  <button
                    type="button"
                    className={styles.verifyButton}
                    onClick={handleVerifyOtp}
                    disabled={otp.length !== 6}
                  >
                    Verify OTP
                  </button>
                </div>
              )}
            </div>
          )}

          {currentStep === 5 && (
            <div className={styles.step}>
              <div className={styles.stepIcon}>📍</div>
              <h2>Where are you located?</h2>
              <p>We&apos;ll find the best salons near you</p>

              <div className={styles.locationSection}>
                {locationStatus === "pending" && (
                  <>
                    <button
                      type="button"
                      className={styles.locationButton}
                      onClick={getCurrentLocation}
                    >
                      <span>📍</span>
                      Use Current Location
                    </button>

                    <div className={styles.divider}>
                      <span>or</span>
                    </div>

                    <input
                      type="text"
                      placeholder="Enter your area/city manually"
                      className={styles.input}
                      onKeyPress={(e) => {
                        if (e.key === "Enter" && e.target.value.trim()) {
                          handleManualLocation(e.target.value.trim());
                        }
                      }}
                      onBlur={(e) => {
                        if (e.target.value.trim()) {
                          handleManualLocation(e.target.value.trim());
                        }
                      }}
                    />
                  </>
                )}

                {locationStatus === "loading" && (
                  <div className={styles.loadingLocation}>
                    <div className={styles.spinner}></div>
                    <p>Getting your location...</p>
                  </div>
                )}

                {locationStatus === "success" && (
                  <div className={styles.locationSuccess}>
                    <div className={styles.locationIcon}>✅</div>
                    <div>
                      <h4>Location Set!</h4>
                      <p>{formData.location.address}</p>
                    </div>
                    <button
                      type="button"
                      className={styles.changeLocationButton}
                      onClick={() => setLocationStatus("pending")}
                    >
                      Change
                    </button>
                  </div>
                )}

                {locationStatus === "error" && (
                  <div className={styles.locationError}>
                    <p>Couldn&apos;t get location. Please enter manually:</p>
                    <input
                      type="text"
                      placeholder="Enter your area/city"
                      className={styles.input}
                      onKeyPress={(e) => {
                        if (e.key === "Enter" && e.target.value.trim()) {
                          handleManualLocation(e.target.value.trim());
                        }
                      }}
                    />
                  </div>
                )}
              </div>
            </div>
          )}
        </motion.div>

        <div className={styles.navigation}>
          {currentStep > 1 && (
            <button
              type="button"
              className={styles.backButton}
              onClick={prevStep}
            >
              ← Back
            </button>
          )}

          <button
            type="button"
            className={styles.nextButton}
            onClick={nextStep}
            disabled={isLoading}
          >
            {isLoading ? (
              <>
                <div className={styles.spinner}></div>
                Setting up...
              </>
            ) : currentStep === 5 ? (
              "Complete Setup"
            ) : (
              "Next →"
            )}
          </button>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="src/components/OwnerSidebar.js">
import { useRouter } from "next/router";
import styles from "../styles/OwnerSidebar.module.css";

export default function OwnerSidebar({ closeSidebar }) {
  const router = useRouter();

  const menuItems = [
    { icon: "👤", label: "Profile", path: "/salons/profile" },
    { icon: "📅", label: "Bookings", path: "/salons/bookings" },
    {
      icon: "👨‍💼",
      label: "Barber Management",
      href: "/salons/barbers",
      path: "/salons/barbers",
    },
    { icon: "👥", label: "Staff", path: "/salons/staff" },
    { icon: "✂️", label: "Services", path: "/salons/services" },
    { icon: "💰", label: "Payments", path: "/salons/payments" },
    { icon: "📈", label: "Analytics", path: "/salons/analytics" },
    { icon: "⚙️", label: "Settings", path: "/salons/settings" },
  ];

  const handleLogout = () => {
    if (window.confirm("Are you sure you want to logout?")) {
      localStorage.removeItem("ownerToken");
      localStorage.removeItem("salonToken");
      localStorage.removeItem("salonSession");
      alert("Logged out successfully!");
      router.push("/auth/salon/login");
    }
  };

  return (
    <div className={styles.sidebar}>
      {/* Logo */}
      <div className={styles.header}>
        <div className={styles.logoContainer}>
          <h2 className={styles.logo}>Tech Trims</h2>
          <p className={styles.subtitle}>Owner Dashboard</p>
        </div>
        {closeSidebar && (
          <button onClick={closeSidebar} className={styles.closeButton}>
            ❌
          </button>
        )}
      </div>

      {/* Nav Menu */}
      <nav className={styles.nav}>
        {menuItems.map((item) => (
          <button
            key={item.path}
            onClick={() => {
              router.push(item.path);
              if (closeSidebar) closeSidebar();
            }}
            className={`${styles.navButton} ${
              router.pathname === item.path
                ? styles.navButtonActive
                : styles.navButtonInactive
            }`}
          >
            <span className={styles.navIcon}>{item.icon}</span>
            <span className={styles.navLabel}>{item.label}</span>
          </button>
        ))}
      </nav>

      {/* Footer */}
      <div className={styles.footer}>
        <button onClick={handleLogout} className={styles.logoutButton}>
          🚪 Logout
        </button>
      </div>
    </div>
  );
}
</file>

<file path="src/pages/api/bookings/update-status.js">
import { connectToDatabase } from "../../../lib/mongodb";
import { updateSalonStats, updateBarberStats } from "../../../lib/statsHelper";
import { ObjectId } from "mongodb";

export default async function handler(req, res) {
  if (req.method !== "PUT") {
    return res.status(405).json({ error: "Method not allowed" });
  }

  try {
    const { bookingId, status, queueStatus, estimatedDuration } = req.body;

    if (!bookingId || !status) {
      return res
        .status(400)
        .json({ error: "Booking ID and status are required" });
    }

    const { client, db } = await connectToDatabase();

    // Prepare update data
    const updateData = {
      status,
      updatedAt: new Date(),
    };

    // ✅ Map status to queueStatus for real-time updates
    const queueStatusMap = {
      confirmed: "RED",
      arrived: "ORANGE",
      started: "GREEN",
      completed: "COMPLETED",
    };

    // Set queueStatus based on status
    updateData.queueStatus = queueStatus || queueStatusMap[status] || "RED";

    // ✅ Add timestamps based on status
    if (status === "arrived") {
      updateData.arrivedAt = new Date();
    } else if (status === "started") {
      updateData.serviceStartedAt = new Date();
      if (estimatedDuration) {
        updateData.estimatedDuration = estimatedDuration;
        updateData.expectedCompletionTime = new Date(
          Date.now() + estimatedDuration * 60000
        );
      }
    } else if (status === "completed") {
      updateData.completedAt = new Date();
      updateData.serviceEndedAt = new Date();
    }

    // Update booking status
    const result = await db
      .collection("bookings")
      .updateOne({ _id: new ObjectId(bookingId) }, { $set: updateData });

    if (result.matchedCount === 0) {
      return res.status(404).json({ error: "Booking not found" });
    }

    // ✅ UPDATE BARBER STATUS WHEN SERVICE STARTS/ENDS
    const updatedBooking = await db.collection("bookings").findOne({
      _id: new ObjectId(bookingId),
    });

    if (status === "started" && updatedBooking?.barberId) {
      const endTime = new Date(Date.now() + (estimatedDuration || 45) * 60000);

      await db.collection("barbers").updateOne(
        { _id: new ObjectId(updatedBooking.barberId) },
        {
          $set: {
            currentStatus: "OCCUPIED",
            currentBookingId: updatedBooking._id,
            currentCustomerName: updatedBooking.customerName,
            currentServiceStartTime: new Date(),
            currentServiceEndTime: endTime,
            isAvailable: false,
          },
        }
      );
    } else if (status === "completed" && updatedBooking?.barberId) {
      await db.collection("barbers").updateOne(
        { _id: new ObjectId(updatedBooking.barberId) },
        {
          $set: {
            currentStatus: "AVAILABLE",
            currentBookingId: null,
            currentCustomerName: null,
            currentServiceStartTime: null,
            currentServiceEndTime: null,
            isAvailable: true,
          },
        }
      );
    }

    // ✅ Calculate wait time when completed
    if (status === "completed" && updatedBooking) {
      const scheduledTime = new Date(
        `${updatedBooking.date}T${updatedBooking.time}:00`
      );
      const waitMinutes = Math.max(
        0,
        Math.round((updatedBooking.completedAt - scheduledTime) / 60000)
      );

      // Get current average and update it
      const salon = await db
        .collection("salons")
        .findOne({ _id: updatedBooking.salonId });

      const currentAvg = salon?.stats?.averageWaitTime || 0;
      const totalBookings = salon?.stats?.totalBookings || 1;
      const newAvg = Math.round(
        (currentAvg * (totalBookings - 1) + waitMinutes) / totalBookings
      );

      await db
        .collection("salons")
        .updateOne(
          { _id: updatedBooking.salonId },
          { $set: { "stats.averageWaitTime": newAvg } }
        );
    }

    // ✅ UPDATE SALON STATS IN REAL-TIME
    if (updatedBooking?.salonId) {
      await updateSalonStats(updatedBooking.salonId);
    }

    // ✅ UPDATE BARBER STATS IF COMPLETED
    if (status === "completed" && updatedBooking?.barber) {
      const barber = await db.collection("barbers").findOne({
        name: updatedBooking.barber,
      });
      if (barber) {
        await updateBarberStats(
          barber._id,
          barber.name,
          updatedBooking.salonId
        );
      }
    }

    res.status(200).json({
      success: true,
      message: "Booking status updated successfully",
      booking: updatedBooking,
      queueStatus: updateData.queueStatus,
    });
  } catch (error) {
    console.error("Error updating booking status:", error);
    res.status(500).json({ error: "Internal server error" });
  }
}
</file>

<file path="src/pages/auth/user/login.js">
import { useState, useEffect } from "react";
import { useRouter } from "next/router";
import styles from "../../../styles/Auth/UserAuth.module.css";
import { UserDataManager } from "@/lib/userData";

export default function UserLoginPage() {
  const router = useRouter();
  const [mounted, setMounted] = useState(false);
  const [formData, setFormData] = useState({
    email: "",
    password: "",
  });
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState("");
  const [showForgotPassword, setShowForgotPassword] = useState(false);
  const [forgotEmail, setForgotEmail] = useState("");

  // ✅ FIX: Wait for client-side mount
  useEffect(() => {
    setMounted(true);
  }, []);

  const handleForgotPassword = async (e) => {
    e.preventDefault();

    if (!forgotEmail || !forgotEmail.includes("@")) {
      setError("Please enter a valid email address");
      return;
    }

    setIsLoading(true);
    setError("");

    try {
      const response = await fetch("/api/auth/forgot-password", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ email: forgotEmail }),
      });

      const data = await response.json();

      if (response.status === 429) {
        setError(`Too many attempts. ${data.message}`);
      } else if (response.ok) {
        alert(
          "✅ Password reset link sent! Please check your email (including spam folder)."
        );
        setShowForgotPassword(false);
        setForgotEmail("");
      } else {
        setError(data.message || "Failed to send reset link");
      }
    } catch (error) {
      setError("Network error. Please check your connection and try again.");
    } finally {
      setIsLoading(false);
    }
  };

  const handleSubmit = async (e) => {
    e.preventDefault();
    setIsLoading(true);
    setError("");

    try {
      const response = await fetch("/api/auth/user/login", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(formData),
      });

      if (response.ok) {
        const result = await response.json();
        localStorage.setItem("userToken", result.token);
        localStorage.setItem(
          "authenticatedUserData",
          JSON.stringify(result.user)
        );

        await UserDataManager.fetchAndStoreUserData();

        alert(`Welcome back, ${result.user.name}!`);
        router.push("/user/dashboard");
      } else {
        const error = await response.json();
        setError(error.message || "Login failed");
      }
    } catch (error) {
      console.error("Login error:", error);
      setError("Network error. Please try again.");
    } finally {
      setIsLoading(false);
    }
  };

  // ✅ FIX: Don't render until mounted on client
  if (!mounted) {
    return (
      <div className={styles.container}>
        <div className={styles.authCard}>
          <div className={styles.header}>
            <button className={styles.backButton}>← Back to Home</button>
          </div>
          <h1 className={styles.title}>Welcome Back</h1>
          <p className={styles.subtitle}>Loading...</p>
        </div>
      </div>
    );
  }

  return (
    <div className={styles.container}>
      <div className={styles.authCard}>
        <div className={styles.header}>
          <button
            onClick={() => router.push("/")}
            className={styles.backButton}
          >
            ← Back to Home
          </button>
        </div>

        {!showForgotPassword ? (
          <>
            <h1 className={styles.title}>Welcome Back</h1>
            <p className={styles.subtitle}>Login to your TechTrims account</p>

            {error && (
              <div className={styles.error}>
                <span>⚠️ {error}</span>
              </div>
            )}

            <form onSubmit={handleSubmit} className={styles.form}>
              <div className={styles.formGroup}>
                <label htmlFor="email">Email Address</label>
                <input
                  id="email"
                  type="email"
                  placeholder="Enter your email"
                  value={formData.email}
                  onChange={(e) =>
                    setFormData({ ...formData, email: e.target.value })
                  }
                  required
                  disabled={isLoading}
                  autoComplete="email"
                />
              </div>

              <div className={styles.formGroup}>
                <label htmlFor="password">Password</label>
                <input
                  id="password"
                  type="password"
                  placeholder="Enter your password"
                  value={formData.password}
                  onChange={(e) =>
                    setFormData({ ...formData, password: e.target.value })
                  }
                  required
                  disabled={isLoading}
                  autoComplete="current-password"
                />
              </div>

              <button
                type="submit"
                className={styles.submitButton}
                disabled={isLoading}
              >
                {isLoading ? (
                  <>
                    <span className={styles.spinner}></span>
                    Logging in...
                  </>
                ) : (
                  "Login"
                )}
              </button>
            </form>

            <div
              className={styles.authLink}
              style={{ marginTop: "1rem", textAlign: "center" }}
            >
              <button
                type="button"
                onClick={() => {
                  setShowForgotPassword(true);
                  setError("");
                }}
                className={styles.linkButton}
              >
                Forgot Password?
              </button>
            </div>

            <div className={styles.authLinks}>
              <div className={styles.authLink}>
                Don&#39;t have an account?{" "}
                <button
                  type="button"
                  onClick={() => router.push("/auth/user/register")}
                  className={styles.linkButton}
                >
                  Create Account
                </button>
              </div>

              <div className={styles.divider}>
                <span>or</span>
              </div>

              <div className={styles.authLink}>
                Are you a salon owner?{" "}
                <button
                  type="button"
                  onClick={() => router.push("/auth/salon/login")}
                  className={styles.linkButton}
                >
                  Login as Salon
                </button>
              </div>
            </div>
          </>
        ) : (
          <>
            <h1 className={styles.title}>Reset Password</h1>
            <p className={styles.subtitle}>
              Enter your email to receive a password reset link
            </p>

            {error && (
              <div className={styles.error}>
                <span>⚠️ {error}</span>
              </div>
            )}

            <form onSubmit={handleForgotPassword} className={styles.form}>
              <div className={styles.formGroup}>
                <label htmlFor="forgotEmail">Email Address</label>
                <input
                  id="forgotEmail"
                  type="email"
                  placeholder="Enter your email"
                  value={forgotEmail}
                  onChange={(e) => setForgotEmail(e.target.value)}
                  required
                  disabled={isLoading}
                  autoFocus
                  autoComplete="email"
                />
              </div>

              <button
                type="submit"
                className={styles.submitButton}
                disabled={isLoading}
              >
                {isLoading ? (
                  <>
                    <span className={styles.spinner}></span>
                    Sending...
                  </>
                ) : (
                  "Send Reset Link"
                )}
              </button>
            </form>

            <div
              className={styles.authLink}
              style={{ marginTop: "1rem", textAlign: "center" }}
            >
              <button
                type="button"
                onClick={() => {
                  setShowForgotPassword(false);
                  setForgotEmail("");
                  setError("");
                }}
                className={styles.linkButton}
              >
                ← Back to Login
              </button>
            </div>
          </>
        )}
      </div>
    </div>
  );
}
</file>

<file path="src/pages/user/dashboard.js">
import { useState, useEffect } from "react";
import { useRouter } from "next/router";
import styles from "../../styles/User.module.css";
import Link from "next/link";
import { UserDataManager } from "../../lib/userData";

export default function UserDashboard() {
  const router = useRouter();
  const [user, setUser] = useState(null);
  const [activeTab, setActiveTab] = useState("overview");
  const [bookings, setBookings] = useState([]);
  const [payments, setPayments] = useState([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState(null);
  const [formData, setFormData] = useState({
    name: "",
    email: "",
    phone: "",
    phoneNumber: "",
    age: "",
    gender: "",
    location: null,
  });

  useEffect(() => {
    const loadUserData = async () => {
      try {
        const token = localStorage.getItem("userToken");

        if (!token) {
          router.push("/auth/user/login");
          return;
        }

        setIsLoading(true);

        // Simple profile load
        try {
          const userRes = await fetch("/api/user/profile", {
            headers: { Authorization: `Bearer ${token}` },
          });

          if (userRes.ok) {
            const userData = await userRes.json();
            setUser(userData);
            setFormData({
              name: userData.name || "",
              email: userData.email || "",
              phone: userData.phone || userData.phoneNumber || "",
              phoneNumber: userData.phoneNumber || userData.phone || "",
              age: userData.age || "",
              gender: userData.gender || "",
              location: userData.location || null,
            });
          }
        } catch (err) {
          console.error("Profile error:", err);
        }

        // Simple bookings load
        try {
          const bookingsRes = await fetch("/api/user/bookings", {
            headers: { Authorization: `Bearer ${token}` },
          });

          if (bookingsRes.ok) {
            const bookingsData = await bookingsRes.json();
            setBookings(Array.isArray(bookingsData) ? bookingsData : []);
          }
        } catch (err) {
          console.error("Bookings error:", err);
          setBookings([]);
        }

        // Simple payments load
        try {
          const paymentsRes = await fetch("/api/user/payments", {
            headers: { Authorization: `Bearer ${token}` },
          });

          if (paymentsRes.ok) {
            const paymentsData = await paymentsRes.json();
            setPayments(Array.isArray(paymentsData) ? paymentsData : []);
          }
        } catch (err) {
          console.error("Payments error:", err);
          setPayments([]);
        }
      } catch (error) {
        console.error("Overall error:", error);
        setError(error.message);
      } finally {
        setIsLoading(false);
      }
    };

    loadUserData();
  }, [router]);

  const handleInputChange = (field, value) => {
    setFormData((prev) => ({ ...prev, [field]: value }));
  };

  const handleLogout = () => {
    if (window.confirm("Are you sure you want to logout?")) {
      UserDataManager.clearUserData();
      alert("Logged out successfully!");
      router.push("/");
    }
  };

  if (isLoading) {
    return (
      <div className={styles.loading}>
        <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-blue-500 mx-auto mb-4"></div>
        <p>Loading dashboard...</p>
      </div>
    );
  }

  if (error) {
    return (
      <div className={styles.error}>
        <p>Error: {error}</p>
        <button onClick={() => window.location.reload()}>Retry</button>
      </div>
    );
  }

  return (
    <div className={styles.dashboard}>
      <div className={styles.sidebar}>
        <div className={styles.userProfile}>
          <h2>Welcome, {user?.name || "User"}</h2>
          <p>{user?.email || "No email"}</p>
        </div>

        <nav className={styles.nav}>
          <button
            className={`${styles.navItem} ${
              activeTab === "overview" ? styles.active : ""
            }`}
            onClick={() => setActiveTab("overview")}
          >
            📊 Overview
          </button>
          <button
            className={`${styles.navItem} ${
              activeTab === "bookings" ? styles.active : ""
            }`}
            onClick={() => setActiveTab("bookings")}
          >
            📅 My Bookings
          </button>
          <button
            className={`${styles.navItem} ${
              activeTab === "payments" ? styles.active : ""
            }`}
            onClick={() => setActiveTab("payments")}
          >
            💳 Payments
          </button>
          <button
            className={`${styles.navItem} ${
              activeTab === "feedback" ? styles.active : ""
            }`}
            onClick={() => setActiveTab("feedback")}
          >
            ⭐ My Reviews
          </button>
          <button
            className={`${styles.navItem} ${
              activeTab === "profile" ? styles.active : ""
            }`}
            onClick={() => setActiveTab("profile")}
          >
            👤 Profile
          </button>
        </nav>

        <button className={styles.logoutButton} onClick={handleLogout}>
          🚪 Logout
        </button>
      </div>

      <div className={styles.content}>
        {activeTab === "bookings" && (
          <div className={styles.bookings}>
            <h1>My Bookings ({bookings.length})</h1>
            <div className={styles.bookingsList}>
              {bookings.map((booking) => (
                <div key={booking._id} className={styles.bookingCard}>
                  <div className={styles.bookingHeader}>
                    <h3>{booking.service}</h3>
                    <div className={styles.badges}>
                      <span
                        className={`${styles.statusBadge} ${
                          styles[booking.status]
                        }`}
                      >
                        {booking.status}
                      </span>
                      {booking.bookingType && (
                        <span
                          className={`${styles.typeBadge} ${
                            booking.bookingType === "WALKIN"
                              ? styles.walkin
                              : styles.prebook
                          }`}
                        >
                          {booking.bookingType === "WALKIN"
                            ? "🚶 Walk-in"
                            : "📅 Pre-book"}
                        </span>
                      )}
                    </div>
                  </div>
                  <div className={styles.bookingDetails}>
                    {booking.bookingType === "WALKIN" ? (
                      <>
                        <p>
                          <strong>📅 Date:</strong>{" "}
                          {booking.createdAt
                            ? new Date(booking.createdAt).toLocaleDateString()
                            : "N/A"}
                        </p>
                        <p>
                          <strong>⏰ Time:</strong>{" "}
                          {booking.createdAt
                            ? new Date(booking.createdAt).toLocaleTimeString()
                            : "N/A"}
                        </p>
                        <p>
                          <strong>🏪 Salon:</strong> {booking.salonName}
                        </p>
                        <p>
                          <strong>💈 Barber:</strong>{" "}
                          {booking.barberName || "Not assigned"}
                        </p>
                        <p>
                          <strong>💰 Price:</strong>{" "}
                          {booking.price
                            ? `₹${booking.price}`
                            : "Paid at salon"}
                        </p>
                      </>
                    ) : (
                      <>
                        <p>
                          <strong>📅 Date:</strong> {booking.date}
                        </p>
                        <p>
                          <strong>⏰ Time:</strong> {booking.time}
                        </p>
                        <p>
                          <strong>🏪 Salon:</strong> {booking.salonName}
                        </p>
                        {booking.barber && (
                          <p>
                            <strong>💈 Barber:</strong> {booking.barber}
                          </p>
                        )}
                        <p>
                          <strong>💰 Price:</strong> ₹{booking.price || 0}
                        </p>
                      </>
                    )}
                    {booking.feedback?.ratings?.overall && (
                      <p>
                        <strong>⭐ Your Rating:</strong>{" "}
                        {booking.feedback.ratings.overall}/5
                      </p>
                    )}
                  </div>
                  {booking.status === "completed" &&
                    !booking.feedback?.submitted && (
                      <button
                        className={styles.feedbackButton}
                        onClick={() =>
                          router.push(`/feedback?bookingId=${booking._id}`)
                        }
                      >
                        📝 Give Feedback
                      </button>
                    )}
                </div>
              ))}
              {bookings.length === 0 && (
                <div className={styles.emptyState}>
                  <p>📅 No bookings found</p>
                  <button
                    onClick={() => router.push("/")}
                    className={styles.bookNowButton}
                  >
                    Book Your First Service
                  </button>
                </div>
              )}
            </div>
          </div>
        )}

        {/* Keep all other tabs as-is */}
        {activeTab === "overview" && (
          <div>
            <div className={styles.overview}>
              <Link href="/" className={styles.backLink}>
                Home
              </Link>
              <h1>Dashboard Overview</h1>
            </div>

            <div className={styles.stats}>
              <div className={styles.statCard}>
                <h3>Total Bookings</h3>
                <p>{bookings.length}</p>
              </div>
              <div className={styles.statCard}>
                <h3>Upcoming</h3>
                <p>{bookings.filter((b) => b.status === "confirmed").length}</p>
              </div>
              <div className={styles.statCard}>
                <h3>Completed</h3>
                <p>{bookings.filter((b) => b.status === "completed").length}</p>
              </div>
              <div className={styles.statCard}>
                <h3>Total Spent</h3>
                <p>
                  ₹{payments.reduce((total, p) => total + (p.amount || 0), 0)}
                </p>
              </div>
            </div>

            {/* Recent Bookings */}
            <div className={styles.recentSection}>
              <h2>Recent Bookings</h2>
              {bookings.slice(0, 3).map((booking) => (
                <div key={booking._id} className={styles.bookingCard}>
                  <div className={styles.bookingHeader}>
                    <h3>{booking.service}</h3>
                    <div className={styles.badges}>
                      <span
                        className={`${styles.statusBadge} ${
                          styles[booking.status]
                        }`}
                      >
                        {booking.status}
                      </span>
                      {booking.bookingType && (
                        <span
                          className={`${styles.typeBadge} ${
                            booking.bookingType === "WALKIN"
                              ? styles.walkin
                              : styles.prebook
                          }`}
                        >
                          {booking.bookingType === "WALKIN"
                            ? "🚶 Walk-in"
                            : "📅 Pre-book"}
                        </span>
                      )}
                    </div>
                  </div>
                  <div className={styles.bookingDetails}>
                    {booking.bookingType === "WALKIN" ? (
                      <>
                        <p>
                          📅{" "}
                          {booking.createdAt
                            ? new Date(booking.createdAt).toLocaleDateString()
                            : "N/A"}{" "}
                          at{" "}
                          {booking.createdAt
                            ? new Date(booking.createdAt).toLocaleTimeString()
                            : "N/A"}
                        </p>
                        <p>🏪 {booking.salonName}</p>
                        <p>💈 {booking.barberName || "Not assigned"}</p>
                      </>
                    ) : (
                      <>
                        <p>
                          📅 {booking.date} at {booking.time}
                        </p>
                        <p>🏪 {booking.salonName}</p>
                        {booking.barber && <p>💈 {booking.barber}</p>}
                      </>
                    )}
                  </div>
                </div>
              ))}
              {bookings.length === 0 && (
                <p className={styles.noData}>
                  No bookings yet.{" "}
                  <Link href="/">Book your first service!</Link>
                </p>
              )}
            </div>
          </div>
        )}

        {activeTab === "profile" && (
          <div className={styles.profile}>
            <h1>Profile Settings</h1>
            <div className={styles.profileCard}>
              <div className={styles.profileForm}>
                <div className={styles.formGroup}>
                  <label>Name</label>
                  <input
                    type="text"
                    value={formData.name}
                    onChange={(e) => handleInputChange("name", e.target.value)}
                  />
                </div>
                <div className={styles.formGroup}>
                  <label>Email</label>
                  <input
                    type="email"
                    value={formData.email}
                    onChange={(e) => handleInputChange("email", e.target.value)}
                  />
                </div>
                <div className={styles.formGroup}>
                  <label>Phone</label>
                  <input
                    type="tel"
                    value={formData.phoneNumber || formData.phone}
                    readOnly
                  />
                </div>
                <div className={styles.formGroup}>
                  <label>Age</label>
                  <input
                    type="text"
                    value={
                      formData.age ? `${formData.age} years` : "Not provided"
                    }
                    readOnly
                  />
                </div>
                <div className={styles.formGroup}>
                  <label>Gender</label>
                  <input type="text" value={formData.gender} readOnly />
                </div>
                {formData.location && (
                  <div className={styles.formGroup}>
                    <label>Location</label>
                    <input
                      type="text"
                      value={formData.location.address || "Location set"}
                      readOnly
                    />
                  </div>
                )}
              </div>
              <div className={styles.profileActions}>
                <p className={styles.note}>
                  📝 Profile editing will be available in future updates
                </p>
              </div>
            </div>
          </div>
        )}

        {/* Include payments and feedback tabs as they were */}
      </div>
    </div>
  );
}
</file>

<file path="src/styles/SalonDetail.module.css">
/* Salon Detail Page Styles */

.container {
  min-height: 100vh;
  background: var(--background-primary);
  color: var(--text-primary);
  padding-bottom: var(--space-24);
}

/* Header Section */
.header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: var(--space-6) var(--space-8);
  background: var(--background-secondary);
  border-bottom: 1px solid var(--border-color);
  position: sticky;
  top: 0;
  z-index: 100;
  backdrop-filter: blur(10px);
  background: rgba(255, 255, 255, 0.95);
}

[data-theme="dark"] .header {
  background: rgba(23, 23, 23, 0.95);
}

.backButton {
  padding: var(--space-3) var(--space-6);
  background: transparent;
  border: 2px solid var(--border-color);
  border-radius: var(--radius-lg);
  color: var(--text-primary);
  font-weight: 600;
  cursor: pointer;
  transition: all var(--transition-luxury);
}

.backButton:hover {
  background: var(--primary);
  color: var(--black);
  border-color: var(--primary);
  transform: translateX(-4px);
}

.salonName {
  font-family: var(--font-display);
  font-size: 1.75rem;
  font-weight: 700;
  color: var(--text-primary);
  flex: 1;
  text-align: center;
}
/* Mode Toggle */
.modeToggle {
  display: flex;
  gap: 12px;
  justify-content: center;
  margin: 20px auto;
  max-width: 400px;
}

.modeButton {
  flex: 1;
  padding: 12px 24px;
  background: var(--background-primary, #fff);
  border: 2px solid var(--border-color, #ddd);
  border-radius: 12px;
  font-size: 16px;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.3s ease;
  color: var(--text-secondary, #666);
}

.modeButton:hover {
  border-color: var(--gold-primary, #d4af37);
  transform: translateY(-2px);
}

.modeButton.active {
  background: linear-gradient(135deg, #d4af37 0%, #b8941f 100%);
  border-color: #d4af37;
  color: #fff;
  box-shadow: 0 8px 20px rgba(212, 175, 55, 0.3);
}

/* Walk-in Status Badge */
.walkInStatusBadge {
  position: absolute;
  top: 10px;
  right: 10px;
  display: flex;
  flex-direction: column;
  gap: 5px;
  z-index: 10;
}

.availableNow {
  background: #4caf50;
  color: white;
  padding: 4px 8px;
  border-radius: 8px;
  font-size: 11px;
  font-weight: 700;
}

.occupiedNow {
  background: #ff9800;
  color: white;
  padding: 4px 8px;
  border-radius: 8px;
  font-size: 11px;
  font-weight: 700;
}

.queueBadge {
  background: #f44336;
  color: white;
  padding: 4px 8px;
  border-radius: 8px;
  font-size: 11px;
  font-weight: 700;
}

/* Barber Card Improvements */
.barberCard {
  position: relative;
  border: 2px solid #e0e0e0;
  border-radius: 12px;
  padding: 16px;
  cursor: pointer;
  transition: all 0.3s ease;
}

.barberCard.selected {
  border-color: #d4af37;
  background: #fffbf0;
  box-shadow: 0 4px 12px rgba(212, 175, 55, 0.2);
}

.barberPhoto {
  width: 100%;
  margin-bottom: 12px;
}

.barberImage {
  width: 100%;
  height: 180px;
  object-fit: cover;
  border-radius: 8px;
}

.barberName {
  font-size: 18px;
  font-weight: 700;
  margin: 8px 0 4px;
}

.barberExperience {
  font-size: 14px;
  color: #666;
  margin: 4px 0;
}

.barberRating {
  font-size: 14px;
  color: #ff9800;
  margin: 4px 0;
}

.barberSkills {
  display: flex;
  flex-wrap: wrap;
  gap: 6px;
  margin-top: 8px;
}

.skillChip {
  background: #f0f0f0;
  padding: 4px 8px;
  border-radius: 12px;
  font-size: 11px;
  color: #555;
}

.waitEstimate {
  margin-top: 12px;
  padding: 8px;
  background: #f5f5f5;
  border-radius: 8px;
  text-align: center;
  font-size: 14px;
  font-weight: 600;
}

.noWait {
  color: #4caf50;
}

.waitTime {
  color: #ff9800;
}

/* Mobile Responsive */
@media (max-width: 768px) {
  .modeToggle {
    flex-direction: column;
  }

  .modeButton {
    width: 100%;
  }
}

.headerActions {
  display: flex;
  gap: var(--space-3);
}

.shareButton,
.favoriteButton {
  width: 44px;
  height: 44px;
  background: var(--background-primary);
  border: 1px solid var(--border-color);
  border-radius: var(--radius-full);
  font-size: 1.25rem;
  cursor: pointer;
  transition: all var(--transition-normal);
}

.shareButton:hover,
.favoriteButton:hover {
  background: var(--primary);
  border-color: var(--primary);
  transform: scale(1.1);
}

/* Hero Section */
.heroSection {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: var(--space-6);
  padding: var(--space-6) var(--space-8);
  max-width: 1400px;
  margin: 0 auto;
}

.imageGallery {
  position: relative;
  width: 100%;
  height: 500px;
  border-radius: var(--radius-2xl);
  overflow: hidden;
  box-shadow: var(--shadow-luxury);
}

.mainImage {
  width: 100%;
  height: 100%;
  object-fit: cover;
}

.placeholderImage {
  width: 100%;
  height: 100%;
  background: var(--background-secondary);
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  gap: var(--space-4);
  border: 2px dashed var(--border-color);
}

.placeholderImage span {
  font-size: 4rem;
}

.placeholderImage p {
  color: var(--text-secondary);
  font-size: 1.125rem;
}

/* Salon Basic Info */
.salonBasicInfo {
  display: grid;
  grid-template-rows: auto auto auto;
  gap: var(--space-4);
}

.ratingSection {
  display: flex;
  align-items: center;
  gap: var(--space-4);
}

.mainRating {
  font-size: 3rem;
  font-weight: 700;
  color: var(--primary);
  font-family: var(--font-display);
}

.reviewCount {
  font-size: 1.125rem;
  color: var(--text-secondary);
}

.locationInfo {
  display: flex;
  flex-direction: column;
  gap: var(--space-3);
  padding: var(--space-6);
  background: var(--background-secondary);
  border: 1px solid var(--border-color);
  border-radius: var(--radius-xl);
}

.locationInfo p {
  font-size: 1rem;
  color: var(--text-secondary);
  display: flex;
  align-items: center;
  gap: var(--space-2);
}

/* Quick Stats */
.quickStats {
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  gap: var(--space-3);
}

.quickStats .stat {
  padding: var(--space-4);
}

.stat {
  display: flex;
  flex-direction: column;
  align-items: center;
  padding: var(--space-6);
  background: var(--background-secondary);
  border: 1px solid var(--border-color);
  border-radius: var(--radius-xl);
  transition: all var(--transition-luxury);
  text-align: center;
}

.stat:hover {
  transform: translateY(-4px);
  box-shadow: var(--shadow-luxury);
  border-color: var(--primary);
}

.statNumber {
  font-size: 2rem;
  font-weight: 700;
  color: var(--primary);
  font-family: var(--font-display);
}

.statLabel {
  font-size: 0.875rem;
  color: var(--text-secondary);
  text-transform: uppercase;
  letter-spacing: 0.5px;
  margin-top: var(--space-2);
}

/* Section Styles */
.servicesSection,
.barbersSection,
.bookingSection,
.mapSection,
.noBarbersSection {
  max-width: 1400px;
  margin: 0 auto;
  padding: var(--space-6) var(--space-8);
}

.sectionTitle {
  font-family: var(--font-display);
  font-size: 2rem;
  font-weight: 700;
  color: var(--text-primary);
  margin-bottom: var(--space-8);
  text-align: center;
}
/* Chair Busy State */
.chairBusy {
  margin-top: 8px;
}

.chairBadgeOccupied {
  display: inline-block;
  padding: 4px 8px;
  background: rgba(255, 152, 0, 0.3);
  border-radius: 8px;
  font-size: 11px;
  font-weight: 700;
  color: #e65100;
}

.chairCustomer {
  font-size: 12px;
  margin: 4px 0;
  font-weight: 600;
}

.chairTime {
  font-size: 12px;
  color: #ff6b00;
  font-weight: 700;
}

.chairQueue {
  font-size: 11px;
  color: #999;
  margin-top: 4px;
}

.chair.occupied {
  background: rgba(255, 152, 0, 0.2);
  border-color: #ff9800;
}

/* Mini Info in Status Cards */
.miniInfo {
  font-size: 11px;
  margin-top: 4px;
  color: #666;
}

/* Real-Time Status Dashboard */
.realTimeStatus {
  background: var(--background-primary);
  padding: 30px;
  border-radius: 16px;
  max-width: 1400px;
  margin: 0 auto;
  color: white;
}

.statusTitle {
  font-size: 24px;
  font-weight: 700;
  margin-bottom: 20px;
  text-align: center;
}

.statusGrid {
  color: #000;
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
  gap: 20px;
  margin-bottom: 30px;
}

.statusCard {
  background: rgba(255, 255, 255, 0.2);
  backdrop-filter: blur(10px);
  padding: 20px;
  border-radius: 12px;
  text-align: center;
  border: 1px solid rgba(255, 255, 255, 0.3);
}

.statusIcon {
  font-size: 32px;
  margin-bottom: 10px;
}

.statusValue {
  font-size: 32px;
  font-weight: 700;
  margin: 10px 0;
}

.statusLabel {
  font-size: 14px;
  opacity: 0.9;
}

/* Chair Visualization */
.chairsSection {
  margin-top: 30px;
}

.chairsTitle {
  font-size: 20px;
  font-weight: 600;
  margin-bottom: 20px;
  text-align: center;
}

.chairsGrid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
  gap: 20px;
}

.chairItem {
  text-align: center;
}

.chair {
  width: 80px;
  height: 80px;
  margin: 0 auto 10px;
  background: rgba(255, 255, 255, 0.3);
  border-radius: 12px;
  display: flex;
  align-items: center;
  justify-content: center;
  position: relative;
  border: 2px solid rgba(255, 255, 255, 0.5);
}

.chair.available {
  background: rgba(76, 175, 80, 0.3);
  border-color: #4caf50;
}

.chairIcon {
  font-size: 36px;
}

.chairStatus {
  position: absolute;
  top: -5px;
  right: -5px;
  width: 20px;
  height: 20px;
  border-radius: 50%;
  border: 2px solid white;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 12px;
}

.chairStatus.green {
  background: #4caf50;
  animation: pulse 2s infinite;
}

.chairStatus.orange {
  background: #ff9800;
  animation: pulse 2s infinite;
}

.chairStatus.red {
  background: #f44336;
}

@keyframes pulse {
  0%,
  100% {
    opacity: 1;
  }
  50% {
    opacity: 0.6;
  }
}

.chairLabel {
  font-size: 12px;
  font-weight: 600;
  margin: 5px 0;
}

.chairBarber {
  font-size: 14px;
  margin: 5px 0;
}

.chairBadge {
  display: inline-block;
  padding: 4px 8px;
  background: rgba(76, 175, 80, 0.3);
  border-radius: 8px;
  font-size: 11px;
  font-weight: 700;
}

/* Legend */
.statusLegend {
  color: #000;
  display: flex;
  justify-content: center;
  gap: 30px;
  margin-top: 30px;
  padding-top: 20px;
  border-top: 1px solid rgba(255, 255, 255, 0.3);
}

.legendItem {
  display: flex;
  align-items: center;
  gap: 8px;
  font-size: 14px;
}

.legendDot {
  font-size: 20px;
}

.legendDot.green {
  color: #4caf50;
}

.legendDot.orange {
  color: #ff9800;
}

.legendDot.red {
  color: #f44336;
}

/* Mobile Responsive */
@media (max-width: 768px) {
  .chairsGrid {
    grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
    gap: 15px;
  }

  .chair {
    width: 60px;
    height: 60px;
  }

  .chairIcon {
    font-size: 28px;
  }

  .statusLegend {
    flex-wrap: wrap;
    gap: 15px;
  }
}

/* Services Grid */
.servicesGrid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
  gap: var(--space-4);
}

.serviceCard {
  background: var(--background-secondary);
  border: 2px solid var(--border-color);
  border-radius: var(--radius-xl);
  padding: var(--space-5);
  cursor: pointer;
  transition: all var(--transition-luxury);
  position: relative;
  overflow: hidden;
}

.serviceCard::before {
  content: "";
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 3px;
  background: linear-gradient(90deg, transparent, var(--primary), transparent);
  opacity: 0;
  transition: opacity var(--transition-normal);
}

.serviceCard:hover {
  transform: translateY(-6px);
  box-shadow: var(--shadow-luxury);
  border-color: var(--primary);
}

.serviceCard:hover::before {
  opacity: 1;
}

.serviceCard.selected {
  background: linear-gradient(
    135deg,
    rgba(212, 175, 55, 0.25),
    rgba(212, 175, 55, 0.15)
  );
  border-color: var(--primary);
  border-width: 3px;
  box-shadow: 0 0 0 4px rgba(212, 175, 55, 0.2), var(--shadow-lg);
  transform: translateY(-4px);
}

.serviceCard.selected::before {
  opacity: 1;
}

.serviceCard.selected::after {
  content: "✓";
  position: absolute;
  top: var(--space-4);
  right: var(--space-4);
  width: 32px;
  height: 32px;
  background: var(--primary);
  color: var(--black);
  border-radius: var(--radius-full);
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 1.25rem;
  font-weight: 700;
  box-shadow: var(--shadow-md);
}

.serviceName {
  font-family: var(--font-display);
  font-size: 1.5rem;
  font-weight: 700;
  color: var(--text-primary);
  margin-bottom: var(--space-3);
}

.servicePrice {
  font-size: 1.75rem;
  font-weight: 700;
  color: var(--primary);
  margin-bottom: var(--space-2);
}

.serviceDuration {
  font-size: 0.9375rem;
  color: var(--text-secondary);
  margin-bottom: var(--space-2);
}

.serviceGender {
  font-size: 0.875rem;
  color: var(--text-tertiary);
  text-transform: uppercase;
  letter-spacing: 0.5px;
}

/* Barbers Grid */
.barbersGrid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(220px, 1fr));
  gap: var(--space-4);
}

.barberCard {
  background: var(--background-secondary);
  border: 2px solid var(--border-color);
  border-radius: var(--radius-2xl);
  padding: var(--space-5);
  cursor: pointer;
  transition: all var(--transition-luxury);
  position: relative;
  overflow: hidden;
}

.barberCard::before {
  content: "";
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 3px;
  background: linear-gradient(90deg, transparent, var(--primary), transparent);
  opacity: 0;
  transition: opacity var(--transition-normal);
}

.barberCard:hover {
  transform: translateY(-6px);
  box-shadow: var(--shadow-luxury);
  border-color: var(--primary);
}

.barberCard:hover::before {
  opacity: 1;
}

.barberCard.selected {
  background: linear-gradient(
    135deg,
    rgba(212, 175, 55, 0.25),
    rgba(212, 175, 55, 0.15)
  );
  border-color: var(--primary);
  border-width: 3px;
  box-shadow: 0 0 0 4px rgba(212, 175, 55, 0.2), var(--shadow-lg);
  transform: translateY(-4px);
}

.barberCard.selected::before {
  opacity: 1;
}

.barberCard.selected .barberImage {
  border-color: var(--primary);
  border-width: 4px;
  box-shadow: 0 0 0 4px rgba(212, 175, 55, 0.3), var(--shadow-xl);
}

.barberImage {
  width: 80px;
  height: 80px;
  margin: 0 auto var(--space-4);
  border-radius: var(--radius-full);
  overflow: hidden;
  border: 3px solid var(--primary);
  box-shadow: var(--shadow-lg);
}

.barberPhoto {
  width: 100%;
  object-fit: cover;
}

.defaultBarberImage {
  width: 100%;
  height: 100%;
  background: var(--background-tertiary);
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 3rem;
}

.barberName {
  font-family: var(--font-display);
  font-size: 1.5rem;
  font-weight: 700;
  color: var(--text-primary);
  text-align: center;
  margin-bottom: var(--space-2);
}

.barberExperience {
  text-align: center;
  color: var(--text-secondary);
  font-size: 0.9375rem;
  margin-bottom: var(--space-3);
}

.barberRating {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: var(--space-2);
  font-size: 1rem;
  color: var(--text-secondary);
  margin-bottom: var(--space-4);
}

.barberSkills {
  display: flex;
  flex-wrap: wrap;
  gap: var(--space-2);
  justify-content: center;
  margin-bottom: var(--space-4);
}

.skillChip {
  padding: var(--space-2) var(--space-3);
  background: rgba(212, 175, 55, 0.1);
  border: 1px solid rgba(212, 175, 55, 0.3);
  border-radius: var(--radius-full);
  font-size: 0.75rem;
  color: var(--primary);
  font-weight: 600;
}

.barberBio {
  text-align: center;
  color: var(--text-secondary);
  font-size: 0.875rem;
  line-height: 1.6;
  font-style: italic;
}

/* Date & Time Selection */
.bookingSection {
  background: var(--background-secondary);
  border-radius: var(--radius-2xl);
  padding: var(--space-10);
  border: 1px solid var(--border-color);
}

.dateTimePicker {
  display: flex;
  flex-direction: column;
  gap: var(--space-8);
}

.dateInput {
  width: 100%;
  max-width: 400px;
  padding: var(--space-5);
  background: var(--background-primary);
  border: 2px solid var(--border-color);
  border-radius: var(--radius-lg);
  color: var(--text-primary);
  font-size: 1.125rem;
  font-family: var(--font-body);
  cursor: pointer;
  transition: all var(--transition-normal);
}

.dateInput:focus {
  outline: none;
  border-color: var(--primary);
  box-shadow: 0 0 0 3px rgba(212, 175, 55, 0.1);
}

.timeSlots {
  width: 100%;
}

.timeSlotsWrapper {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
  gap: var(--space-3);
}

.timeSlot {
  padding: var(--space-4);
  background: var(--background-primary);
  border: 2px solid var(--border-color);
  border-radius: var(--radius-lg);
  color: var(--text-primary);
  font-weight: 600;
  font-size: 1rem;
  cursor: pointer;
  transition: all var(--transition-luxury);
  text-align: center;
}

.timeSlot:hover:not(.disabled) {
  background: rgba(212, 175, 55, 0.1);
  border-color: var(--primary);
  transform: translateY(-2px);
}

.timeSlot.selected {
  background: linear-gradient(135deg, var(--primary), var(--primary-dark));
  color: var(--black);
  border-color: var(--primary);
  border-width: 3px;
  font-weight: 700;
  box-shadow: 0 0 0 4px rgba(212, 175, 55, 0.2), var(--shadow-lg);
  transform: translateY(-2px) scale(1.05);
}

.timeSlot.disabled {
  background: var(--background-tertiary);
  color: var(--text-tertiary);
  cursor: not-allowed;
  opacity: 0.5;
  border-style: dashed;
}

/* Map Section */
.mapSection {
  background: var(--background-secondary);
  border-radius: var(--radius-2xl);
  padding: var(--space-10);
  border: 1px solid var(--border-color);
  overflow: hidden;
}

/* Book Button Container */
.bookButtonContainer {
  position: fixed;
  bottom: 0;
  left: 0;
  right: 0;
  padding: var(--space-6) var(--space-8);
  background: var(--background-secondary);
  border-top: 1px solid var(--border-color);
  box-shadow: var(--shadow-xl);
  z-index: 90;
  backdrop-filter: blur(10px);
}

.bookButton {
  width: 100%;
  max-width: 600px;
  margin: 0 auto;
  padding: var(--space-5) var(--space-8);
  background: linear-gradient(135deg, var(--primary), var(--primary-dark));
  color: var(--black);
  border: none;
  border-radius: var(--radius-lg);
  font-size: 1.25rem;
  font-weight: 700;
  cursor: pointer;
  transition: all var(--transition-luxury);
  box-shadow: var(--shadow-lg), 0 0 20px rgba(212, 175, 55, 0.3);
  position: relative;
  overflow: hidden;
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: var(--space-2);
}

.bookButton::before {
  content: "";
  position: absolute;
  top: 0;
  left: -100%;
  width: 100%;
  height: 100%;
  background: linear-gradient(
    90deg,
    transparent,
    rgba(255, 255, 255, 0.3),
    transparent
  );
  transition: left 0.5s ease;
}

.bookButton:hover:not(.disabled) {
  transform: translateY(-3px);
  box-shadow: var(--shadow-xl), 0 0 30px rgba(212, 175, 55, 0.5);
}

.bookButton:hover:not(.disabled)::before {
  left: 100%;
}

.bookButton.disabled {
  background: var(--gray-400);
  cursor: not-allowed;
  transform: none;
  box-shadow: var(--shadow-sm);
}

.buttonSubtext {
  font-size: 0.875rem;
  font-weight: 500;
  opacity: 0.9;
}

/* Modal Styles */
.modalOverlay {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(0, 0, 0, 0.7);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 1000;
  padding: var(--space-6);
  backdrop-filter: blur(5px);
}

.modalContent {
  background: var(--background-primary);
  border: 1px solid var(--border-color);
  border-radius: var(--radius-2xl);
  padding: var(--space-10);
  max-width: 500px;
  width: 100%;
  box-shadow: var(--shadow-2xl);
  animation: scaleIn 0.3s ease-out;
}

.modalContent h3 {
  font-family: var(--font-display);
  font-size: 1.875rem;
  font-weight: 700;
  color: var(--text-primary);
  margin-bottom: var(--space-6);
  text-align: center;
}

.modalContent p {
  color: var(--text-secondary);
  margin-bottom: var(--space-4);
  line-height: 1.6;
}

.modalContent input {
  width: 100%;
  padding: var(--space-4);
  background: var(--background-secondary);
  border: 2px solid var(--border-color);
  border-radius: var(--radius-lg);
  color: var(--text-primary);
  font-size: 1rem;
  margin-bottom: var(--space-4);
  transition: all var(--transition-normal);
}

.modalContent input:focus {
  outline: none;
  border-color: var(--primary);
  box-shadow: 0 0 0 3px rgba(212, 175, 55, 0.1);
}

.modalActions {
  display: flex;
  gap: var(--space-4);
  margin-top: var(--space-6);
}

.confirmButton,
.cancelButton {
  flex: 1;
  padding: var(--space-4) var(--space-6);
  border: none;
  border-radius: var(--radius-lg);
  font-weight: 700;
  font-size: 1rem;
  cursor: pointer;
  transition: all var(--transition-luxury);
}

.confirmButton {
  background: linear-gradient(135deg, var(--primary), var(--primary-dark));
  color: var(--black);
  box-shadow: var(--shadow-md);
}

.confirmButton:hover {
  transform: translateY(-2px);
  box-shadow: var(--shadow-xl);
}

.cancelButton {
  background: transparent;
  color: var(--text-primary);
  border: 2px solid var(--border-color);
}

.cancelButton:hover {
  background: var(--background-secondary);
  border-color: var(--primary);
}

/* Loading State */
.loadingContainer {
  min-height: 100vh;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  background: var(--background-primary);
}

.spinner {
  width: 60px;
  height: 60px;
  border: 4px solid var(--border-color);
  border-top: 4px solid var(--primary);
  border-radius: 50%;
  margin-bottom: var(--space-6);
  animation: spin 1s linear infinite;
}

.loadingContainer p {
  font-size: 1.125rem;
  color: var(--text-secondary);
}

/* Error State */
.errorContainer {
  min-height: 100vh;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  background: var(--background-primary);
  padding: var(--space-8);
  text-align: center;
}

.errorContainer h2 {
  font-family: var(--font-display);
  font-size: 2rem;
  color: var(--text-primary);
  margin-bottom: var(--space-6);
}

/* Animations */
@keyframes spin {
  0% {
    transform: rotate(0deg);
  }
  100% {
    transform: rotate(360deg);
  }
}

@keyframes scaleIn {
  from {
    opacity: 0;
    transform: scale(0.9);
  }
  to {
    opacity: 1;
    transform: scale(1);
  }
}

/* Tablet Responsive */
@media (max-width: 1024px) {
  .heroSection {
    grid-template-columns: 1fr;
  }

  .imageGallery {
    height: 400px;
  }

  .servicesGrid {
    grid-template-columns: repeat(auto-fill, minmax(240px, 1fr));
  }

  .barbersGrid {
    grid-template-columns: repeat(auto-fill, minmax(260px, 1fr));
  }

  .quickStats {
    grid-template-columns: repeat(3, 1fr);
  }
}

/* Mobile Responsive */
@media (max-width: 768px) {
  .header {
    padding: var(--space-4) var(--space-4);
  }

  .salonName {
    font-size: 1.25rem;
  }

  .backButton {
    padding: var(--space-2) var(--space-4);
    font-size: 0.875rem;
  }

  .shareButton,
  .favoriteButton {
    width: 36px;
    height: 36px;
    font-size: 1rem;
  }

  .heroSection {
    padding: var(--space-6) var(--space-4);
  }

  .imageGallery {
    height: 300px;
  }

  .mainRating {
    font-size: 2rem;
  }

  .reviewCount {
    font-size: 0.9375rem;
  }

  .quickStats {
    grid-template-columns: 1fr 1fr;
  }

  .stat {
    padding: var(--space-4);
  }

  .statNumber {
    font-size: 1.5rem;
  }

  .servicesSection,
  .barbersSection,
  .bookingSection,
  .mapSection,
  .noBarbersSection {
    padding: var(--space-6) var(--space-4);
  }

  .sectionTitle {
    font-size: 1.5rem;
    margin-bottom: var(--space-6);
  }

  .servicesGrid {
    grid-template-columns: 1fr 1fr;
  }

  .barbersGrid {
    grid-template-columns: 1fr;
  }

  .timeSlotsWrapper {
    grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
  }

  .timeSlot {
    padding: var(--space-3);
    font-size: 0.875rem;
  }

  .bookButtonContainer {
    padding: var(--space-4);
  }

  .bookButton {
    padding: var(--space-4) var(--space-6);
    font-size: 1rem;
  }

  .modalContent {
    padding: var(--space-6);
  }

  .modalContent h3 {
    font-size: 1.5rem;
  }

  .modalActions {
    flex-direction: column;
  }
}

/* Small Mobile */
@media (max-width: 480px) {
  .salonName {
    font-size: 1rem;
  }

  .imageGallery {
    height: 250px;
  }

  .serviceCard,
  .barberCard {
    padding: var(--space-6);
  }

  .serviceName,
  .barberName {
    font-size: 1.25rem;
  }

  .barberImage {
    width: 100px;
    height: 100px;
  }

  .timeSlotsWrapper {
    grid-template-columns: repeat(3, 1fr);
  }

  .dateInput {
    font-size: 1rem;
  }
}

/* Dark Mode Specific Adjustments */
[data-theme="dark"] .serviceCard,
[data-theme="dark"] .barberCard,
[data-theme="dark"] .locationInfo,
[data-theme="dark"] .stat,
[data-theme="dark"] .bookingSection,
[data-theme="dark"] .mapSection {
  background: var(--gray-800);
  border-color: var(--gray-700);
}

[data-theme="dark"] .timeSlot {
  background: var(--gray-900);
  border-color: var(--gray-700);
}

[data-theme="dark"] .timeSlot.disabled {
  background: var(--gray-800);
}

[data-theme="dark"] .bookButtonContainer {
  background: rgba(38, 38, 38, 0.95);
  border-top-color: var(--gray-700);
}

[data-theme="dark"] .modalContent {
  background: var(--gray-800);
  border-color: var(--gray-700);
}

[data-theme="dark"] .modalContent input {
  background: var(--gray-900);
  border-color: var(--gray-700);
}

[data-theme="dark"] .dateInput {
  background: var(--gray-900);
  border-color: var(--gray-700);
}

/* Dark Mode Selected States - Brighter Gold */
[data-theme="dark"] .serviceCard.selected {
  background: linear-gradient(
    135deg,
    rgba(255, 215, 0, 0.35),
    rgba(255, 215, 0, 0.25)
  );
  border-color: #ffd700;
  box-shadow: 0 0 0 4px rgba(255, 215, 0, 0.35), var(--shadow-xl);
}

[data-theme="dark"] .serviceCard.selected::after {
  background: #ffd700;
  color: #000;
  box-shadow: 0 4px 12px rgba(255, 215, 0, 0.5);
}

[data-theme="dark"] .barberCard.selected {
  background: linear-gradient(
    135deg,
    rgba(255, 215, 0, 0.35),
    rgba(255, 215, 0, 0.25)
  );
  border-color: #ffd700;
  box-shadow: 0 0 0 4px rgba(255, 215, 0, 0.35), var(--shadow-xl);
}

[data-theme="dark"] .barberCard.selected .barberImage {
  border-color: #ffd700;
  box-shadow: 0 0 0 4px rgba(255, 215, 0, 0.4),
    0 8px 24px rgba(255, 215, 0, 0.3);
}

[data-theme="dark"] .timeSlot.selected {
  background: linear-gradient(135deg, #ffd700, #f0c000);
  color: #000;
  border-color: #ffd700;
  box-shadow: 0 0 0 4px rgba(255, 215, 0, 0.35),
    0 8px 16px rgba(255, 215, 0, 0.4);
}

/* Print Styles */
@media print {
  .header,
  .bookButtonContainer,
  .modalOverlay {
    display: none;
  }

  .container {
    background: white;
  }
}
</file>

<file path="package.json">
{
  "name": "techtrims",
  "version": "0.1.0",
  "private": true,
  "type": "module",
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start ",
    "lint": "eslint . ",
    "seed": "node scripts/seed.js"
  },
  "dependencies": {
    "@react-pdf/pdfkit": "^4.0.4",
    "@react-three/fiber": "^8.18.0",
    "axios": "^1.12.2",
    "bcryptjs": "^2.4.3",
    "cookie": "^1.0.2",
    "dotenv": "^17.2.3",
    "framer-motion": "^12.23.16",
    "jsonwebtoken": "^9.0.2",
    "jspdf": "^3.0.3",
    "jspdf-autotable": "^5.0.2",
    "leaflet": "^1.9.4",
    "lucide-react": "^0.544.0",
    "mongodb": "^6.20.0",
    "mongoose": "^7.5.0",
    "next": "^14.2.32",
    "nodemailer": "^7.0.7",
    "ogl": "^1.0.11",
    "qrcode": "^1.5.4",
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "react-leaflet": "^4.2.1",
    "react-qr-code": "^2.0.18",
    "resend": "^6.1.2",
    "swr": "^2.1.0",
    "three": "^0.180.0",
    "uuid": "^9.0.0",
    "validator": "^13.9.0"
  },
  "devDependencies": {
    "@eslint/eslintrc": "^3",
    "@tailwindcss/postcss": "^4.1.13",
    "@types/react": "^19.1.13",
    "autoprefixer": "^10.4.21",
    "eslint": "^9",
    "eslint-config-next": "15.5.3",
    "postcss": "^8.5.6",
    "tailwindcss": "^4.1.13",
    "typescript": "^5.9.2"
  }
}
</file>

<file path="src/components/Salon/SalonRegisterForm.js">
import React, { useState, useEffect } from "react";
import { MapPin, Clock, Store, Scissors, Star } from "lucide-react";
import styles from "../../styles/SalonRegister.module.css";
import dynamic from "next/dynamic";
import Link from "next/link";

// Dynamically import LocationPicker to avoid SSR issues with Leaflet
const LocationPicker = dynamic(() => import("../Maps/LocationPicker"), {
  ssr: false,
  loading: () => (
    <div className="animate-pulse bg-gray-300 h-64 rounded-xl"></div>
  ),
});

const SalonRegisterForm = () => {
  const [formData, setFormData] = useState({
    // Owner Details
    fullName: "",
    phone: "",
    email: "",
    password: "",

    // Salon Details
    salonName: "",
    address: "",
    locationData: null,
    latitude: "",
    longitude: "", // Will store coordinates and formatted address
    openingTime: "09:00",
    closingTime: "21:00",

    // Basic Services & Pricing
    services: {
      haircut: { enabled: false, price: "" },
      shave: { enabled: false, price: "" },
      hairWash: { enabled: false, price: "" },
      hairStyling: { enabled: false, price: "" },
      facial: { enabled: false, price: "" },
      hairColor: { enabled: false, price: "" },
    },
    barbers: [],
    services: {
      haircut: { enabled: false, price: "" },
      shave: { enabled: false, price: "" },
      hairWash: { enabled: false, price: "" },
      hairStyling: { enabled: false, price: "" },
      facial: { enabled: false, price: "" },
      hairColor: { enabled: false, price: "" },
    },
  });

  const [currentStep, setCurrentStep] = useState(1);
  const [isDarkMode, setIsDarkMode] = useState(false);
  const [showLocationPicker, setShowLocationPicker] = useState(false);
  const [isClient, setIsClient] = useState(false);
  const [validationErrors, setValidationErrors] = useState({});
  useEffect(() => {
    if (navigator.geolocation) {
      navigator.geolocation.getCurrentPosition((pos) => {
        setFormData((prev) => ({
          ...prev,
          latitude: prev.latitude || pos.coords.latitude,
          longitude: prev.longitude || pos.coords.longitude,
        }));
      });
    }
  }, []);
  useEffect(() => {
    setIsClient(true);
  }, []);

  const validateStep = (step) => {
    const errors = {};

    if (step === 1) {
      if (!formData.fullName) errors.fullName = "Full name is required";
      if (!formData.phone) errors.phone = "Mobile number is required";
      if (!formData.email) errors.email = "Email is required";
      if (!formData.password) errors.password = "Password is required";
      else if (formData.password.length < 6)
        errors.password = "Password must be at least 6 characters";
    }

    if (step === 2) {
      if (!formData.salonName) errors.salonName = "Salon name is required";
      if (!formData.locationData) {
        errors.location = "Please select a location on the map";
      }
      if (!formData.address) errors.address = "Address is required";
    }

    if (step === 4) {
      const enabledServices = Object.values(formData.services).some(
        (service) => service.enabled
      );
      if (!enabledServices)
        errors.services = "Please enable at least one service";
    }

    setValidationErrors(errors);
    return Object.keys(errors).length === 0;
  };

  const handleInputChange = (field, value) => {
    setFormData((prev) => ({
      ...prev,
      [field]: value,
    }));

    // Clear validation error when field is updated
    if (validationErrors[field]) {
      setValidationErrors((prev) => {
        const newErrors = { ...prev };
        delete newErrors[field];
        return newErrors;
      });
    }
  };

  const handleServiceChange = (service, field, value) => {
    setFormData((prev) => ({
      ...prev,
      services: {
        ...prev.services,
        [service]: {
          ...prev.services[service],
          [field]: value,
        },
      },
    }));
  };

  // Add barber management functions
  const addBarber = () => {
    setFormData((prev) => ({
      ...prev,
      barbers: [
        ...prev.barbers,
        {
          name: "",
          experience: "",
          skills: [],
          bio: "",
          photo: "",
          isAvailable: true,
          totalBookings: 0,
          rating: 5.0,
        },
      ],
    }));
  };

  const removeBarber = (index) => {
    setFormData((prev) => ({
      ...prev,
      barbers: prev.barbers.filter((_, i) => i !== index),
    }));
  };

  const handleBarberChange = (index, field, value) => {
    setFormData((prev) => ({
      ...prev,
      barbers: prev.barbers.map((barber, i) =>
        i === index ? { ...barber, [field]: value } : barber
      ),
    }));
  };

  const handleBarberSkillChange = (index, skill, checked) => {
    setFormData((prev) => ({
      ...prev,
      barbers: prev.barbers.map((barber, i) =>
        i === index
          ? {
              ...barber,
              skills: checked
                ? [...barber.skills, skill]
                : barber.skills.filter((s) => s !== skill),
            }
          : barber
      ),
    }));
  };

  const handleLocationSelect = (locationData) => {
    const lat = locationData.lat ? parseFloat(locationData.lat) : "";
    const lng = locationData.lng ? parseFloat(locationData.lng) : "";

    setFormData((prev) => ({
      ...prev,
      locationData: {
        lat: lat,
        lng: lng,
        address: locationData.address,
      },
      latitude: lat,
      longitude: lng,
      address: locationData.address || prev.address,
    }));
    setShowLocationPicker(false);

    if (validationErrors.location) {
      setValidationErrors((prev) => {
        const newErrors = { ...prev };
        delete newErrors.location;
        return newErrors;
      });
    }
  };

  const handleNextStep = () => {
    if (validateStep(currentStep)) {
      setCurrentStep(currentStep + 1);
    }
    if (!validateStep(currentStep)) {
      console.log("Validation failed at step", currentStep, validationErrors);
      return;
    }
    console.log("Form Data at Step", currentStep, formData);
  };

  const handlePrevStep = () => {
    setCurrentStep(currentStep - 1);
  };

  const handleSubmit = async () => {
    if (!validateStep(4)) return;

    const lat = formData.locationData?.lat || parseFloat(formData.latitude);
    const lng = formData.locationData?.lng || parseFloat(formData.longitude);

    try {
      const registrationData = {
        ownerName: formData.fullName,
        phone: formData.phone,
        email: formData.email,
        password: formData.password,
        salonName: formData.salonName,
        address: formData.locationData?.address || formData.address,
        latitude: lat,
        longitude: lng,
        coordinates: [lng, lat],
        openingTime: formData.openingTime,
        closingTime: formData.closingTime,
        services: formData.services,
        barbers: formData.barbers,
      };

      // Here you would send data to your backend API
      const response = await fetch("/api/auth/salon/register", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify(registrationData),
      });

      if (response.ok) {
        const result = await response.json();
        console.log("Registration result:", result);

        // Store salon session with proper structure
        const salonSession = {
          id: result.salon._id || result.salon.id,
          salonName: result.salon.salonName,
          ownerName: result.salon.ownerName,
          email: result.salon.email,
        };

        localStorage.setItem("salonSession", JSON.stringify(salonSession));
        localStorage.setItem("salonToken", result.token);
        // alert("Salon registered successfully! Welcome to the platform.");
        alert(
          `Salon registered successfully! ${
            result.barbersCreated || 0
          } barbers added. Welcome!`
        );

        // Redirect to dashboard or login
        window.location.href = "/auth/salon/login";
      } else {
        const error = await response.json();
        alert(`Registration failed: ${error.message}`);
      }
    } catch (error) {
      console.error("Registration error:", error);
      alert("Registration failed. Please try again.");
    }
  };

  const services = [
    { key: "haircut", label: "Haircut", icon: Scissors, defaultPrice: "200" },
    { key: "shave", label: "Shave", icon: Scissors, defaultPrice: "100" },
    {
      key: "hairWash",
      label: "Hair Wash",
      icon: Scissors,
      defaultPrice: "150",
    },
    {
      key: "hairStyling",
      label: "Hair Styling",
      icon: Scissors,
      defaultPrice: "300",
    },
    { key: "facial", label: "Facial", icon: Star, defaultPrice: "500" },
    {
      key: "hairColor",
      label: "Hair Color",
      icon: Scissors,
      defaultPrice: "800",
    },
  ];

  // Don't render until client-side to avoid hydration issues
  if (!isClient) {
    return (
      <div className="min-h-screen bg-[var(--background-primary)] flex items-center justify-center">
        <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-amber-500"></div>
      </div>
    );
  }

  return (
    <div
      className={styles.container}
      data-theme={isDarkMode ? "dark" : "light"}
    >
      {/* Header */}
      <div className={styles.header}>
        <h1 className={styles.headerTitle}>Register Your Salon</h1>
        <p className={styles.headerSubtitle}>
          Join our platform and start getting more customers
        </p>
      </div>

      {/* Progress Steps */}
      <div className={styles.progressSteps}>
        {[1, 2, 3, 4].map((step) => (
          <React.Fragment key={step}>
            <div
              className={styles.stepCircle}
              style={{
                background:
                  currentStep >= step ? "var(--primary)" : "var(--gray-400)",
                color: currentStep >= step ? "var(--black)" : "var(--black)",
              }}
            >
              {step}
            </div>
            {step < 4 && (
              <div
                className={styles.stepLine}
                style={{
                  background:
                    currentStep > step ? "var(--primary)" : "var(--gray-400)",
                }}
              />
            )}
          </React.Fragment>
        ))}
      </div>

      {/* Registration Form */}
      <div className={styles.formCard}>
        <div className="space-y-8">
          {/* Step 1: Owner Details */}
          {currentStep === 1 && (
            <div className={styles.stepContainer}>
              <h2 className={styles.stepTitle}>Owner Details</h2>
              <div className={styles.formGrid}>
                <div className={styles.formGroup}>
                  <label className={styles.formLabel}>Full Name</label>
                  <input
                    type="text"
                    placeholder="Your full name"
                    value={formData.fullName}
                    onChange={(e) =>
                      handleInputChange("fullName", e.target.value)
                    }
                    className={`${styles.formInput} ${
                      validationErrors.fullName ? styles.inputError : ""
                    }`}
                  />
                  {validationErrors.fullName && (
                    <p className={styles.errorText}>
                      {validationErrors.fullName}
                    </p>
                  )}
                </div>

                <div className={styles.formGroup}>
                  <label className={styles.formLabel}>Mobile Number</label>
                  <input
                    type="tel"
                    placeholder="+91 9876543210"
                    value={formData.phone}
                    onChange={(e) => handleInputChange("phone", e.target.value)}
                    className={`${styles.formInput} ${
                      validationErrors.phone ? styles.inputError : ""
                    }`}
                  />
                  {validationErrors.phone && (
                    <p className={styles.errorText}>{validationErrors.phone}</p>
                  )}
                </div>

                <div className={styles.formGroup}>
                  <label className={styles.formLabel}>Email</label>
                  <input
                    type="email"
                    placeholder="your.email@example.com"
                    value={formData.email}
                    onChange={(e) => handleInputChange("email", e.target.value)}
                    className={`${styles.formInput} ${
                      validationErrors.email ? styles.inputError : ""
                    }`}
                  />
                  {validationErrors.email && (
                    <p className={styles.errorText}>{validationErrors.email}</p>
                  )}
                </div>

                <div className={styles.formGroup}>
                  <label className={styles.formLabel}>Password</label>
                  <input
                    type="password"
                    placeholder="Create a strong password"
                    value={formData.password}
                    onChange={(e) =>
                      handleInputChange("password", e.target.value)
                    }
                    className={`${styles.formInput} ${
                      validationErrors.password ? styles.inputError : ""
                    }`}
                  />
                  {validationErrors.password && (
                    <p className={styles.errorText}>
                      {validationErrors.password}
                    </p>
                  )}
                </div>
              </div>
            </div>
          )}

          {/* Step 2: Salon Details */}
          {currentStep === 2 && (
            <div className={styles.stepContainer}>
              <h2 className={styles.stepTitle}>
                <Store className="w-6 h-6" />
                Salon Details
              </h2>

              <div className={styles.formGrid}>
                <div className={styles.formGroup}>
                  <label className={styles.formLabel}>Salon Name</label>
                  <input
                    type="text"
                    placeholder="Your salon name"
                    value={formData.salonName}
                    onChange={(e) =>
                      handleInputChange("salonName", e.target.value)
                    }
                    className={`${styles.formInput} ${
                      validationErrors.salonName ? styles.inputError : ""
                    }`}
                  />
                  {validationErrors.salonName && (
                    <p className={styles.errorText}>
                      {validationErrors.salonName}
                    </p>
                  )}
                </div>

                <div className={styles.formGroup}>
                  <label className={styles.formLabel}>Location Pin</label>
                  <div className={styles.inputWithIcon}>
                    <MapPin className={styles.inputIcon} />
                    <button
                      type="button"
                      className={`${styles.locationButton} ${
                        validationErrors.location ? styles.inputError : ""
                      }`}
                      onClick={() => setShowLocationPicker(true)}
                    >
                      {formData.locationData
                        ? formData.locationData.address
                        : "Set exact location on map"}
                    </button>
                    {validationErrors.location && (
                      <p className={styles.errorText}>
                        {validationErrors.location}
                      </p>
                    )}
                    {showLocationPicker && (
                      <div className={styles.modalOverlay}>
                        <div className={styles.modalContent}>
                          <button
                            className={styles.modalClose}
                            onClick={() => setShowLocationPicker(false)}
                          >
                            ✕
                          </button>
                          <LocationPicker
                            onLocationSelect={handleLocationSelect}
                          />
                        </div>
                      </div>
                    )}
                  </div>
                </div>

                <div className={`${styles.formGroup} ${styles.formGridFull}`}>
                  <label className={styles.formLabel}>Address</label>
                  <textarea
                    placeholder="Complete address with landmarks"
                    value={formData.address}
                    onChange={(e) =>
                      handleInputChange("address", e.target.value)
                    }
                    rows={3}
                    className={`${styles.textarea} ${
                      validationErrors.address ? styles.inputError : ""
                    }`}
                  />
                  {validationErrors.address && (
                    <p className={styles.errorText}>
                      {validationErrors.address}
                    </p>
                  )}
                </div>
                <input
                  type="hidden"
                  name="latitude"
                  value={formData.latitude || ""}
                />
                <input
                  type="hidden"
                  name="longitude"
                  value={formData.longitude || ""}
                />

                <div className={styles.formGroup}>
                  <label className={styles.formLabel}>Opening Time</label>
                  <div className={styles.inputWithIcon}>
                    <Clock className={styles.inputIcon} />
                    <input
                      type="time"
                      value={formData.openingTime}
                      onChange={(e) =>
                        handleInputChange("openingTime", e.target.value)
                      }
                      className={styles.formInput}
                    />
                  </div>
                </div>

                <div className={styles.formGroup}>
                  <label className={styles.formLabel}>Closing Time</label>
                  <div className={styles.inputWithIcon}>
                    <Clock className={styles.inputIcon} />
                    <input
                      type="time"
                      value={formData.closingTime}
                      onChange={(e) =>
                        handleInputChange("closingTime", e.target.value)
                      }
                      className={styles.formInput}
                    />
                  </div>
                </div>
              </div>
            </div>
          )}

          {/* Step 3: Barber Management */}
          {currentStep === 3 && (
            <div className={styles.stepContainer}>
              <h2 className={styles.stepTitle}>Add Your Barbers</h2>

              <div className="space-y-6">
                {formData.barbers.map((barber, index) => (
                  <div key={index} className={styles.barberCard}>
                    <div className={styles.barberHeader}>
                      <h3 className={styles.barberTitle}>Barber {index + 1}</h3>
                      {formData.barbers.length > 1 && (
                        <button
                          type="button"
                          onClick={() => removeBarber(index)}
                          className={styles.removeButton}
                        >
                          ✕
                        </button>
                      )}
                    </div>

                    <div className={styles.barberInputGrid}>
                      <input
                        type="text"
                        placeholder="Barber Name"
                        value={barber.name}
                        onChange={(e) =>
                          handleBarberChange(index, "name", e.target.value)
                        }
                        className={styles.formInput}
                      />

                      <input
                        type="number"
                        placeholder="Years of Experience"
                        value={barber.experience}
                        onChange={(e) =>
                          handleBarberChange(
                            index,
                            "experience",
                            e.target.value
                          )
                        }
                        className={styles.formInput}
                      />
                    </div>

                    <div className="mt-4">
                      <label className={styles.skillsLabel}>
                        Specializations
                      </label>
                      <div className={styles.skillsGrid}>
                        {[
                          "Haircut",
                          "Shaving",
                          "Hair Styling",
                          "Beard Trim",
                          "Hair Color",
                          "Facial",
                        ].map((skill) => (
                          <div key={skill} className={styles.skillCheckbox}>
                            <input
                              type="checkbox"
                              checked={barber.skills.includes(skill)}
                              onChange={(e) =>
                                handleBarberSkillChange(
                                  index,
                                  skill,
                                  e.target.checked
                                )
                              }
                            />
                            <label>{skill}</label>
                          </div>
                        ))}
                      </div>
                    </div>

                    <div className="mt-4">
                      <label className={styles.skillsLabel}>
                        Bio/Accomplishments
                      </label>
                      <textarea
                        placeholder="Describe barber's achievements, awards, etc."
                        value={barber.bio}
                        onChange={(e) =>
                          handleBarberChange(index, "bio", e.target.value)
                        }
                        rows={2}
                        className={styles.textarea}
                      />
                    </div>
                  </div>
                ))}

                <button
                  type="button"
                  onClick={addBarber}
                  className={styles.addBarberButton}
                >
                  + Add Another Barber
                </button>
              </div>
            </div>
          )}

          {/* Step 4: Services */}
          {currentStep === 4 && (
            <div className={styles.stepContainer}>
              <h2 className={styles.stepTitle}>
                <Scissors className="w-6 h-6" />
                Basic Services & Pricing
              </h2>

              {validationErrors.services && (
                <p className={styles.errorText}>{validationErrors.services}</p>
              )}

              <div className={styles.servicesGrid}>
                {services.map((service) => {
                  const Icon = service.icon;
                  return (
                    <div
                      key={service.key}
                      className={`${styles.serviceCard} ${
                        formData.services[service.key].enabled
                          ? styles.active
                          : ""
                      }`}
                    >
                      <div className={styles.serviceHeader}>
                        <div className={styles.serviceCheckbox}>
                          <input
                            type="checkbox"
                            checked={formData.services[service.key].enabled}
                            onChange={(e) =>
                              handleServiceChange(
                                service.key,
                                "enabled",
                                e.target.checked
                              )
                            }
                          />
                          <Icon className={styles.serviceIcon} />
                          <span className={styles.serviceName}>
                            {service.label}
                          </span>
                        </div>
                      </div>

                      {formData.services[service.key].enabled && (
                        <div className={styles.priceInput}>
                          <span className={styles.priceSymbol}>₹</span>
                          <input
                            type="number"
                            placeholder={service.defaultPrice}
                            value={formData.services[service.key].price}
                            onChange={(e) =>
                              handleServiceChange(
                                service.key,
                                "price",
                                e.target.value
                              )
                            }
                          />
                        </div>
                      )}
                    </div>
                  );
                })}
              </div>
            </div>
          )}

          {/* Navigation Buttons */}
          <div className={styles.navigationButtons}>
            {currentStep > 1 && (
              <button
                type="button"
                onClick={handlePrevStep}
                className={styles.prevButton}
              >
                Previous
              </button>
            )}

            {currentStep < 4 ? (
              <button
                type="button"
                onClick={handleNextStep}
                className={styles.nextButton}
              >
                Next Step
              </button>
            ) : (
              <button
                type="button"
                onClick={handleSubmit}
                className={styles.nextButton}
              >
                Register My Salon
              </button>
            )}
          </div>
        </div>

        {/* Sign In Link */}
        <div className={styles.signInSection}>
          <p className={styles.signInText}>
            Already registered?{" "}
            <Link href="/salons/login" className={styles.signInLink}>
              Sign In
            </Link>
          </p>
        </div>
      </div>
    </div>
  );
};

export default SalonRegisterForm;
</file>

<file path="src/pages/_app.js">
// pages/_app.js
import { useState, useEffect } from "react";
import { useRouter } from "next/router";
import { motion } from "framer-motion";
import "leaflet/dist/leaflet.css";
import "../styles/globals.css";
import styles from "../styles/Home.module.css";
import { UserDataManager } from "../lib/userData";
import NetworkStatus from "../components/NetworkStatus";
import OnboardingLogoutButton from "../components/OnBoardingLogout";
import GradientBackground from "@/components/Background";

function MyApp({ Component, pageProps }) {
  const router = useRouter();
  const [showLoginMenu, setShowLoginMenu] = useState(false);
  const [isMobileMenuOpen, setIsMobileMenuOpen] = useState(false);
  const [isDarkMode, setIsDarkMode] = useState(false);

  // Don't show header on onboarding pages
  const hideHeader = router.pathname.startsWith("/onboarding");

  useEffect(() => {
    // Check theme preference
    const darkMode = localStorage.getItem("darkMode") === "true";
    setIsDarkMode(darkMode);
    if (darkMode) {
      document.documentElement.setAttribute("data-theme", "dark");
    }
  }, []);

  const toggleDarkMode = () => {
    const newMode = !isDarkMode;
    setIsDarkMode(newMode);
    localStorage.setItem("darkMode", newMode.toString());

    if (newMode) {
      document.documentElement.setAttribute("data-theme", "dark");
    } else {
      document.documentElement.removeAttribute("data-theme");
    }
  };

  const navigateToAuth = (type, role) => {
    router.push(`/auth/${role}/${type}`);
  };

  return (
    <>
      <NetworkStatus />
      {!hideHeader && (
        <header className={styles.header}>
          <div className={styles.headerContent}>
            <motion.div
              className={styles.logoContainer}
              initial={{ opacity: 0, x: -30 }}
              animate={{ opacity: 1, x: 0 }}
              transition={{ duration: 0.8, ease: "easeOut" }}
            >
              <div className={styles.logoIcon}>✨</div>
              <h1 className={styles.logo}>
                <span className={styles.goldText}>Tech</span>
                <span className={styles.trimText}>Trims</span>
              </h1>
            </motion.div>

            {/* Desktop Navigation */}
            <nav className={styles.desktopNav}>
              <div className={styles.navLinks}>
                <OnboardingLogoutButton />
                <button className={styles.navLink}>Services</button>
                <button className={styles.navLink}>Salons</button>
                <button className={styles.navLink}>About</button>
              </div>

              <div className={styles.headerActions}>
                <motion.button
                  className={styles.themeToggle}
                  onClick={toggleDarkMode}
                  whileHover={{ scale: 1.1, rotate: 15 }}
                  whileTap={{ scale: 0.95 }}
                  title={
                    isDarkMode ? "Switch to Light Mode" : "Switch to Dark Mode"
                  }
                >
                  <span className={styles.themeIcon}>
                    {isDarkMode ? "☀️" : "🌙"}
                  </span>
                </motion.button>

                {UserDataManager.isLoggedIn() && (
                  <motion.button
                    className={`${styles.actionButton} ${styles.bookingButton}`}
                    whileHover={{ scale: 1.05, y: -2 }}
                    whileTap={{ scale: 0.98 }}
                    onClick={() => router.push("/user/dashboard")}
                  >
                    Dashboard
                  </motion.button>
                )}

                <motion.button
                  className={`${styles.actionButton} ${styles.ownerButton}`}
                  whileHover={{ scale: 1.05, y: -2 }}
                  whileTap={{ scale: 0.98 }}
                  onClick={() => navigateToAuth("register", "salon")}
                >
                  Register Salon
                </motion.button>

                <div className={styles.loginDropdown}>
                  <motion.button
                    className={`${styles.actionButton} ${styles.loginButton}`}
                    whileHover={{ scale: 1.05, y: -2 }}
                    whileTap={{ scale: 0.98 }}
                    onClick={() => setShowLoginMenu(!showLoginMenu)}
                  >
                    <span className={styles.buttonIcon}>👤</span>
                    Login
                    <span className={styles.dropdownArrow}>▼</span>
                  </motion.button>
                  {showLoginMenu && (
                    <motion.div
                      className={styles.loginMenu}
                      initial={{ opacity: 0, y: -10, scale: 0.95 }}
                      animate={{ opacity: 1, y: 0, scale: 1 }}
                      transition={{ duration: 0.2 }}
                    >
                      <button
                        onClick={() => {
                          router.push("/auth/user/login");
                          setShowLoginMenu(false);
                        }}
                      >
                        👤 User Login
                      </button>
                      <button
                        onClick={() => {
                          navigateToAuth("login", "salon");
                          setShowLoginMenu(false);
                        }}
                      >
                        🏪 Salon Login
                      </button>
                    </motion.div>
                  )}
                </div>
              </div>
            </nav>

            {/* Mobile Menu Button */}
            <button
              className={styles.mobileMenuButton}
              onClick={() => setIsMobileMenuOpen(!isMobileMenuOpen)}
            >
              <span
                className={`${styles.hamburgerLine} ${
                  isMobileMenuOpen ? styles.active : ""
                }`}
              ></span>
              <span
                className={`${styles.hamburgerLine} ${
                  isMobileMenuOpen ? styles.active : ""
                }`}
              ></span>
              <span
                className={`${styles.hamburgerLine} ${
                  isMobileMenuOpen ? styles.active : ""
                }`}
              ></span>
            </button>

            {/* Mobile Navigation */}
            {isMobileMenuOpen && (
              <motion.div
                className={styles.mobileNav}
                initial={{ opacity: 0, height: 0 }}
                animate={{ opacity: 1, height: "auto" }}
                transition={{ duration: 0.3 }}
              >
                <div className={styles.mobileNavLinks}>
                  <OnboardingLogoutButton />
                  <button className={styles.mobileNavLink}>Services</button>
                  <button className={styles.mobileNavLink}>Salons</button>
                  <button className={styles.mobileNavLink}>About</button>
                  <div className={styles.mobileNavDivider}></div>
                  {UserDataManager.isLoggedIn() && (
                    <button
                      className={styles.mobileNavLink}
                      onClick={() => {
                        router.push("/user/dashboard");
                        setIsMobileMenuOpen(false);
                      }}
                    >
                      Dashboard
                    </button>
                  )}
                  <button
                    className={styles.mobileNavLink}
                    onClick={() => {
                      router.push("/auth/user/login");
                      setIsMobileMenuOpen(false);
                    }}
                  >
                    👤 User Login
                  </button>
                  <button
                    className={styles.mobileNavLink}
                    onClick={() => {
                      navigateToAuth("login", "salon");
                      setIsMobileMenuOpen(false);
                    }}
                  >
                    🏪 Salon Login
                  </button>
                  <button
                    className={styles.mobileNavLink}
                    onClick={() => {
                      navigateToAuth("register", "salon");
                      setIsMobileMenuOpen(false);
                    }}
                  >
                    🏪 Register Salon
                  </button>
                </div>
              </motion.div>
            )}
          </div>
        </header>
      )}

      <Component {...pageProps} />
    </>
  );
}

export default MyApp;
</file>

<file path="src/pages/api/bookings/create.js">
import { connectToDatabase, clientPromise } from "../../../lib/mongodb";
import { ObjectId } from "mongodb";
import { updateSalonStats } from "../../../lib/statsHelper";

export default async function handler(req, res) {
  if (req.method !== "POST") {
    return res.status(405).json({ error: "Method not allowed" });
  }

  try {
    const { db, client } = await connectToDatabase();
    const {
      salonId,
      service,
      barber,
      barberId,
      date,
      time,
      user,
      price,
      customerName,
      customerPhone,
      userId,
    } = req.body;

    if (!salonId || !service || !date || !time) {
      return res.status(400).json({ error: "Missing required fields" });
    }

    const session = client.startSession ? client.startSession() : null;
    let bookingId = null;
    let finalUserId = null;

    const transactionFn = async (session) => {
      // Check for existing booking inside transaction
      const existingBooking = await db.collection("bookings").findOne(
        {
          salonId: ObjectId.isValid(salonId) ? new ObjectId(salonId) : salonId,
          date,
          time,
          status: { $ne: "cancelled" },
        },
        { session }
      );

      if (existingBooking) {
        throw new Error("Time slot already booked");
      }

      const bookingData = {
        salonId: ObjectId.isValid(salonId) ? new ObjectId(salonId) : salonId,
        service,
        barber: barber || null,
        barberId: barberId ? new ObjectId(barberId) : null,
        date,
        time,
        customerName: customerName || user?.name || "Guest",
        customerPhone:
          customerPhone ||
          user?.phoneNumber ||
          user?.phone ||
          user?.mobile ||
          "",
        customerAge: user?.age || null,
        customerGender: user?.gender || null,
        customerLocation: user?.location || null,
        price: price || 0,
        paymentStatus: "pending",
        status: "confirmed",
        userId: null,
        createdAt: new Date(),
        updatedAt: new Date(),
        feedback: {
          submitted: false,
          ratings: {},
          comment: "",
        },
      };

      const result = await db
        .collection("bookings")
        .insertOne(bookingData, { session });
      bookingId = result.insertedId;

      // Enhanced user handling - Create or find user
      if (userId && ObjectId.isValid(userId)) {
        // Authenticated user booking
        finalUserId = new ObjectId(userId);
        await db
          .collection("bookings")
          .updateOne(
            { _id: bookingId },
            { $set: { userId: finalUserId } },
            { session }
          );

        // Update user's booking history
        await db.collection("users").updateOne(
          { _id: finalUserId },
          {
            $push: { bookingHistory: bookingId },
            $set: { updatedAt: new Date() },
          },
          { session }
        );
      } else if (user && (user.phone || user.mobile)) {
        // Anonymous user booking - create or find user
        const phoneNumber = user.phone || user.mobile || customerPhone;
        let existingUser = await db.collection("users").findOne(
          {
            $or: [{ phone: phoneNumber }, { mobile: phoneNumber }],
          },
          { session }
        );

        if (!existingUser) {
          const newUser = {
            name: user.name || "Guest",
            mobile: user.phoneNumber || user.mobile,
            phone: user.phoneNumber || user.phone,
            phoneNumber: user.phoneNumber || user.mobile,
            email: user.email || null,
            gender: user.gender || "other",
            age: user.age || null,
            dateOfBirth: user.dateOfBirth || null,
            location: user.location || null,
            bookingHistory: [bookingId],
            preferences: user.preferences || {},
            createdAt: new Date(),
            updatedAt: new Date(),
            isActive: true,
          };

          const userResult = await db
            .collection("users")
            .insertOne(newUser, { session });
          finalUserId = userResult.insertedId;
        } else {
          finalUserId = existingUser._id;
          // Update existing user's booking history and preserve location data
          await db.collection("users").updateOne(
            { _id: finalUserId },
            {
              $push: { bookingHistory: bookingId },
              $set: {
                updatedAt: new Date(),
                // Update location if new location data is provided
                ...(user.location && { location: user.location }),
              },
            },
            { session }
          );
        }

        // Always link booking to user
        await db
          .collection("bookings")
          .updateOne(
            { _id: bookingId },
            { $set: { userId: finalUserId } },
            { session }
          );
      }

      // Update salon bookings array
      await db.collection("salons").updateOne(
        { _id: ObjectId.isValid(salonId) ? new ObjectId(salonId) : salonId },
        {
          $push: {
            bookings: { _id: bookingId, date, time, service, barber },
          },
          $set: { updatedAt: new Date() },
        },
        { session }
      );
    };

    if (session) {
      try {
        await session.withTransaction(async () => {
          await transactionFn(session);
        });
      } finally {
        await session.endSession();
      }
    } else {
      // fallback: not a replica set / no sessions available
      await transactionFn(null);
    }
    await updateSalonStats(salonId);

    res.status(201).json({
      success: true,
      message: "Booking created successfully",
      bookingId: bookingId,
      _id: bookingId,
      userId: finalUserId,
    });
  } catch (error) {
    if (error.message && error.message.includes("Time slot already booked")) {
      return res.status(409).json({ error: "Time slot already booked" });
    }
    console.error("Booking creation error:", error);
    res.status(500).json({ error: "Internal server error" });
  }
}
</file>

<file path="src/styles/Home.module.css">
/* Container & Layout */
.container {
  min-height: 100vh;
  background: linear-gradient(
    135deg,
    var(--background-primary) 0%,
    var(--background-secondary) 100%
  );
  position: relative;
  overflow-x: hidden;
}

/* Enhanced Loading */
.loadingContainer {
  min-height: 100vh;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  gap: var(--space-8);
  background: linear-gradient(
    135deg,
    var(--primary) 0%,
    var(--primary-dark) 100%
  );
}

.luxurySpinner {
  position: relative;
  width: 100px;
  height: 100px;
}

.spinnerRing {
  position: absolute;
  width: 100%;
  height: 100%;
  border: 4px solid transparent;
  border-top: 4px solid var(--white);
  border-radius: 50%;
  animation: spin 1.2s linear infinite;
}

.spinnerCore {
  position: absolute;
  top: 36%;
  left: 36%;
  transform: translate(-50%, -50%);
  width: 30px;
  height: 30px;
  background: var(--white);
  border-radius: 50%;
  animation: pulse 1.8s ease-in-out infinite;
}

.loadingText {
  color: var(--white);
  font-size: 1.25rem;
  font-weight: 600;
  font-family: var(--font-display);
}

/* Enhanced Header */
.header {
  position: sticky;
  top: 0;
  z-index: 10;
  background: rgba(255, 255, 255, 0.95);
  backdrop-filter: blur(20px);
  transition: all var(--transition-normal);
}

[data-theme="dark"] .header {
  background: rgba(23, 23, 23, 0.95);
}

.headerContent {
  max-width: 1400px;
  margin: 0 auto;
  padding: 0 var(--space-6);
  display: flex;
  align-items: center;
  justify-content: space-between;
  height: 80px;
}

.logoContainer {
  display: flex;
  align-items: center;
  gap: var(--space-3);
}

.logoIcon {
  font-size: 2rem;
  animation: float 3s ease-in-out infinite;
}

.logo {
  font-family: var(--font-display);
  font-size: 2rem;
  font-weight: 800;
  color: var(--text-primary);
  display: flex;
  align-items: baseline;
  gap: var(--space-1);
}

.goldText {
  background: linear-gradient(
    135deg,
    var(--primary) 0%,
    var(--primary-dark) 100%
  );
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
}

.trimText {
  color: var(--text-primary);
}

/* Desktop Navigation */
.desktopNav {
  display: flex;
  align-items: center;
  gap: var(--space-8);
}

.navLinks {
  display: flex;
  align-items: center;
  gap: var(--space-6);
}

.navLink {
  background: none;
  border: none;
  color: var(--text-secondary);
  font-weight: 500;
  font-size: 0.95rem;
  cursor: pointer;
  padding: var(--space-2) var(--space-3);
  border-radius: var(--radius-md);
  transition: all var(--transition-normal);
  position: relative;
}

.navLink::after {
  content: "";
  position: absolute;
  bottom: 0;
  left: 50%;
  width: 0;
  height: 2px;
  background: linear-gradient(135deg, var(--primary), var(--primary-dark));
  transition: all var(--transition-normal);
  transform: translateX(-50%);
}

.navLink:hover {
  color: var(--primary);
  transform: translateY(-1px);
}

.navLink:hover::after {
  width: 100%;
}

.headerActions {
  display: flex;
  align-items: center;
  gap: var(--space-4);
}

.themeToggle {
  display: flex;
  align-items: center;
  justify-content: center;
  width: 44px;
  height: 44px;
  border: none;
  background: var(--background-secondary);
  border-radius: var(--radius-full);
  cursor: pointer;
  transition: all var(--transition-normal);
  position: relative;
  overflow: hidden;
}

.themeToggle:hover {
  background: var(--primary);
  transform: scale(1.1);
}

.themeIcon {
  font-size: 1.25rem;
  transition: transform var(--transition-normal);
}

.themeToggle:hover .themeIcon {
  transform: rotate(15deg) scale(1.1);
}

.actionButton {
  display: flex;
  align-items: center;
  gap: var(--space-2);
  padding: var(--space-3) var(--space-5);
  border-radius: var(--radius-full);
  font-weight: 600;
  font-size: 0.875rem;
  cursor: pointer;
  transition: all var(--transition-luxury);
  position: relative;
  overflow: hidden;
  border: none;
}

.actionButton::before {
  content: "";
  position: absolute;
  top: 0;
  left: -100%;
  width: 100%;
  height: 100%;
  background: linear-gradient(
    90deg,
    transparent,
    rgba(255, 255, 255, 0.2),
    transparent
  );
  transition: left 0.5s ease;
}

.actionButton:hover::before {
  left: 100%;
}

.bookingButton {
  background: transparent;
  color: var(--primary);
  border: 2px solid var(--primary);
}

.bookingButton:hover {
  background: var(--primary);
  color: var(--black);
  transform: translateY(-2px);
  box-shadow: var(--shadow-lg);
}

.ownerButton {
  background: rgba(var(--primary), 0.1);
  color: var(--primary);
  border: 1px solid rgba(var(--primary), 0.3);
}

.ownerButton:hover {
  background: var(--primary);
  color: var(--black);
  transform: translateY(-2px);
}

.loginButton {
  background: linear-gradient(
    135deg,
    var(--primary) 0%,
    var(--primary-dark) 100%
  );
  color: var(--black);
  border: none;
  box-shadow: var(--shadow-md);
}

.loginButton:hover {
  transform: translateY(-2px) scale(1.02);
  box-shadow: var(--shadow-lg);
}

.buttonIcon {
  font-size: 1rem;
}

.dropdownArrow {
  font-size: 0.75rem;
  transition: transform var(--transition-normal);
}

.loginButton:hover .dropdownArrow {
  transform: rotate(180deg);
}

/* Login Dropdown */
.loginDropdown {
  position: relative;
}

.loginMenu {
  position: absolute;
  top: calc(100% + var(--space-2));
  right: 0;
  background: var(--background-primary);
  border: 1px solid var(--border-color);
  border-radius: var(--radius-xl);
  box-shadow: var(--shadow-xl);
  min-width: 200px;
  z-index: 10;
  overflow: hidden;
}
.card,
.salonCard,
.serviceCard,
.noSalons {
  background: rgba(255, 255, 255, 0.25); /* White with 25% opacity */
  border-radius: 16px;
  box-shadow: 0 4px 32px 0 rgba(34, 34, 80, 0.15),
    0 1.5px 18px 0 rgba(212, 175, 55, 0.05);
  backdrop-filter: blur(18px) saturate(160%);
  -webkit-backdrop-filter: blur(18px) saturate(160%);
  border: 1.5px solid rgba(255, 255, 255, 0.35);
  padding: 24px;
  transition: all 0.3s cubic-bezier(0.4, 0.01, 0, 1);
}
.loginMenu button {
  width: 100%;
  padding: var(--space-4) var(--space-5);
  text-align: left;
  background: none;
  border: none;
  cursor: pointer;
  font-size: 0.9rem;
  color: var(--text-primary);
  transition: all var(--transition-normal);
  display: flex;
  align-items: center;
  gap: var(--space-3);
}

.loginMenu button:hover {
  background: var(--background-secondary);
  color: var(--primary);
}

.loginMenu button:first-child:hover {
  border-radius: var(--radius-xl) var(--radius-xl) 0 0;
}

.loginMenu button:last-child:hover {
  border-radius: 0 0 var(--radius-xl) var(--radius-xl);
}

/* Mobile Menu */
.mobileMenuButton {
  display: none;
  flex-direction: column;
  justify-content: space-around;
  width: 40px;
  height: 40px;
  background: transparent;
  border: none;
  cursor: pointer;
  padding: var(--space-2);
}

.hamburgerLine {
  width: 100%;
  height: 3px;
  background: var(--text-primary);
  border-radius: var(--radius-sm);
  transition: all var(--transition-normal);
  transform-origin: center;
}

.hamburgerLine.active:nth-child(1) {
  transform: rotate(45deg) translateY(8px);
}

.hamburgerLine.active:nth-child(2) {
  opacity: 0;
}

.hamburgerLine.active:nth-child(3) {
  transform: rotate(-45deg) translateY(-8px);
}

.mobileNav {
  position: absolute;
  top: 100%;
  left: 0;
  right: 0;
  background: var(--background-primary);
  border-top: 1px solid var(--border-color);
  box-shadow: var(--shadow-lg);
  overflow: hidden;
}

.mobileNavLinks {
  padding: var(--space-6);
  display: flex;
  flex-direction: column;
  gap: var(--space-4);
}

.mobileNavLink {
  background: none;
  border: none;
  color: var(--text-primary);
  font-weight: 500;
  font-size: 1rem;
  cursor: pointer;
  padding: var(--space-4);
  text-align: left;
  border-radius: var(--radius-lg);
  transition: all var(--transition-normal);
  display: flex;
  align-items: center;
  gap: var(--space-3);
}

.mobileNavLink:hover {
  background: var(--background-secondary);
  color: var(--primary);
  transform: translateX(var(--space-2));
}

.mobileNavDivider {
  height: 1px;
  background: var(--border-color);
  margin: var(--space-2) 0;
}
/* Booking Type Tabs */
.bookingTypeTabs {
  display: flex;
  gap: 12px;
  margin: 20px 0;
  justify-content: center;
}

.bookingTypeTab {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 12px 24px;
  background: var(--background-primary);
  border: 2px solid var(--border-color);
  border-radius: 12px;
  cursor: pointer;
  transition: all 0.3s ease;
  font-size: 16px;
  font-weight: 600;
  color: var(--text-secondary);
}

.bookingTypeTab:hover {
  border-color: var(--gold-primary);
  transform: translateY(-2px);
}

.bookingTypeTab.activeTab {
  background: linear-gradient(
    135deg,
    var(--gold-primary) 0%,
    var(--gold-dark) 100%
  );
  border-color: var(--gold-primary);
  color: var(--contrast-dark);
  box-shadow: 0 8px 20px rgba(212, 175, 55, 0.3);
}

.tabIcon {
  font-size: 20px;
}

.tabLabel {
  font-weight: 600;
}

.tabBadge {
  background: rgba(0, 0, 0, 0.2);
  padding: 2px 8px;
  border-radius: 8px;
  font-size: 11px;
  font-weight: 700;
  text-transform: uppercase;
}

.activeTab .tabBadge {
  background: rgba(0, 0, 0, 0.3);
}

/* Walk-in Container */
.walkInContainer {
  margin-top: 30px;
}

.walkInInfo {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 12px;
  padding: 16px;
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  border-radius: 12px;
  margin-bottom: 30px;
  color: white;
}

.walkInIcon {
  font-size: 24px;
}

.walkInInfo p {
  margin: 0;
  font-size: 16px;
  font-weight: 500;
}

.walkInBadge {
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%) !important;
  color: white !important;
  animation: pulse 2s infinite;
}

.walkInButton {
  width: 100%;
  padding: 12px;
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  color: white;
  border: none;
  border-radius: 8px;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.3s ease;
}

.walkInButton:hover {
  transform: translateY(-2px);
  box-shadow: 0 8px 25px rgba(102, 126, 234, 0.4);
}

@keyframes pulse {
  0%,
  100% {
    opacity: 1;
  }
  50% {
    opacity: 0.8;
  }
}

/* Mobile Responsive */
@media (max-width: 768px) {
  .bookingTypeTabs {
    flex-direction: column;
    width: 100%;
  }

  .bookingTypeTab {
    width: 100%;
    justify-content: center;
  }

  .walkInInfo {
    flex-direction: column;
    text-align: center;
  }
}

/* Hero Section */
.heroSection {
  position: relative;
  min-height: calc(100vh - 80px);
  display: flex;
  align-items: center;
  padding: var(--space-20) 0;
  overflow: hidden;
}

.heroBackground {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  z-index: -2;
}

.heroPattern {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: radial-gradient(
      circle at 25% 25%,
      rgba(212, 175, 55, 0.1) 0%,
      transparent 25%
    ),
    radial-gradient(
      circle at 75% 75%,
      rgba(212, 175, 55, 0.05) 0%,
      transparent 25%
    ),
    radial-gradient(
      circle at 50% 10%,
      rgba(212, 175, 55, 0.08) 0%,
      transparent 20%
    );
  animation: float 8s ease-in-out infinite;
}

.floatingElements {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  pointer-events: none;
  z-index: -1;
}

.floatingElement {
  position: absolute;
  font-size: 2rem;
  opacity: 0.6;
  animation: float 6s ease-in-out infinite;
}

.element1 {
  top: 20%;
  left: 10%;
  animation-delay: 0s;
}

.element2 {
  top: 30%;
  right: 15%;
  animation-delay: 1.5s;
}

.element3 {
  bottom: 30%;
  left: 20%;
  animation-delay: 3s;
}

.element4 {
  bottom: 20%;
  right: 25%;
  animation-delay: 4.5s;
}

.heroContent {
  max-width: 1400px;
  margin: 0 auto;
  padding: 0 var(--space-6);
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: var(--space-16);
  align-items: center;
}

.heroLeft {
  display: flex;
  flex-direction: column;
  gap: var(--space-8);
}

.heroTextContainer {
  display: flex;
  flex-direction: column;
  gap: var(--space-6);
}

.heroTitle {
  font-family: var(--font-display);
  font-size: clamp(2.5rem, 5vw, 4rem);
  font-weight: 800;
  line-height: 1.1;
  color: var(--text-primary);
}

.heroNameHighlight {
  background: linear-gradient(
    135deg,
    var(--primary) 0%,
    var(--primary-dark) 100%
  );
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
  position: relative;
}

.heroSubtitle {
  font-size: 1.25rem;
  color: var(--text-secondary);
  line-height: 1.6;
  max-width: 90%;
}

.locationHighlight {
  color: var(--primary);
  font-weight: 600;
}

.heroStats {
  display: flex;
  gap: var(--space-8);
  margin: var(--space-6) 0;
}

.heroStat {
  display: flex;
  align-items: center;
  gap: var(--space-3);
  padding: var(--space-4) var(--space-5);
  background: rgba(212, 175, 55, 0.1);
  border-radius: var(--radius-xl);
  border: 1px solid rgba(212, 175, 55, 0.2);
}

.statIcon {
  font-size: 1.5rem;
}

.statContent {
  display: flex;
  flex-direction: column;
  gap: var(--space-1);
}

.statNumber {
  font-size: 1.5rem;
  font-weight: 800;
  color: var(--primary);
  font-family: var(--font-display);
}

.statLabel {
  font-size: 0.875rem;
  color: var(--text-secondary);
  font-weight: 500;
}

.heroActions {
  display: flex;
  gap: var(--space-4);
}

.heroCta {
  display: flex;
  align-items: center;
  gap: var(--space-3);
  padding: var(--space-5) var(--space-8);
  border-radius: var(--radius-full);
  font-weight: 700;
  font-size: 1rem;
  cursor: pointer;
  transition: all var(--transition-luxury);
  position: relative;
  overflow: hidden;
  border: none;
}

.heroCta.primary {
  background: linear-gradient(
    135deg,
    var(--primary) 0%,
    var(--primary-dark) 100%
  );
  color: var(--black);
  box-shadow: var(--shadow-lg);
}

.heroCta.primary:hover {
  transform: translateY(-3px) scale(1.02);
  box-shadow: var(--shadow-xl);
}

.heroCta.secondary {
  background: transparent;
  color: var(--primary);
  border: 2px solid var(--primary);
}

.heroCta.secondary:hover {
  background: var(--primary);
  color: var(--black);
  transform: translateY(-3px);
}

.ctaIcon {
  font-size: 1.25rem;
}

/* Hero Right - Visuals */
.heroRight {
  position: relative;
  height: 600px;
}

.heroVisuals {
  position: relative;
  width: 100%;
  height: 100%;
}

.visualsContainer {
  position: relative;
  width: 100%;
  height: 100%;
}

.mainImage {
  position: relative;
  width: 80%;
  height: 70%;
  border-radius: var(--radius-3xl);
  overflow: hidden;
  box-shadow: var(--shadow-2xl);
  margin-left: auto;
}

.heroImage {
  width: 100%;
  height: 100%;
  object-fit: cover;
  transition: transform var(--transition-slow);
}

.mainImage:hover .heroImage {
  transform: scale(1.05);
}

.imageGradient {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: linear-gradient(
    45deg,
    rgba(212, 175, 55, 0.2) 0%,
    transparent 50%
  );
  pointer-events: none;
}

.floatingCards {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  pointer-events: none;
}

.floatingCard {
  position: absolute;
  background: var(--background-primary);
  border: 1px solid var(--border-color);
  border-radius: var(--radius-2xl);
  padding: var(--space-4) var(--space-5);
  box-shadow: var(--shadow-xl);
  display: flex;
  align-items: center;
  gap: var(--space-3);
  backdrop-filter: blur(10px);
  min-width: 180px;
}

.card1 {
  top: 10%;
  left: -10%;
  transform: rotate(-5deg);
}

.card2 {
  top: 40%;
  right: -15%;
  transform: rotate(8deg);
}

.card3 {
  bottom: 15%;
  left: 5%;
  transform: rotate(-3deg);
}

.cardIcon {
  font-size: 1.5rem;
}

.cardText {
  display: flex;
  flex-direction: column;
}

.cardTitle {
  font-weight: 600;
  color: var(--text-primary);
  font-size: 0.875rem;
}

.cardPrice {
  color: var(--primary);
  font-weight: 700;
  font-size: 0.75rem;
}

.decorativeShapes {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  pointer-events: none;
  z-index: -1;
}

.shape {
  position: absolute;
  border-radius: 50%;
  opacity: 0.6;
}

.shape1 {
  top: 20%;
  right: 10%;
  width: 60px;
  height: 60px;
  background: linear-gradient(135deg, var(--primary), transparent);
  animation: float 4s ease-in-out infinite;
}

.shape2 {
  bottom: 30%;
  left: 0%;
  width: 40px;
  height: 40px;
  background: linear-gradient(135deg, var(--accent), transparent);
  animation: float 5s ease-in-out infinite reverse;
}

.shape3 {
  top: 60%;
  right: 30%;
  width: 30px;
  height: 30px;
  background: linear-gradient(135deg, var(--primary-light), transparent);
  animation: float 6s ease-in-out infinite;
}

/* Search Section */
.searchSection {
  max-width: 1000px;
  margin: 0 auto;
  padding: var(--space-20) var(--space-6);
}

.searchContainer {
  display: flex;
  flex-direction: column;
  gap: var(--space-8);
  align-items: center;
}

.searchBox {
  width: 100%;
  max-width: 700px;
  position: relative;
}

.searchInputWrapper {
  display: flex;
  align-items: center;
  background: var(--background-primary);
  border: 2px solid var(--border-color);
  border-radius: var(--radius-full);
  padding: var(--space-2);
  box-shadow: var(--shadow-lg);
  transition: all var(--transition-normal);
}

.searchInputWrapper:hover {
  border-color: var(--primary);
  box-shadow: var(--shadow-xl);
}

.searchIcon {
  padding: 0 var(--space-4);
  font-size: 1.25rem;
  color: var(--text-secondary);
}

.searchInput {
  flex: 1;
  border: none;
  outline: none;
  padding: var(--space-4) var(--space-2);
  font-size: 1rem;
  color: var(--text-primary);
  background: transparent;
}

.searchInput::placeholder {
  color: var(--text-tertiary);
}

.searchButton {
  background: linear-gradient(
    135deg,
    var(--primary) 0%,
    var(--primary-dark) 100%
  );
  color: var(--black);
  border: none;
  padding: var(--space-4) var(--space-8);
  border-radius: var(--radius-full);
  font-weight: 600;
  cursor: pointer;
  transition: all var(--transition-luxury);
  box-shadow: var(--shadow-md);
}

.searchButton:hover {
  transform: scale(1.05);
  box-shadow: var(--shadow-lg);
}

.quickFilters {
  display: flex;
  align-items: center;
  gap: var(--space-3);
  flex-wrap: wrap;
  justify-content: center;
}

.filtersLabel {
  font-weight: 600;
  color: var(--text-secondary);
  margin-right: var(--space-2);
}

.filterChip {
  display: flex;
  align-items: center;
  gap: var(--space-2);
  padding: var(--space-3) var(--space-5);
  background: var(--background-primary);
  border: 2px solid var(--border-color);
  border-radius: var(--radius-full);
  font-size: 0.875rem;
  font-weight: 500;
  cursor: pointer;
  transition: all var(--transition-normal);
  position: relative;
  overflow: hidden;
}

.filterChip::before {
  content: "";
  position: absolute;
  top: 0;
  left: -100%;
  width: 100%;
  height: 100%;
  background: var(--filter-color, var(--primary));
  opacity: 0.1;
  transition: left var(--transition-normal);
}

.filterChip:hover::before {
  left: 0;
}

.filterChip:hover {
  border-color: var(--filter-color, var(--primary));
  color: var(--filter-color, var(--primary));
  transform: translateY(-2px);
  box-shadow: var(--shadow-md);
}

.filterIcon {
  font-size: 1rem;
}

/* Services Section */
.servicesSection {
  max-width: 1400px;
  margin: 0 auto;
  padding: var(--space-24) var(--space-6);
}

.sectionHeader {
  text-align: center;
  margin-bottom: var(--space-16);
}

.sectionTitleContainer {
  display: flex;
  flex-direction: column;
  gap: var(--space-4);
  align-items: center;
}

.sectionTitle {
  font-family: var(--font-display);
  font-size: clamp(2rem, 4vw, 3rem);
  font-weight: 800;
  color: var(--text-primary);
  position: relative;
}

.sectionTitle::after {
  content: "";
  position: absolute;
  bottom: -8px;
  left: 50%;
  transform: translateX(-50%);
  width: 60px;
  height: 4px;
  background: linear-gradient(135deg, var(--primary), var(--primary-dark));
  border-radius: var(--radius-sm);
}

.sectionSubtitle {
  font-size: 1.125rem;
  color: var(--text-secondary);
  max-width: 600px;
}

.servicesGrid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
  gap: var(--space-8);
}

.serviceCard {
  position: relative;
  background: var(--background-primary);
  border: 1px solid var(--border-color);
  border-radius: var(--radius-3xl);
  padding: var(--space-10);
  text-align: center;
  transition: all var(--transition-luxury);
  cursor: pointer;
  overflow: hidden;
}

.serviceCardBackground {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: linear-gradient(
    135deg,
    rgba(212, 175, 55, 0.05) 0%,
    transparent 100%
  );
  opacity: 0;
  transition: opacity var(--transition-normal);
}

.serviceCard:hover .serviceCardBackground {
  opacity: 1;
}

.serviceCard:hover {
  border-color: var(--primary);
  box-shadow: var(--shadow-luxury);
}

.serviceIcon {
  font-size: 3rem;
  margin-bottom: var(--space-6);
  display: block;
}

.serviceName {
  font-family: var(--font-display);
  font-size: 1.5rem;
  font-weight: 700;
  margin-bottom: var(--space-4);
  color: var(--text-primary);
}

.serviceDetails {
  display: flex;
  justify-content: center;
  align-items: center;
  gap: var(--space-6);
  margin-bottom: var(--space-6);
}

.servicePrice {
  font-size: 1.75rem;
  font-weight: 800;
  color: var(--primary);
  font-family: var(--font-display);
}

.serviceDuration {
  font-size: 0.875rem;
  color: var(--text-secondary);
  display: flex;
  align-items: center;
  gap: var(--space-1);
}

.serviceBookButton {
  width: 100%;
  padding: var(--space-4) var(--space-6);
  background: transparent;
  color: var(--primary);
  border: 2px solid var(--primary);
  border-radius: var(--radius-full);
  font-weight: 600;
  cursor: pointer;
  transition: all var(--transition-luxury);
}

.serviceBookButton:hover {
  background: var(--primary);
  color: var(--black);
  transform: translateY(-2px);
  box-shadow: var(--shadow-lg);
}

/* Salons Section */
.salonsSection {
  max-width: 1400px;
  margin: 0 auto;
  padding: var(--space-24) var(--space-6);
  background: rgba(255, 255, 255, 0.25); /* White with 25% opacity */
  border-radius: 16px;
  box-shadow: 0 4px 32px 0 rgba(34, 34, 80, 0.15),
    0 1.5px 18px 0 rgba(212, 175, 55, 0.05);
  backdrop-filter: blur(18px) saturate(160%);
  -webkit-backdrop-filter: blur(18px) saturate(160%);
  border: 1.5px solid rgba(255, 255, 255, 0.35);
  padding: 24px;
  transition: all 0.3s cubic-bezier(0.4, 0.01, 0, 1);

  margin-top: var(--space-16);
}

.viewOptions {
  display: flex;
  gap: var(--space-2);
  background: rgba(255, 255, 255, 0.25); /* White with 25% opacity */
  border-radius: 16px;
  box-shadow: 0 4px 32px 0 rgba(34, 34, 80, 0.15),
    0 1.5px 18px 0 rgba(212, 175, 55, 0.05);
  backdrop-filter: blur(18px) saturate(160%);
  -webkit-backdrop-filter: blur(18px) saturate(160%);
  border: 1.5px solid rgba(255, 255, 255, 0.35);
  padding: 24px;
  transition: all 0.3s cubic-bezier(0.4, 0.01, 0, 1);
  padding: var(--space-1);
  border-radius: var(--radius-full);
  width: fit-content;
}

.viewToggle {
  display: flex;
  align-items: center;
  gap: var(--space-2);
  padding: var(--space-3) var(--space-6);
  background: transparent;
  color: var(--text-secondary);
  border: none;
  border-radius: var(--radius-full);
  font-weight: 600;
  font-size: 0.875rem;
  cursor: pointer;
  transition: all var(--transition-normal);
}

.viewToggle.active {
  background: var(--background-primary);
  color: var(--primary);
  box-shadow: var(--shadow-sm);
}

.viewToggle:hover:not(.active) {
  background: rgba(212, 175, 55, 0.1);
  color: var(--primary);
}

.viewIcon {
  font-size: 1rem;
}

.mapContainer {
  margin-top: var(--space-8);
  border-radius: var(--radius-3xl);
  overflow: hidden;
  box-shadow: var(--shadow-xl);
  height: 600px;
}

.loadingSalons {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  padding: var(--space-20);
  gap: var(--space-6);
}

.loadingSalons p {
  color: var(--text-secondary);
  font-size: 1.125rem;
  font-weight: 500;
}

.salonsGrid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(380px, 1fr));
  gap: var(--space-8);
  margin-top: var(--space-8);
}

.salonCard {
  background: var(--background-primary);
  border: 1px solid var(--border-color);
  border-radius: var(--radius-3xl);
  overflow: hidden;
  transition: all var(--transition-luxury);
  cursor: pointer;
  position: relative;
}

.salonCard::before {
  content: "";
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: linear-gradient(
    135deg,
    rgba(212, 175, 55, 0.1) 0%,
    transparent 100%
  );
  opacity: 0;
  transition: opacity var(--transition-normal);
  z-index: 1;
  pointer-events: none;
}

.salonCard:hover::before {
  opacity: 1;
}

.salonCard:hover {
  border-color: var(--primary);
  box-shadow: var(--shadow-luxury);
}

.salonImageContainer {
  position: relative;
  height: 240px;
  overflow: hidden;
}

.salonImage {
  width: 100%;
  height: 100%;
  object-fit: cover;
  transition: transform var(--transition-slow);
}

.salonCard:hover .salonImage {
  transform: scale(1.05);
}

.salonImageOverlay {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  border-radius: 1rem;
  background: linear-gradient(45deg, rgba(0, 0, 0, 0.1) 0%, transparent 50%);
}

.salonBadges {
  position: absolute;
  top: var(--space-4);
  left: var(--space-4);
  right: var(--space-4);
  display: flex;
  justify-content: space-between;
  z-index: 2;
}

.salonBadge {
  padding: var(--space-2) var(--space-4);
  border-radius: var(--radius-full);
  font-size: 0.75rem;
  font-weight: 700;
  backdrop-filter: blur(10px);
}

.primaryBadge {
  background: linear-gradient(
    135deg,
    var(--primary) 0%,
    var(--primary-dark) 100%
  );
  color: var(--black);
}

.distanceBadge {
  background: rgba(0, 0, 0, 0.7);
  color: var(--white);
}

.salonInfo {
  padding: var(--space-8);
  position: relative;
  z-index: 2;
}

.salonHeader {
  display: flex;
  justify-content: space-between;
  align-items: flex-start;
  margin-bottom: var(--space-4);
}

.salonName {
  font-family: var(--font-display);
  font-size: 1.5rem;
  font-weight: 700;
  color: var(--text-primary);
  margin: 0;
  line-height: 1.2;
}

.salonRating {
  display: flex;
  flex-direction: column;
  align-items: flex-end;
  gap: var(--space-1);
}

.ratingStars {
  font-size: 0.875rem;
  filter: grayscale(0.7);
  transition: filter var(--transition-normal);
}

.salonCard:hover .ratingStars {
  filter: grayscale(0);
}

.ratingNumber {
  font-size: 0.875rem;
  font-weight: 700;
  color: var(--primary);
}

.salonLocation {
  color: var(--text-secondary);
  font-size: 0.875rem;
  margin-bottom: var(--space-5);
  display: flex;
  align-items: center;
  gap: var(--space-2);
}

.salonMetrics {
  display: flex;
  gap: var(--space-6);
  margin-bottom: var(--space-6);
}

.metric {
  display: flex;
  align-items: center;
  gap: var(--space-2);
}

.metricIcon {
  font-size: 0.875rem;
  color: var(--text-secondary);
}

.metricValue {
  font-size: 0.875rem;
  color: var(--text-secondary);
  font-weight: 500;
}

.salonServices {
  display: flex;
  flex-wrap: wrap;
  gap: var(--space-2);
  margin-bottom: var(--space-8);
}

.serviceTag {
  background: var(--background-secondary);
  color: var(--text-secondary);
  padding: var(--space-2) var(--space-3);
  border-radius: var(--radius-full);
  font-size: 0.75rem;
  font-weight: 500;
  border: 1px solid var(--border-color);
  transition: all var(--transition-normal);
}

.serviceTag:hover {
  background: rgba(212, 175, 55, 0.1);
  border-color: var(--primary);
  color: var(--primary);
}

.serviceTag strong {
  color: var(--primary);
  margin-left: var(--space-1);
}

.salonBookButton {
  width: 100%;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: var(--space-3);
  padding: var(--space-5) var(--space-6);
  background: linear-gradient(
    135deg,
    var(--primary) 0%,
    var(--primary-dark) 100%
  );
  color: var(--black);
  border: none;
  border-radius: var(--radius-full);
  font-weight: 700;
  font-size: 1rem;
  cursor: pointer;
  transition: all var(--transition-luxury);
  position: relative;
  overflow: hidden;
}

.salonBookButton::before {
  content: "";
  position: absolute;
  top: 0;
  left: -100%;
  width: 100%;
  height: 100%;
  background: linear-gradient(
    90deg,
    transparent,
    rgba(255, 255, 255, 0.3),
    transparent
  );
  transition: left 0.5s ease;
}

.salonBookButton:hover::before {
  left: 100%;
}

.salonBookButton:hover {
  transform: translateY(-3px) scale(1.02);
  box-shadow: var(--shadow-xl);
}

.bookButtonIcon {
  font-size: 1.125rem;
}

.bookButtonArrow {
  font-size: 1.125rem;
  transition: transform var(--transition-normal);
}

.salonBookButton:hover .bookButtonArrow {
  transform: translateX(var(--space-1));
}

/* No Salons State */
.noSalons {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  padding: var(--space-20);
  text-align: center;
  background: var(--background-secondary);
  border-radius: var(--radius-3xl);
  border: 2px dashed var(--border-color);
  margin-top: var(--space-8);
}

.noSalonsIcon {
  font-size: 4rem;
  margin-bottom: var(--space-6);
  opacity: 0.6;
}

.noSalonsTitle {
  font-family: var(--font-display);
  font-size: 1.5rem;
  font-weight: 700;
  color: var(--text-primary);
  margin-bottom: var(--space-4);
}

.noSalonsText {
  color: var(--text-secondary);
  font-size: 1rem;
  margin-bottom: var(--space-8);
  max-width: 400px;
}

.registerSalonButton {
  display: flex;
  align-items: center;
  gap: var(--space-3);
  padding: var(--space-5) var(--space-8);
  background: linear-gradient(
    135deg,
    var(--primary) 0%,
    var(--primary-dark) 100%
  );
  color: var(--black);
  border: none;
  border-radius: var(--radius-full);
  font-weight: 700;
  font-size: 1rem;
  cursor: pointer;
  transition: all var(--transition-luxury);
  box-shadow: var(--shadow-lg);
}

.registerSalonButton:hover {
  transform: translateY(-3px) scale(1.05);
  box-shadow: var(--shadow-xl);
}

.registerIcon {
  font-size: 1.25rem;
}

/* Testimonials Section */
.testimonialsSection {
  max-width: 1400px;
  margin: 0 auto;
  background: rgba(255, 255, 255, 0.25); /* White with 25% opacity */
  border-radius: 16px;
  box-shadow: 0 4px 32px 0 rgba(34, 34, 80, 0.15),
    0 1.5px 18px 0 rgba(212, 175, 55, 0.05);
  backdrop-filter: blur(18px) saturate(160%);
  -webkit-backdrop-filter: blur(18px) saturate(160%);
  border: 1.5px solid rgba(255, 255, 255, 0.35);
  padding: 24px;
  transition: all 0.3s cubic-bezier(0.4, 0.01, 0, 1);
}

.testimonialsGrid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
  gap: var(--space-8);
  margin-top: var(--space-12);
}

.testimonialCard {
  background: var(--background-primary);
  border: 1px solid var(--border-color);
  border-radius: var(--radius-3xl);
  padding: var(--space-8);
  transition: all var(--transition-luxury);
  position: relative;
  overflow: hidden;
}

.testimonialCard::before {
  content: '"';
  position: absolute;
  top: var(--space-6);
  right: var(--space-6);
  font-size: 4rem;
  color: var(--primary);
  opacity: 0.2;
  font-family: var(--font-display);
  line-height: 1;
}

.testimonialCard:hover {
  border-color: var(--primary);
  box-shadow: var(--shadow-luxury);
}

.testimonialHeader {
  display: flex;
  align-items: center;
  gap: var(--space-4);
  margin-bottom: var(--space-6);
}

.testimonialAvatar {
  width: 60px;
  height: 60px;
  border-radius: var(--radius-full);
  object-fit: cover;
  border: 3px solid var(--primary);
}

.testimonialMeta {
  flex: 1;
}

.testimonialName {
  font-family: var(--font-display);
  font-size: 1.125rem;
  font-weight: 700;
  color: var(--text-primary);
  margin: 0 0 var(--space-1) 0;
}

.testimonialService {
  color: var(--text-secondary);
  font-size: 0.875rem;
  margin: 0 0 var(--space-2) 0;
}

.testimonialRating {
  font-size: 0.875rem;
}

.testimonialText {
  color: var(--text-secondary);
  font-size: 1rem;
  line-height: 1.6;
  font-style: italic;
  margin: 0;
}

/* Enhanced Footer */
.footer {
  background: linear-gradient(135deg, var(--gray-900) 0%, var(--black) 100%);
  color: var(--white);
  position: relative;
  overflow: hidden;
  margin-top: 2rem;
}

.footer::before {
  content: "";
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 1px;
  background: linear-gradient(90deg, transparent, var(--primary), transparent);
}

.footerContent {
  max-width: 1400px;
  margin: 0 auto;
  padding: var(--space-20) var(--space-6) 0;
}

.footerMain {
  display: grid;
  grid-template-columns: 1fr 2fr;
  gap: var(--space-16);
  margin-bottom: var(--space-16);
}

.footerBrand {
  display: flex;
  flex-direction: column;
  gap: var(--space-6);
}

.footerLogo {
  display: flex;
  align-items: center;
  gap: var(--space-3);
  margin-bottom: var(--space-4);
}

.footerLogoIcon {
  font-size: 2rem;
  animation: float 3s ease-in-out infinite;
}

.footerLogo h4 {
  font-family: var(--font-display);
  font-size: 2rem;
  font-weight: 800;
  color: var(--primary);
  margin: 0;
}

.footerTagline {
  color: var(--gray-300);
  font-size: 1.125rem;
  line-height: 1.6;
  max-width: 300px;
  margin: 0;
}

.footerSocials {
  display: flex;
  gap: var(--space-4);
}

.socialButton {
  display: flex;
  align-items: center;
  justify-content: center;
  width: 44px;
  height: 44px;
  background: rgba(212, 175, 55, 0.1);
  border: 1px solid rgba(212, 175, 55, 0.3);
  border-radius: var(--radius-full);
  font-size: 1.25rem;
  cursor: pointer;
  transition: all var(--transition-normal);
}

.socialButton:hover {
  background: var(--primary);
  transform: translateY(-2px) scale(1.1);
  box-shadow: var(--shadow-lg);
}

.footerLinks {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
  gap: var(--space-10);
}

.footerColumn {
  display: flex;
  flex-direction: column;
  gap: var(--space-4);
}

.footerColumnTitle {
  font-family: var(--font-display);
  font-size: 1.25rem;
  font-weight: 700;
  color: var(--primary);
  margin: 0 0 var(--space-4) 0;
}

.footerList {
  list-style: none;
  padding: 0;
  margin: 0;
  display: flex;
  flex-direction: column;
  gap: var(--space-3);
}

.footerList li a {
  color: var(--gray-300);
  text-decoration: none;
  transition: all var(--transition-normal);
  font-size: 0.95rem;
}

.footerList li a:hover {
  color: var(--primary);
  transform: translateX(var(--space-2));
}

.footerContact {
  display: flex;
  flex-direction: column;
  gap: var(--space-3);
}

.footerContact p {
  color: var(--gray-300);
  margin: 0;
  font-size: 0.95rem;
  display: flex;
  align-items: center;
  gap: var(--space-2);
}

.footerBottom {
  border-top: 1px solid var(--gray-800);
  padding: var(--space-8) 0;
}

.footerBottomContent {
  display: flex;
  justify-content: space-between;
  align-items: center;
  flex-wrap: wrap;
  gap: var(--space-4);
}

.footerBottomContent p {
  color: var(--gray-400);
  margin: 0;
  font-size: 0.875rem;
}

.footerBadges {
  display: flex;
  gap: var(--space-4);
}

.footerBadge {
  display: flex;
  align-items: center;
  gap: var(--space-1);
  padding: var(--space-2) var(--space-3);
  background: rgba(212, 175, 55, 0.1);
  color: var(--primary);
  border-radius: var(--radius-md);
  font-size: 0.75rem;
  font-weight: 600;
}

/* Responsive Design */
@media (max-width: 1024px) {
  .heroContent {
    grid-template-columns: 1fr;
    gap: var(--space-12);
    text-align: center;
  }

  .heroRight {
    height: 500px;
  }

  .heroStats {
    justify-content: center;
    flex-wrap: wrap;
  }

  .footerMain {
    grid-template-columns: 1fr;
    gap: var(--space-12);
    text-align: center;
  }
}

@media (max-width: 768px) {
  .desktopNav {
    display: none;
  }

  .mobileMenuButton {
    display: flex;
  }

  .headerContent {
    height: 70px;
    padding: 0 var(--space-4);
  }

  .heroSection {
    padding: var(--space-12) 0;
  }

  .heroTitle {
    font-size: 2.5rem;
  }

  .heroSubtitle {
    font-size: 1.125rem;
  }

  .heroActions {
    flex-direction: column;
    width: 100%;
  }

  .heroCta {
    width: 100%;
    justify-content: center;
  }

  .heroRight {
    height: 400px;
  }

  .servicesGrid {
    grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
    gap: var(--space-6);
  }

  .salonsGrid {
    grid-template-columns: 1fr;
    gap: var(--space-6);
  }

  .testimonialsGrid {
    grid-template-columns: 1fr;
    gap: var(--space-6);
  }

  .searchSection {
    padding: var(--space-16) var(--space-4);
  }

  .servicesSection {
    padding: var(--space-16) var(--space-4);
  }

  .salonsSection {
    padding: var(--space-16) var(--space-4);
  }

  .testimonialsSection {
    padding: var(--space-16) var(--space-4);
  }

  .sectionHeader {
    flex-direction: column;
    gap: var(--space-4);
    text-align: center;
  }

  .quickFilters {
    justify-content: center;
  }

  .filtersLabel {
    width: 100%;
    text-align: center;
    margin-bottom: var(--space-2);
  }

  .footerContent {
    padding: var(--space-12) var(--space-4) 0;
  }

  .footerLinks {
    grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
    gap: var(--space-8);
    text-align: center;
  }

  .footerBottomContent {
    flex-direction: column;
    text-align: center;
  }
}

@media (max-width: 640px) {
  .heroStats {
    flex-direction: column;
    gap: var(--space-4);
  }

  .heroStat {
    flex-direction: row;
    justify-content: center;
    padding: var(--space-3) var(--space-4);
  }

  .servicesGrid {
    grid-template-columns: 1fr;
  }

  .serviceCard {
    padding: var(--space-8);
  }

  .searchBox {
    margin: 0 var(--space-2);
  }

  .searchInputWrapper {
    padding: var(--space-1);
  }

  .searchInput {
    padding: var(--space-3) var(--space-2);
    font-size: 16px; /* Prevents zoom on iOS */
  }

  .searchButton {
    padding: var(--space-3) var(--space-6);
  }

  .quickFilters {
    gap: var(--space-2);
  }

  .filterChip {
    padding: var(--space-2) var(--space-4);
    font-size: 0.8rem;
  }

  .viewOptions {
    width: 100%;
    justify-content: center;
  }
}

@media (max-width: 420px) {
  .logo {
    font-size: 1.5rem;
  }

  .heroTitle {
    font-size: 2rem;
  }

  .heroSubtitle {
    font-size: 1rem;
  }

  .sectionTitle {
    font-size: 1.75rem;
  }

  .serviceCard {
    padding: var(--space-6);
  }

  .serviceName {
    font-size: 1.25rem;
  }

  .servicePrice {
    font-size: 1.5rem;
  }

  .salonInfo {
    padding: var(--space-6);
  }

  .salonName {
    font-size: 1.25rem;
  }

  .mapContainer {
    height: 400px;
  }
}

@media (max-width: 360px) {
  .headerContent {
    padding: 0 var(--space-3);
  }

  .heroSection {
    padding: var(--space-10) 0;
  }

  .heroTitle {
    font-size: 1.75rem;
  }

  .searchSection {
    padding: var(--space-12) var(--space-3);
  }

  .servicesSection {
    padding: var(--space-12) var(--space-3);
  }

  .salonsSection {
    padding: var(--space-12) var(--space-3);
  }

  .footerContent {
    padding: var(--space-10) var(--space-3) 0;
  }
}

/* Animations */
@keyframes spin {
  0% {
    transform: rotate(0deg);
  }
  100% {
    transform: rotate(360deg);
  }
}

@keyframes pulse {
  0%,
  100% {
    opacity: 1;
    transform: scale(1);
  }
  50% {
    opacity: 0.8;
    transform: scale(0.95);
  }
}

@keyframes float {
  0%,
  100% {
    transform: translateY(0px);
  }
  50% {
    transform: translateY(-8px);
  }
}

/* Print Styles */
@media print {
  .header,
  .footer,
  .mobileMenuButton,
  .themeToggle {
    display: none !important;
  }

  .container {
    background: white !important;
  }

  .container * {
    color: black !important;
    background: white !important;
    box-shadow: none !important;
  }
}
</file>

<file path="src/pages/feedback.js">
// src/pages/feedback.js - Enhanced feedback with star ratings
import { useState, useEffect, useCallback } from "react";
import { useRouter } from "next/router";
import styles from "../styles/Feedback.module.css";

export default function FeedbackPage() {
  const router = useRouter();
  const { bookingId } = router.query;

  const [bookings, setBooking] = useState(null);
  const [ratings, setRatings] = useState({
    serviceQuality: 0,
    timing: 0,
    barberPerformance: 0,
    ambience: 0,
    overall: 0,
  });
  const [comment, setComment] = useState("");
  const [submitting, setSubmitting] = useState(false);

  const fetchBookingDetails = useCallback(async () => {
    try {
      const response = await fetch(`/api/bookings/${bookingId}`);
      if (response.ok) {
        const data = await response.json();
        console.log("API Response:", data); // ✅ Debug log

        // Handle different API response formats
        const bookingData = data.booking || data;
        setBooking(bookingData);
      } else {
        console.error("Failed to fetch booking:", response.status);
        alert("Failed to load booking details");
      }
    } catch (error) {
      console.error("Error fetching booking:", error);
      alert("Error loading booking: " + error.message);
    }
  }, [bookingId]);

  useEffect(() => {
    if (bookingId) {
      fetchBookingDetails();
    }
  }, [bookingId, fetchBookingDetails]);

  // StarRating component - fixed version
  const StarRating = ({ value, onChange, label, required = true }) => {
    return (
      <div className={styles.ratingGroup}>
        <label className={styles.ratingLabel}>
          {label} {required && <span className={styles.required}>*</span>}
        </label>
        <div className={styles.starsContainer}>
          {[1, 2, 3, 4, 5].map((star) => (
            <button
              key={star}
              type="button"
              onClick={() => onChange(star)}
              className={`${styles.starButton} ${
                star <= value ? styles.starFilled : styles.starEmpty
              }`}
            >
              {star <= value ? "⭐" : "☆"}
            </button>
          ))}
          <div className={styles.ratingInfo}>
            {value === 0 ? (
              <span className={styles.ratingPlaceholder}>Tap to rate</span>
            ) : (
              <span className={styles.ratingValue}>
                {value}/5 {getRatingLabel(value)}
              </span>
            )}
          </div>
        </div>
      </div>
    );
  };

  // Add rating labels
  const getRatingLabel = (rating) => {
    switch (rating) {
      case 1:
        return "Poor";
      case 2:
        return "Fair";
      case 3:
        return "Good";
      case 4:
        return "Very Good";
      case 5:
        return "Excellent";
      default:
        return "";
    }
  };

  // Add validation before submission
  const submitFeedback = async () => {
    if (!bookingId) {
      alert("Invalid booking ID");
      return;
    }

    // Validate that all ratings are provided
    const unratedFields = Object.entries(ratings)
      .filter(([key, value]) => value === 0)
      .map(([key]) => key.replace(/([A-Z])/g, " $1").toLowerCase());

    if (unratedFields.length > 0) {
      alert(`Please rate: ${unratedFields.join(", ")}`);
      return;
    }

    setSubmitting(true);
    try {
      const response = await fetch("/api/bookings/update", {
        method: "PUT",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          bookingId,
          feedback: { ratings, comment },
          submittedAt: new Date(),
        }),
      });

      if (response.ok) {
        alert("Thank you for your feedback!");

        // Check if user is logged in
        const userToken = localStorage.getItem("userToken");
        const authenticatedUserData = localStorage.getItem(
          "authenticatedUserData"
        );

        if (userToken && authenticatedUserData) {
          // User is logged in - redirect to dashboard
          router.push("/user/dashboard");
        } else {
          // User is not logged in - store prefill data and redirect to register
          if (bookings) {
            const prefillData = {
              name: bookings.customerName,
              phone: bookings.customerPhone,
              gender: bookings.customerGender,
              lastbookings: {
                salonId: bookings.salonId,
                service: bookings.service,
                date: bookings.date,
                time: bookings.time,
              },
              timestamp: new Date().getTime(),
            };
            console.log("Storing prefill data:", prefillData);
            localStorage.setItem(
              "userPrefillData",
              JSON.stringify(prefillData)
            );
          }
          router.push("/auth/user/register");
        }
      } else {
        alert("Failed to submit feedback");
      }
    } catch (error) {
      console.error("Feedback submission error:", error);
      alert("Error submitting feedback");
    } finally {
      setSubmitting(false);
    }
  };

  if (!bookings) {
    return (
      <div className={styles.loadingContainer}>
        <div className={styles.loadingContent}>
          <div className={styles.spinner}></div>
          <p className={styles.loadingText}>Loading booking details...</p>
        </div>
      </div>
    );
  }

  return (
    <div className={styles.pageContainer}>
      <div className={styles.content}>
        <div className={styles.card}>
          <div className={styles.header}>
            <h1 className={styles.title}>Rate Your Experience</h1>
            <p className={styles.subtitle}>
              How was your visit to {bookings.salonName || "the salon"}?
            </p>
          </div>

          {/* Booking Summary */}
          <div className={styles.bookingSummary}>
            <h3 className={styles.summaryTitle}>Booking Summary</h3>
            <p className={styles.summaryInfo}>
              <strong>Customer:</strong> {bookings.customerName}
              {bookings.customerAge && ` (${bookings.customerAge} years)`}
            </p>
            <p className={styles.summaryInfo}>
              <strong>Phone:</strong> {bookings.customerPhone}
            </p>
            <p className={styles.summaryInfo}>
              <strong>Service:</strong> {bookings.service}
            </p>
            {bookings.barber && (
              <p className={styles.summaryInfo}>
                <strong>Barber:</strong> {bookings.barber}
              </p>
            )}
            <p className={styles.summaryInfo}>
              <strong>Date:</strong> {bookings.date} at {bookings.time}
            </p>
            <p className={styles.summaryInfo}>
              <strong>Amount:</strong> ₹{bookings.price}
            </p>
          </div>

          {/* Rating Form */}
          <div className={styles.ratingsForm}>
            <StarRating
              label="Service Quality"
              value={ratings.serviceQuality}
              onChange={(value) =>
                setRatings({ ...ratings, serviceQuality: value })
              }
            />

            <StarRating
              label="Timing/Punctuality"
              value={ratings.timing}
              onChange={(value) => setRatings({ ...ratings, timing: value })}
            />

            <StarRating
              label="Barber Performance"
              value={ratings.barberPerformance}
              onChange={(value) =>
                setRatings({ ...ratings, barberPerformance: value })
              }
            />

            <StarRating
              label="Salon Ambience / Cleanliness"
              value={ratings.ambience}
              onChange={(value) => setRatings({ ...ratings, ambience: value })}
            />

            <StarRating
              label="Overall Experience"
              value={ratings.overall}
              onChange={(value) => setRatings({ ...ratings, overall: value })}
            />

            {/* Text Feedback */}
            <div className={styles.commentSection}>
              <label className={styles.commentLabel}>
                Additional Comments (Optional)
              </label>
              <textarea
                value={comment}
                onChange={(e) => setComment(e.target.value)}
                placeholder="Share your experience in detail..."
                className={styles.textarea}
                rows="4"
              />
            </div>

            {/* Submit Button */}
            <div className={styles.submitSection}>
              <button
                onClick={submitFeedback}
                disabled={submitting}
                className={styles.submitButton}
              >
                {submitting ? "Submitting..." : "✅ Submit Feedback"}
              </button>
            </div>
          </div>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="src/pages/salons/dashboard.js">
//pages/salons/dashboard.js
import React, { useEffect, useState, useCallback } from "react";
import { useRouter } from "next/router";
import OwnerSidebar from "../../components/OwnerSidebar";
import styles from "../../styles/SalonDashboard.module.css";

export default function DashboardPage() {
  const router = useRouter();
  const [loading, setLoading] = useState(true);
  const [salon, setSalon] = useState(null);
  const [barbers, setBarbers] = useState([]);
  const [showScanner, setShowScanner] = useState(false);
  const [manualCode, setManualCode] = useState("");
  const [showTimeModal, setShowTimeModal] = useState(false);
  const [timeEstimate, setTimeEstimate] = useState(30);
  const [bookingToStart, setBookingToStart] = useState(null);
  const [scanResult, setScanResult] = useState(null);
  const [bookings, setBookings] = useState([]);
  const [error, setError] = useState(null);
  const [sidebarOpen, setSidebarOpen] = useState(false);
  const [selectedDate, setSelectedDate] = useState(
    new Date().toISOString().split("T")[0]
  );
  const [showDatePicker, setShowDatePicker] = useState(false);

  const loadBookings = useCallback(async (salonId, dateString) => {
    try {
      setLoading(true);
      let dateParam = "";

      if (dateString === "all") {
        dateParam = ""; // No filter
      } else {
        dateParam = `&date=${dateString}`;
      }

      // ✅ Add bookingType=all to include walk-ins
      const response = await fetch(
        `/api/salons/bookings?salonId=${salonId}${dateParam}&includeWalkins=true`,

        { cache: "no-store", headers: { "Content-Type": "application/json" } }
      );

      if (!response.ok) throw new Error("Failed to fetch bookings");

      const data = await response.json();
      setBookings(Array.isArray(data) ? data : []);
    } catch (err) {
      setError("Error loading bookings: " + err.message);
      setBookings([]);
    } finally {
      setLoading(false);
    }
  }, []);

  const loadBarbers = useCallback(async (salonId) => {
    try {
      const response = await fetch(`/api/salons/barbers?salonId=${salonId}`);
      if (!response.ok) throw new Error("Failed to fetch barbers");
      const data = await response.json();
      setBarbers(Array.isArray(data) ? data : []);
    } catch (err) {
      console.error("Error loading barbers:", err);
    }
  }, []);

  useEffect(() => {
    if (!router.isReady) return;
    const salonSession = localStorage.getItem("salonSession");
    if (!salonSession) {
      router.push("/auth/salon/login");
      return;
    }
    const salonData = JSON.parse(salonSession);
    setSalon(salonData);
    loadBookings(salonData._id, selectedDate);
    loadBarbers(salonData._id);
  }, [router, router.isReady, loadBookings, selectedDate]);

  // Handle date change
  const handleDateChange = (newDate) => {
    setSelectedDate(newDate);
    if (salon) {
      loadBookings(salon._id, newDate);
    }
  };

  // Quick date buttons
  const setQuickDate = (daysOffset) => {
    const date = new Date();
    date.setDate(date.getDate() + daysOffset);
    const dateString = date.toISOString().split("T")[0];
    handleDateChange(dateString);
  };

  // Get display text for current date
  const getDateDisplayText = () => {
    if (selectedDate === "all") return "All Time";

    const selected = new Date(selectedDate + "T00:00:00");
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    selected.setHours(0, 0, 0, 0);

    const diffDays = Math.floor((selected - today) / (1000 * 60 * 60 * 24));

    if (diffDays === 0) return "Today's Bookings";
    if (diffDays === -1) return "Yesterday's Bookings";
    if (diffDays === 1) return "Tomorrow's Bookings";

    return selected.toLocaleDateString("en-IN", {
      weekday: "long",
      year: "numeric",
      month: "long",
      day: "numeric",
    });
  };
  const handleVerifyArrival = async (bookingCode) => {
    try {
      const res = await fetch("/api/walkin/verify-arrival", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          bookingCode,
          salonId: salon._id,
        }),
      });

      const data = await res.json();

      if (data.success) {
        setScanResult({
          success: true,
          message: `✅ ${data.booking.customerName} checked in!`,
          queuePosition: data.booking.queuePosition,
        });
        // Refresh bookings
        loadBookings();
      } else {
        setScanResult({
          success: false,
          message: data.message,
        });
      }
    } catch (error) {
      setScanResult({
        success: false,
        message: "Error verifying booking",
      });
    }
  };

  const updateBookingStatus = async (
    bookingId,
    newStatus,
    estimatedTime = null
  ) => {
    try {
      const queueStatusMap = {
        confirmed: "RED",
        arrived: "ORANGE",
        started: "GREEN",
        completed: "COMPLETED",
      };

      const payload = {
        bookingId,
        status: newStatus,
        queueStatus: queueStatusMap[newStatus],
      };

      // ✅ Add time estimate if starting service
      if (newStatus === "started" && estimatedTime) {
        payload.estimatedDuration = estimatedTime;
      }

      const response = await fetch("/api/bookings/update-status", {
        method: "PUT",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(payload),
      });

      if (response.ok) {
        setBookings((prev) =>
          prev.map((b) =>
            (b._id || b.id) === bookingId
              ? {
                  ...b,
                  status: newStatus,
                  queueStatus: queueStatusMap[newStatus],
                  estimatedDuration: estimatedTime || b.estimatedDuration,
                  updatedAt: new Date(),
                }
              : b
          )
        );

        if (salon) {
          loadBookings(salon._id, selectedDate);
        }
      } else {
        alert("Failed to update booking");
      }
    } catch (error) {
      console.error("Error updating status:", error);
      alert("Error updating booking");
    }
  };

  if (loading && !salon) {
    return (
      <div className={styles.loadingContainer}>
        <div className={styles.loadingContent}>
          <div className={styles.spinner}></div>
          <p>Loading dashboard...</p>
        </div>
      </div>
    );
  }

  return (
    <div className={styles.dashboardWrapper}>
      {/* Sidebar Desktop */}
      <aside className={styles.sidebarDesktop}>
        <OwnerSidebar />
      </aside>

      {/* Sidebar Mobile */}
      {sidebarOpen && (
        <div className={styles.mobileOverlay}>
          <div
            className={styles.overlay}
            onClick={() => setSidebarOpen(false)}
          ></div>
          <div className={styles.drawer}>
            <OwnerSidebar closeSidebar={() => setSidebarOpen(false)} />
          </div>
        </div>
      )}

      {/* Main Content */}
      <main className={styles.mainContent}>
        <div className={styles.contentContainer}>
          {/* Top Bar for mobile */}
          <div className={styles.mobileTopBar}>
            <button
              onClick={() => setSidebarOpen(true)}
              className={styles.menuButton}
            >
              ☰
            </button>
            <h1 className={styles.mobileTitle}>
              {salon?.salonName || "Dashboard"}
            </h1>
          </div>

          {/* Salon Info */}
          <div className={styles.card}>
            <h1 className={styles.salonTitle}>{salon?.salonName}</h1>
            <p className={styles.salonOwner}>Owner: {salon?.ownerName}</p>
            <div className={styles.headerActions}>
              <button
                onClick={() => setShowScanner(true)}
                className={styles.scannerBtn}
              >
                📷 Scan QR / Enter Code
              </button>
              {showScanner && (
                <div className={styles.scannerModal}>
                  <div className={styles.scannerContent}>
                    <button
                      onClick={() => {
                        setShowScanner(false);
                        setScanResult(null);
                        setManualCode("");
                      }}
                      className={styles.closeModal}
                    >
                      ✕
                    </button>

                    <h2>Check-in Customer</h2>

                    {!scanResult ? (
                      <>
                        <div className={styles.manualInput}>
                          <input
                            type="text"
                            placeholder="Enter booking code (e.g., ST-3842N)"
                            value={manualCode}
                            onChange={(e) =>
                              setManualCode(e.target.value.toUpperCase())
                            }
                            className={styles.codeInput}
                          />
                          <button
                            onClick={() => handleVerifyArrival(manualCode)}
                            disabled={!manualCode}
                            className={styles.verifyBtn}
                          >
                            Verify & Check-in
                          </button>
                        </div>

                        <div className={styles.divider}>OR</div>

                        <div className={styles.qrScanner}>
                          <p>📷 QR Scanner Coming Soon</p>
                          <p className={styles.note}>
                            For now, manually enter the code shown on
                            customer&apos;s screen
                          </p>
                        </div>
                      </>
                    ) : (
                      <div
                        className={`${styles.result} ${
                          scanResult.success ? styles.success : styles.error
                        }`}
                      >
                        <p>{scanResult.message}</p>
                        {scanResult.success && (
                          <p className={styles.queueInfo}>
                            Queue Position: #{scanResult.queuePosition}
                          </p>
                        )}
                        <button
                          onClick={() => {
                            setScanResult(null);
                            setManualCode("");
                          }}
                          className={styles.scanAgainBtn}
                        >
                          Check-in Another Customer
                        </button>
                      </div>
                    )}
                  </div>
                </div>
              )}
              {/* Time Estimate Modal */}
              {showTimeModal && (
                <div className={styles.scannerModal}>
                  <div className={styles.scannerContent}>
                    <button
                      onClick={() => {
                        setShowTimeModal(false);
                        setBookingToStart(null);
                        setTimeEstimate(30);
                      }}
                      className={styles.closeModal}
                    >
                      ✕
                    </button>

                    <h2>⏱️ Estimate Service Time</h2>
                    <p className={styles.modalSubtext}>
                      For: <strong>{bookingToStart?.customerName}</strong>
                    </p>

                    <div className={styles.timeInput}>
                      <label>How long will this service take?</label>
                      <div className={styles.timeButtons}>
                        {[15, 20, 30, 45, 60].map((mins) => (
                          <button
                            key={mins}
                            onClick={() => setTimeEstimate(mins)}
                            className={`${styles.timeOption} ${
                              timeEstimate === mins ? styles.selected : ""
                            }`}
                          >
                            {mins} mins
                          </button>
                        ))}
                      </div>

                      <div className={styles.customTime}>
                        <input
                          type="number"
                          value={timeEstimate}
                          onChange={(e) =>
                            setTimeEstimate(parseInt(e.target.value) || 30)
                          }
                          min="5"
                          max="120"
                          className={styles.timeNumberInput}
                        />
                        <span>minutes</span>
                      </div>
                    </div>

                    <button
                      onClick={async () => {
                        await updateBookingStatus(
                          bookingToStart._id,
                          "started",
                          timeEstimate
                        );
                        setShowTimeModal(false);
                        setBookingToStart(null);
                        setTimeEstimate(30);
                      }}
                      className={styles.verifyBtn}
                    >
                      Start Service ({timeEstimate} mins)
                    </button>
                  </div>
                </div>
              )}
            </div>
          </div>

          {/* Date Picker Section */}
          <div className={styles.card}>
            <h2 className={styles.filterTitle}>📅 Select Date</h2>

            {/* Quick Date Buttons */}
            <div className={styles.filterButtons}>
              <button
                onClick={() => setQuickDate(-1)}
                className={styles.filterButton}
              >
                ⏮️ Yesterday
              </button>
              <button
                onClick={() => setQuickDate(0)}
                className={`${styles.filterButton} ${styles.filterButtonActive}`}
              >
                📅 Today
              </button>
              <button
                onClick={() => setQuickDate(1)}
                className={styles.filterButton}
              >
                ⏭️ Tomorrow
              </button>
              <button
                onClick={() => {
                  handleDateChange("all");
                  setShowDatePicker(false);
                }}
                className={`${styles.filterButton} ${
                  selectedDate === "all" ? styles.filterButtonActive : ""
                }`}
              >
                📊 All Time
              </button>

              {/* Pick a Date Button */}
              <button
                onClick={() => setShowDatePicker(!showDatePicker)}
                className={`${styles.filterButton} ${
                  showDatePicker ? styles.filterButtonActive : ""
                }`}
              >
                📆 Pick a Date
              </button>

              {/* Date Picker Input - Shows only when button clicked */}
              {showDatePicker && (
                <input
                  type="date"
                  value={selectedDate === "all" ? "" : selectedDate}
                  onChange={(e) => handleDateChange(e.target.value)}
                  className={styles.datePickerInput}
                  autoFocus
                />
              )}
            </div>

            {/* Current Selection Display
            <div className={styles.currentDateDisplay}>
              <span className={styles.currentDateIcon}>🗓️</span>
              <span className={styles.currentDateText}>
                {getDateDisplayText()}
              </span>
            </div> */}
          </div>

          {/* Bookings */}
          <div className={styles.card}>
            <div className={styles.bookingsHeader}>
              <div className={styles.bookingsInfo}>
                <h2 className={styles.bookingsTitle}>
                  Bookings ({bookings.length})
                </h2>
                <span className={styles.bookingsDate}>
                  {getDateDisplayText()}
                </span>
              </div>
              <button
                onClick={() => loadBookings(salon._id, selectedDate)}
                className={styles.refreshButton}
                disabled={loading}
              >
                🔄 {loading ? "Refreshing..." : "Refresh"}
              </button>
            </div>

            {error && <div className={styles.errorBox}>{error}</div>}

            {bookings.length === 0 ? (
              <div className={styles.emptyState}>
                <div className={styles.emptyIcon}>📅</div>
                <p className={styles.emptyText}>
                  No bookings found for{" "}
                  {selectedDate === "all" ? "all time" : "selected date"}
                </p>
                <button
                  onClick={() => handleDateChange("all")}
                  className={styles.viewAllButton}
                >
                  View All Bookings
                </button>
              </div>
            ) : (
              <div>
                {/* Unassigned Bookings */}
                {bookings.filter((b) => !b.barberId).length > 0 && (
                  <div className={styles.unassignedSection}>
                    <h3 className={styles.sectionTitle}>
                      ⏳ Pending Assignment
                    </h3>
                    <div className={styles.bookingsGrid}>
                      {bookings
                        .filter((b) => !b.barberId)
                        .map((b) => (
                          <div
                            key={b._id || b.id}
                            className={styles.bookingCard}
                          >
                            <div className={styles.bookingDetails}>
                              <h3 className={styles.customerName}>
                                {b.customerName}
                              </h3>
                              <p className={styles.bookingInfo}>
                                📞 {b.customerPhone}
                              </p>
                              <p className={styles.bookingInfo}>
                                ✂️ {b.service}
                              </p>
                              <p className={styles.bookingInfo}>
                                📅 {b.date || "Walk-in"}{" "}
                                {b.time && `at ${b.time}`}
                              </p>
                              {b.price && (
                                <p className={styles.bookingInfo}>
                                  💰 ₹{b.price}
                                </p>
                              )}
                            </div>
                          </div>
                        ))}
                    </div>
                  </div>
                )}

                {/* Barbers Accordions - ONLY ONE SECTION */}
                <div className={styles.barbersSection}>
                  <h3 className={styles.sectionTitle}>💈 Barbers</h3>
                  {barbers.map((barber) => {
                    const barberBookings = bookings.filter(
                      (b) => b.barberId === barber._id
                    );
                    return (
                      <details
                        key={barber._id}
                        className={styles.barberAccordion}
                      >
                        <summary className={styles.barberSummary}>
                          <span className={styles.barberName}>
                            {barber.name}
                          </span>
                          {barberBookings.length > 0 && (
                            <span className={styles.bookingBadge}>
                              {barberBookings.length}
                            </span>
                          )}
                        </summary>

                        <div className={styles.barberBookings}>
                          {barberBookings.length === 0 ? (
                            <p className={styles.noBookings}>No bookings</p>
                          ) : (
                            barberBookings.map((b) => (
                              <div
                                key={b._id || b.id}
                                className={styles.bookingCard}
                              >
                                <div className={styles.bookingDetails}>
                                  <h3 className={styles.customerName}>
                                    {b.customerName}
                                    {b.customerAge && (
                                      <span className={styles.customerAge}>
                                        {" "}
                                        ({b.customerAge} yrs)
                                      </span>
                                    )}
                                  </h3>
                                  <p className={styles.bookingInfo}>
                                    📞 {b.customerPhone}
                                  </p>
                                  <p className={styles.bookingInfo}>
                                    ✂️ {b.service}
                                  </p>
                                  <p className={styles.bookingInfo}>
                                    📅 {b.date || "Walk-in"}{" "}
                                    {b.time && `at ${b.time}`}
                                  </p>
                                  {b.price && (
                                    <p className={styles.bookingInfo}>
                                      💰 ₹{b.price}
                                    </p>
                                  )}
                                  <span
                                    className={`${
                                      styles.statusBadge
                                    } ${getStatusClassName(b.status)}`}
                                  >
                                    {b.queueStatus || b.status}
                                  </span>
                                </div>

                                <div className={styles.barberActions}>
                                  {b.status === "confirmed" && (
                                    <button
                                      onClick={() =>
                                        updateBookingStatus(b._id, "arrived")
                                      }
                                      className={styles.arrivedBtn}
                                    >
                                      Mark Arrived
                                    </button>
                                  )}

                                  {b.status === "arrived" && (
                                    <button
                                      onClick={() => {
                                        setBookingToStart(b);
                                        setShowTimeModal(true);
                                      }}
                                      className={styles.startBtn}
                                    >
                                      Start Service
                                    </button>
                                  )}

                                  <button className={styles.timeBtn}>
                                    +5min
                                  </button>
                                  <button className={styles.timeBtn}>
                                    +10min
                                  </button>
                                  <button className={styles.pauseBtn}>
                                    Pause
                                  </button>

                                  {b.status === "started" && (
                                    <button
                                      onClick={() =>
                                        updateBookingStatus(b._id, "completed")
                                      }
                                      className={styles.doneBtn}
                                    >
                                      Done
                                    </button>
                                  )}
                                </div>
                              </div>
                            ))
                          )}
                        </div>
                      </details>
                    );
                  })}
                </div>
              </div>
            )}
          </div>
        </div>
      </main>
    </div>
  );
}

function getStatusClassName(status) {
  switch (status) {
    case "confirmed":
      return styles.statusConfirmed;
    case "started":
      return styles.statusStarted;
    case "completed":
      return styles.statusCompleted;
    case "cancelled":
      return styles.statusCancelled;
    default:
      return styles.statusDefault;
  }
}
</file>

<file path="src/pages/index.js">
// pages/index.js
import { useState, useEffect } from "react";
import { useRouter } from "next/router";
import { motion } from "framer-motion";
import dynamic from "next/dynamic";
import styles from "../styles/Home.module.css";
import Image from "next/image";
import { UserDataManager } from "../lib/userData";
import TextMorph from "../components/TextMorph";
import OnboardingLogoutButton from "../components/OnBoardingLogout";

export default function Home() {
  const router = useRouter();
  const [userOnboarding, setUserOnboarding] = useState(null);
  const [nearbySalons, setNearbySalons] = useState([]);
  const [isLoading, setIsLoading] = useState(true);
  const [isLoadingSalons, setIsLoadingSalons] = useState(false);
  const [showMapView, setShowMapView] = useState(false);
  const [selectedSalon, setSelectedSalon] = useState(null);
  const [searchTerm, setSearchTerm] = useState("");
  const [selectedService, setSelectedService] = useState("");
  const [filteredSalons, setFilteredSalons] = useState([]);
  const [isPrebook, setIsPrebook] = useState(false);

  // Dynamic import for map component
  const SalonMap = dynamic(() => import("../components/Maps/SalonMap"), {
    ssr: false,
    loading: () => <div className={styles.mapLoading}>Loading map...</div>,
  });

  useEffect(() => {
    const initializeUser = async () => {
      if (typeof window === "undefined") return;

      // Check if user has completed onboarding
      if (!UserDataManager.hasOnboarded()) {
        router.push("/onboarding");
        return;
      }

      const userToken = localStorage.getItem("userToken");

      if (userToken) {
        // User is logged in - get API data and use hardcoded location for now
        try {
          const response = await fetch("/api/user/profile", {
            headers: { Authorization: `Bearer ${userToken}` },
          });

          if (response.ok) {
            const apiUserData = await response.json();

            // Use API data with hardcoded location (temporary fix)
            const userData = {
              ...apiUserData,
              location: {
                latitude: 19.248192,
                longitude: 73.157593,
                address:
                  "Shahad, Ambivali, Kalyan-Dombivli, Kalyan Taluka, Thane, Maharashtra, 410209, India",
              },
            };

            setUserOnboarding(userData);

            // Load salons with the location
            loadNearbySalons(
              userData.location.latitude,
              userData.location.longitude,
              userData.gender
            );
          }
        } catch (error) {
          console.error("Error loading user data:", error);
        }
      } else {
        // User not logged in - check onboarding data
        const onboardingData = localStorage.getItem("userOnboardingData");
        if (onboardingData) {
          try {
            const userData = JSON.parse(onboardingData);
            setUserOnboarding(userData);

            if (userData.location?.latitude && userData.location?.longitude) {
              loadNearbySalons(
                userData.location.latitude,
                userData.location.longitude,
                userData.gender
              );
            }
          } catch (error) {
            console.error("Error parsing onboarding data:", error);
          }
        }
      }

      // Check theme preference
      // const darkMode = localStorage.getItem("darkMode") === "true";
      // setIsDarkMode(darkMode);
      // if (darkMode) {
      //   document.documentElement.setAttribute("data-theme", "dark");
      // }

      setIsLoading(false);
    };

    initializeUser();
  }, [router]);
  useEffect(() => {
    if (!nearbySalons.length) {
      setFilteredSalons([]);
      return;
    }

    let filtered = nearbySalons;

    // Filter by selected service
    if (selectedService) {
      filtered = filtered.filter((salon) =>
        salon.topServices?.some((service) =>
          service.name.toLowerCase().includes(selectedService.toLowerCase())
        )
      );
    }

    // Filter by search term
    if (searchTerm) {
      const searchLower = searchTerm.toLowerCase();
      filtered = filtered.filter(
        (salon) =>
          salon.salonName.toLowerCase().includes(searchLower) ||
          salon.location.address.toLowerCase().includes(searchLower) ||
          salon.topServices?.some((service) =>
            service.name.toLowerCase().includes(searchLower)
          )
      );
    }

    setFilteredSalons(filtered);
  }, [nearbySalons, searchTerm, selectedService]);

  const loadNearbySalons = async (latitude, longitude, gender) => {
    setIsLoadingSalons(true);
    try {
      console.log("Loading salons for coordinates:", latitude, longitude);

      const response = await fetch(
        `/api/salons/nearby?latitude=${latitude}&longitude=${longitude}&radius=100&gender=${gender}`
      );

      const data = await response.json();
      console.log("Salon API response:", data);

      if (response.ok) {
        setNearbySalons(data.salons || []);
        console.log("Set nearby salons:", data.salons?.length || 0);
      } else {
        console.error("Error loading salons:", data.message);
        setNearbySalons([]);
      }
    } catch (error) {
      console.error("Error loading salons:", error);
      setNearbySalons([]);
    } finally {
      setIsLoadingSalons(false);
    }
  };

  // const toggleDarkMode = () => {
  //   const newMode = !isDarkMode;
  //   setIsDarkMode(newMode);
  //   localStorage.setItem("darkMode", newMode.toString());

  //   if (newMode) {
  //     document.documentElement.setAttribute("data-theme", "dark");
  //   } else {
  //     document.documentElement.removeAttribute("data-theme");
  //   }
  // };

  const navigateToAuth = (type, role) => {
    router.push(`/auth/${role}/${type}`);
  };

  const handleSalonCardClick = (salonId) => {
    router.push({ pathname: "/salons/[id]", query: { id: salonId } });
  };

  if (isLoading) {
    return (
      <div className={styles.loadingContainer}>
        <div className={styles.luxurySpinner}>
          <div className={styles.spinnerRing}></div>
          <div className={styles.spinnerCore}></div>
        </div>
        <motion.p
          initial={{ opacity: 0 }}
          animate={{ opacity: 1 }}
          transition={{ delay: 0.5 }}
          className={styles.loadingText}
        >
          Crafting your luxury experience...
        </motion.p>
      </div>
    );
  }

  return (
    <div className={styles.container}>
      {/* Enhanced Header */}
      {/* Hero Section */}
      <main id="main-content">
        <section className={styles.heroSection}>
          <div className={styles.heroBackground}>
            <div className={styles.heroPattern}></div>
            <div className={styles.floatingElements}>
              <div className={`${styles.floatingElement} ${styles.element1}`}>
                ✨
              </div>
              <div className={`${styles.floatingElement} ${styles.element2}`}>
                💎
              </div>
              <div className={`${styles.floatingElement} ${styles.element3}`}>
                👑
              </div>
              <div className={`${styles.floatingElement} ${styles.element4}`}>
                🌟
              </div>
            </div>
          </div>

          <div className={styles.heroContent}>
            <div className={styles.heroLeft}>
              <motion.div
                className={styles.heroTextContainer}
                initial={{ opacity: 0, y: 50 }}
                animate={{ opacity: 1, y: 0 }}
                transition={{ duration: 1, ease: "easeOut" }}
              >
                <motion.h1
                  className={styles.heroTitle}
                  initial={{ opacity: 0, y: 30 }}
                  animate={{ opacity: 1, y: 0 }}
                  transition={{ duration: 1, delay: 0.2 }}
                >
                  Welcome back,
                  <br />
                  <span className={styles.heroNameHighlight}>
                    {userOnboarding?.name || "Guest"} ✨{" "}
                  </span>
                </motion.h1>

                <motion.p
                  className={styles.heroSubtitle}
                  initial={{ opacity: 0, y: 30 }}
                  animate={{ opacity: 1, y: 0 }}
                  transition={{ duration: 1, delay: 0.4 }}
                >
                  Discover luxury salon experiences and premium beauty services
                  near{" "}
                  <span className={styles.locationHighlight}>
                    {userOnboarding?.location?.address || "you"}{" "}
                  </span>
                </motion.p>
                {/* <TextMorph/> */}
                <motion.div
                  className={styles.heroStats}
                  initial={{ opacity: 0, y: 30 }}
                  animate={{ opacity: 1, y: 0 }}
                  transition={{ duration: 1, delay: 0.6 }}
                >
                  <div className={styles.heroStat}>
                    <div className={styles.statIcon}>🏪</div>
                    <div className={styles.statContent}>
                      <span className={styles.statNumber}>
                        {nearbySalons.length}
                      </span>
                      <span className={styles.statLabel}>Premium Salons</span>
                    </div>
                  </div>
                  <div className={styles.heroStat}>
                    <div className={styles.statIcon}>💆</div>
                    <div className={styles.statContent}>
                      <span className={styles.statNumber}>
                        {nearbySalons.reduce(
                          (total, salon) =>
                            total + (salon.topServices?.length || 0),
                          0
                        )}
                      </span>
                      <span className={styles.statLabel}>Expert Services</span>
                    </div>
                  </div>
                  <div className={styles.heroStat}>
                    <div className={styles.statIcon}>⭐</div>
                    <div className={styles.statContent}>
                      <span className={styles.statNumber}>
                        {nearbySalons.reduce(
                          (total, salon) =>
                            total + (salon.stats?.totalBookings || 0),
                          0
                        )}
                      </span>
                      <span className={styles.statLabel}>Happy Clients</span>
                    </div>
                  </div>
                </motion.div>

                <motion.div
                  className={styles.heroActions}
                  initial={{ opacity: 0, y: 30 }}
                  animate={{ opacity: 1, y: 0 }}
                  transition={{ duration: 1, delay: 0.8 }}
                >
                  <button className={`${styles.heroCta} ${styles.primary}`}>
                    <span className={styles.ctaIcon}>🔍</span>
                    Find Salons Near Me
                  </button>
                  <button className={`${styles.heroCta} ${styles.secondary}`}>
                    <span className={styles.ctaIcon}>📅</span>
                    Book Appointment
                  </button>
                </motion.div>
              </motion.div>
            </div>

            <div className={styles.heroRight}>
              <motion.div
                className={styles.heroVisuals}
                initial={{ opacity: 0, x: 50 }}
                animate={{ opacity: 1, x: 0 }}
                transition={{ duration: 1, delay: 0.3 }}
              >
                <div className={styles.visualsContainer}>
                  <div className={styles.mainImage}>
                    <img
                      src="https://images.unsplash.com/photo-1560066984-138dadb4c035?w=600&h=400&fit=crop&crop=face"
                      alt="Luxury salon interior"
                      className={styles.heroImage}
                    />
                    <div className={styles.imageGradient}></div>
                  </div>

                  <div className={styles.floatingCards}>
                    <motion.div
                      className={`${styles.floatingCard} ${styles.card1}`}
                      animate={{ y: [0, -10, 0] }}
                      transition={{ duration: 3, repeat: Infinity }}
                    >
                      <div className={styles.cardIcon}>💇‍♀️</div>
                      <div className={styles.cardText}>
                        <span className={styles.cardTitle}>Hair Styling</span>
                        <span className={styles.cardPrice}>from ₹299</span>
                      </div>
                    </motion.div>

                    <motion.div
                      className={`${styles.floatingCard} ${styles.card2}`}
                      animate={{ y: [0, 10, 0] }}
                      transition={{ duration: 3, repeat: Infinity, delay: 1 }}
                    >
                      <div className={styles.cardIcon}>✨</div>
                      <div className={styles.cardText}>
                        <span className={styles.cardTitle}>
                          Facial Treatment
                        </span>
                        <span className={styles.cardPrice}>from ₹599</span>
                      </div>
                    </motion.div>

                    <motion.div
                      className={`${styles.floatingCard} ${styles.card3}`}
                      animate={{ y: [0, -8, 0] }}
                      transition={{ duration: 3, repeat: Infinity, delay: 2 }}
                    >
                      <div className={styles.cardIcon}>💅</div>
                      <div className={styles.cardText}>
                        <span className={styles.cardTitle}>Manicure</span>
                        <span className={styles.cardPrice}>from ₹399</span>
                      </div>
                    </motion.div>
                  </div>

                  {/* Decorative Elements */}
                  <div className={styles.decorativeShapes}>
                    <div className={`${styles.shape} ${styles.shape1}`}></div>
                    <div className={`${styles.shape} ${styles.shape2}`}></div>
                    <div className={`${styles.shape} ${styles.shape3}`}></div>
                  </div>
                </div>
              </motion.div>
            </div>
          </div>
        </section>
        {/* Enhanced Search Section */}
        <motion.section
          className={styles.searchSection}
          initial={{ opacity: 0, y: 50 }}
          animate={{ opacity: 1, y: 0 }}
          transition={{ duration: 0.8, delay: 0.2 }}
        >
          <div className={styles.searchContainer}>
            <motion.div
              className={styles.searchBox}
              whileHover={{ scale: 1.02 }}
              transition={{ type: "spring", stiffness: 300 }}
            >
              <div className={styles.searchInputWrapper}>
                <span className={styles.searchIcon}>🔍</span>
                <input
                  type="text"
                  placeholder="Search for services, salons, or treatments..."
                  className={styles.searchInput}
                  value={searchTerm}
                  onChange={(e) => setSearchTerm(e.target.value)}
                />
                <motion.button
                  className={styles.searchButton}
                  whileHover={{ scale: 1.1 }}
                  whileTap={{ scale: 0.95 }}
                >
                  Search
                </motion.button>
              </div>
            </motion.div>

            <div className={styles.quickFilters}>
              <span className={styles.filtersLabel}>Popular:</span>
              {[
                { icon: "💇", label: "Haircut", color: "#FF6B6B" },
                { icon: "🧔", label: "Beard Trim", color: "#4ECDC4" },
                { icon: "💅", label: "Manicure", color: "#45B7D1" },
                { icon: "✨", label: "Facial", color: "#96CEB4" },
                { icon: "🎨", label: "Hair Color", color: "#FECA57" },
                { icon: "💆", label: "Massage", color: "#FF9FF3" },
              ].map((filter, index) => (
                <motion.button
                  key={filter.label}
                  className={`${styles.filterChip} ${
                    selectedService === filter.label ? styles.activeFilter : ""
                  }`}
                  style={{ "--filter-color": filter.color }}
                  whileHover={{ scale: 1.05, y: -2 }}
                  whileTap={{ scale: 0.98 }}
                  initial={{ opacity: 0, x: -20 }}
                  animate={{ opacity: 1, x: 0 }}
                  transition={{ delay: 0.1 * index }}
                  onClick={() => {
                    if (selectedService === filter.label) {
                      setSelectedService(""); // Deselect if already selected
                    } else {
                      setSelectedService(filter.label);
                    }
                  }}
                >
                  <span className={styles.filterIcon}>{filter.icon}</span>
                  {filter.label}
                </motion.button>
              ))}
            </div>
          </div>
        </motion.section>
        {/* <motion.section
        className={styles.servicesSection}
        initial={{ opacity: 0, y: 50 }}
        animate={{ opacity: 1, y: 0 }}
        transition={{ duration: 0.8, delay: 0.4 }}
      >
        <div className={styles.sectionHeader}>
          <div className={styles.sectionTitleContainer}>
            <motion.h3
              className={styles.sectionTitle}
              initial={{ opacity: 0, x: -30 }}
              animate={{ opacity: 1, x: 0 }}
              transition={{ duration: 0.8 }}
            >
              {userOnboarding
                ? `Perfect for ${userOnboarding.gender || "Everyone"}`
                : "Perfect Services for You"}
            </motion.h3>
            <motion.p
              className={styles.sectionSubtitle}
              initial={{ opacity: 0, x: -30 }}
              animate={{ opacity: 1, x: 0 }}
              transition={{ duration: 0.8, delay: 0.2 }}
            >
              Curated services designed just for you
            </motion.p>
          </div>
        </div>

        <div className={styles.servicesGrid}>
          {getGenderBasedServices(userOnboarding?.gender || "Other").map(
            (service, index) => (
              <motion.div
                key={service.name}
                className={styles.serviceCard}
                initial={{ opacity: 0, y: 30 }}
                animate={{ opacity: 1, y: 0 }}
                transition={{ duration: 0.6, delay: 0.1 * index }}
                whileHover={{
                  y: -8,
                  scale: 1.02,
                  transition: { type: "spring", stiffness: 300 },
                }}
              >
                <div className={styles.serviceCardBackground}></div>
                <div className={styles.serviceIcon}>{service.icon}</div>
                <h4 className={styles.serviceName}>{service.name}</h4>
                <div className={styles.serviceDetails}>
                  <p className={styles.servicePrice}>₹{service.price}</p>
                  <p className={styles.serviceDuration}>
                    ⏱ {service.duration} min
                  </p>
                </div>
                <motion.button
                  className={styles.serviceBookButton}
                  whileHover={{ scale: 1.05 }}
                  whileTap={{ scale: 0.98 }}
                >
                  Book Now
                </motion.button>
              </motion.div>
            )
          )}
        </div>
      </motion.section>
      ; */}
        {/* Salons Section with Booking Type Tabs */}
        <motion.section
          className={styles.salonsSection}
          initial={{ opacity: 0, y: 50 }}
          animate={{ opacity: 1, y: 0 }}
          transition={{ duration: 0.8, delay: 0.6 }}
        >
          <div className={styles.sectionHeader}>
            <div className={styles.sectionTitleContainer}>
              <h3 className={styles.sectionTitle}>Premium Salons Near You</h3>
              <p className={styles.sectionSubtitle}>
                Handpicked luxury experiences in your area
              </p>
            </div>

            {/* NEW: Booking Type Tabs */}
            <div className={styles.bookingTypeTabs}>
              <button
                className={`${styles.bookingTypeTab} ${
                  !isPrebook ? styles.activeTab : ""
                }`}
                onClick={() => setIsPrebook(false)}
              >
                <span className={styles.tabIcon}>⚡</span>
                <span className={styles.tabLabel}>Walk-in</span>
                <span className={styles.tabBadge}>Instant</span>
              </button>

              <button
                className={`${styles.bookingTypeTab} ${
                  isPrebook ? styles.activeTab : ""
                }`}
                onClick={() => setIsPrebook(true)}
              >
                <span className={styles.tabIcon}>📅</span>
                <span className={styles.tabLabel}>Pre-book</span>
                <span className={styles.tabBadge}>Advance</span>
              </button>
            </div>

            {/* View toggle (only show for pre-book) */}
            {isPrebook && (
              <div className={styles.viewOptions}>
                <motion.button
                  className={`${styles.viewToggle} ${
                    !showMapView ? styles.active : ""
                  }`}
                  onClick={() => setShowMapView(false)}
                  whileHover={{ scale: 1.05 }}
                  whileTap={{ scale: 0.98 }}
                >
                  <span className={styles.viewIcon}>⊞</span>
                  Grid View
                </motion.button>

                <motion.button
                  className={`${styles.viewToggle} ${
                    showMapView ? styles.active : ""
                  }`}
                  onClick={() => setShowMapView(true)}
                  whileHover={{ scale: 1.05 }}
                  whileTap={{ scale: 0.98 }}
                >
                  <span className={styles.viewIcon}>🗺</span>
                  Map View
                </motion.button>
              </div>
            )}
          </div>

          {/* Conditional Rendering based on Tab */}
          {!isPrebook ? (
            // WALK-IN MODE
            <div className={styles.walkInContainer}>
              <div className={styles.walkInInfo}>
                <span className={styles.walkInIcon}>⚡</span>
                <p>
                  Select a salon below to see real-time chair availability and
                  queue status
                </p>
              </div>

              <div className={styles.salonsGrid}>
                {(filteredSalons.length > 0
                  ? filteredSalons
                  : nearbySalons
                ).map((salon, index) => (
                  <motion.div
                    key={salon._id?.oid || salon._id?.toString() || index}
                    className={styles.salonCard}
                    initial={{ opacity: 0, y: 30 }}
                    animate={{ opacity: 1, y: 0 }}
                    transition={{ duration: 0.6, delay: 0.1 * index }}
                    whileHover={{ y: -12, scale: 1.02 }}
                    onClick={() => {
                      const salonId = salon._id?.oid || salon._id;
                      if (isPrebook) {
                        // Pre-book mode
                        router.push(`/salons/${salonId}?mode=prebook`);
                      } else {
                        // Walk-in mode - SAME PAGE, just different mode
                        router.push(`/salons/${salonId}?mode=walkin`);
                      }
                    }}
                  >
                    {/* Salon Image */}
                    <div className={styles.salonImageContainer}>
                      <img
                        src={
                          typeof salon.salonImages?.[0] === "string"
                            ? salon.salonImages[0]
                            : salon.salonImages?.[0]?.url ||
                              "https://images.unsplash.com/photo-1560066984-138dadb4c035?w=300&h=200&fit=crop"
                        }
                        alt={`${salon.salonName} Salon`}
                        className={styles.salonImage}
                      />
                      <div className={styles.salonImageOverlay}></div>

                      {/* Walk-in Badge */}
                      <div className={styles.salonBadges}>
                        <span
                          className={`${styles.salonBadge} ${styles.walkInBadge}`}
                        >
                          ⚡ Walk-in Ready
                        </span>
                      </div>
                    </div>

                    {/* Salon Info */}
                    <div className={styles.salonInfo}>
                      <div className={styles.salonHeader}>
                        <h4 className={styles.salonName}>{salon.salonName}</h4>
                        <div className={styles.salonRating}>
                          <span className={styles.ratingStars}>⭐</span>
                          <span className={styles.ratingNumber}>
                            {salon.ratings?.overall ?? salon.rating ?? 4.5}
                          </span>
                        </div>
                      </div>

                      <p className={styles.salonLocation}>
                        {salon.location?.address}
                      </p>

                      <div className={styles.salonMetrics}>
                        <div className={styles.metric}>
                          <span className={styles.metricIcon}>📍</span>
                          <span className={styles.metricValue}>
                            {salon.distance} km away
                          </span>
                        </div>
                        <div className={styles.metric}>
                          <span className={styles.metricIcon}>🕐</span>
                          <span className={styles.metricValue}>Open Now</span>
                        </div>
                      </div>

                      {/* Walk-in CTA */}
                      <motion.button
                        className={styles.walkInButton}
                        whileHover={{ scale: 1.05 }}
                        whileTap={{ scale: 0.98 }}
                      >
                        View Live Availability
                      </motion.button>
                    </div>
                  </motion.div>
                ))}
              </div>
            </div>
          ) : (
            // PRE-BOOK MODE (EXISTING INTERFACE)
            <>
              {isLoadingSalons ? (
                <div className={styles.loadingSalons}>
                  <div className={styles.luxurySpinner}>
                    <div className={styles.spinnerRing}></div>
                    <div className={styles.spinnerCore}></div>
                  </div>
                  <p>Discovering premium salons near you...</p>
                </div>
              ) : nearbySalons.length === 0 ? (
                <div className={styles.noSalons}>
                  <p>No salons found in your area</p>
                </div>
              ) : showMapView ? (
                <div className={styles.mapContainer}>
                  <SalonMap
                    salons={nearbySalons}
                    userLocation={{
                      lat: userOnboarding?.location?.latitude,
                      lng: userOnboarding?.location?.longitude,
                    }}
                    selectedSalon={selectedSalon}
                    onSalonSelect={setSelectedSalon}
                    onBookNow={handleSalonCardClick}
                    userGender={userOnboarding?.gender}
                  />
                </div>
              ) : (
                <div className={styles.salonsGrid}>
                  {(filteredSalons.length > 0
                    ? filteredSalons
                    : nearbySalons
                  ).map((salon, index) => (
                    <motion.div
                      key={salon._id?.oid || salon._id?.toString() || index}
                      className={styles.salonCard}
                      initial={{ opacity: 0, y: 30 }}
                      animate={{ opacity: 1, y: 0 }}
                      transition={{ duration: 0.6, delay: 0.1 * index }}
                      whileHover={{ y: -12, scale: 1.02 }}
                      onClick={() => {
                        const salonId = salon._id?.oid || salon._id;
                        if (isPrebook) {
                          // Pre-book mode: use existing flow
                          handleSalonCardClick(salonId);
                        } else {
                          // Walk-in mode: add mode parameter
                          router.push(`/salons/${salonId}?mode=walkin`);
                        }
                      }}
                    >
                      {/* EXISTING PREBOOK SALON CARD CODE - KEEP AS IS */}
                      <div className={styles.salonImageContainer}>
                        <img
                          src={
                            typeof salon.salonImages?.[0] === "string"
                              ? salon.salonImages[0]
                              : salon.salonImages?.[0]?.url ||
                                "https://images.unsplash.com/photo-1560066984-138dadb4c035?w=300&h=200&fit=crop"
                          }
                          alt={`${salon.salonName} Salon`}
                          className={styles.salonImage}
                        />
                        <div className={styles.salonImageOverlay}></div>

                        <div className={styles.salonBadges}>
                          <span
                            className={`${styles.salonBadge} ${styles.primaryBadge}`}
                          >
                            {salon.distance < 2
                              ? "Very Close"
                              : salon.isVerified
                              ? "Verified"
                              : "Popular"}
                          </span>
                          <span
                            className={`${styles.salonBadge} ${styles.distanceBadge}`}
                          >
                            {salon.distance}km away
                          </span>
                        </div>
                      </div>

                      <div className={styles.salonInfo}>
                        <div className={styles.salonHeader}>
                          <h4 className={styles.salonName}>
                            {salon.salonName}
                          </h4>
                          <div className={styles.salonRating}>
                            <span className={styles.ratingStars}>⭐</span>
                            <span className={styles.ratingNumber}>
                              {salon.ratings?.overall ?? salon.rating ?? 4.5}
                            </span>
                          </div>
                        </div>

                        <p className={styles.salonLocation}>
                          {salon.location?.address}
                        </p>

                        <div className={styles.salonMetrics}>
                          <div className={styles.metric}>
                            <span className={styles.metricIcon}>📍</span>
                            <span className={styles.metricValue}>
                              {salon.stats?.totalBookings || 0} bookings
                            </span>
                          </div>
                          <div className={styles.metric}>
                            <span className={styles.metricIcon}>🕐</span>
                            <span className={styles.metricValue}>Open Now</span>
                          </div>
                        </div>

                        <div className={styles.salonServices}>
                          {salon.topServices
                            ?.slice(0, 3)
                            .map((service, idx) => (
                              <span key={idx} className={styles.serviceTag}>
                                {service.name}
                              </span>
                            ))}
                        </div>

                        <motion.button
                          className={styles.bookButton}
                          whileHover={{ scale: 1.05 }}
                          whileTap={{ scale: 0.98 }}
                        >
                          Book Now
                        </motion.button>
                      </div>
                    </motion.div>
                  ))}
                </div>
              )}
            </>
          )}
        </motion.section>
        ;{/* Testimonials Section */}
        <motion.section
          className={styles.testimonialsSection}
          initial={{ opacity: 0, y: 50 }}
          animate={{ opacity: 1, y: 0 }}
          transition={{ duration: 0.8, delay: 0.8 }}
        >
          <div className={styles.sectionHeader}>
            <h3 className={styles.sectionTitle}>What Our Clients Say</h3>
            <p className={styles.sectionSubtitle}>
              Real experiences from real people
            </p>
          </div>

          <div className={styles.testimonialsGrid}>
            {[
              {
                name: "Priya Sharma",
                service: "Hair Styling & Color",
                rating: 5,
                text: "Absolutely amazing experience! The staff was professional and the results exceeded my expectations.",
                image:
                  "https://images.unsplash.com/photo-1494790108755-2616b612b742?w=80&h=80&fit=crop&crop=face",
              },
              {
                name: "Rajesh Kumar",
                service: "Beard Styling",
                rating: 5,
                text: "Best grooming experience I've had in Mumbai. Clean, professional, and great attention to detail.",
                image:
                  "https://images.unsplash.com/photo-1507003211169-0a1dd7228f2d?w=80&h=80&fit=crop&crop=face",
              },
              {
                name: "Anita Patel",
                service: "Facial & Manicure",
                rating: 5,
                text: "Such a relaxing and luxurious experience. I feel completely refreshed and beautiful!",
                image:
                  "https://images.unsplash.com/photo-1438761681033-6461ffad8d80?w=80&h=80&fit=crop&crop=face",
              },
            ].map((testimonial, index) => (
              <motion.div
                key={testimonial.name}
                className={styles.testimonialCard}
                initial={{ opacity: 0, y: 30 }}
                animate={{ opacity: 1, y: 0 }}
                transition={{ duration: 0.6, delay: 0.1 * index }}
                whileHover={{ y: -5, scale: 1.02 }}
              >
                <div className={styles.testimonialHeader}>
                  <img
                    src={testimonial.image}
                    alt={testimonial.name}
                    className={styles.testimonialAvatar}
                  />
                  <div className={styles.testimonialMeta}>
                    <h5 className={styles.testimonialName}>
                      {testimonial.name}
                    </h5>
                    <p className={styles.testimonialService}>
                      {testimonial.service}
                    </p>
                    <div className={styles.testimonialRating}>
                      {"⭐".repeat(testimonial.rating)}
                    </div>
                  </div>
                </div>
                <p className={styles.testimonialText}>
                  &quot;{testimonial.text}&quot;
                </p>
              </motion.div>
            ))}
          </div>
        </motion.section>
        {/* Enhanced Footer */}
        <footer className={styles.footer}>
          <div className={styles.footerContent}>
            <div className={styles.footerMain}>
              <div className={styles.footerBrand}>
                <div className={styles.footerLogo}>
                  <div className={styles.footerLogoIcon}>✨</div>
                  <h4>TechTrims</h4>
                </div>
                <p className={styles.footerTagline}>
                  Elevating beauty experiences through technology and luxury
                </p>
                <div className={styles.footerSocials}>
                  <button className={styles.socialButton}>📘</button>
                  <button className={styles.socialButton}>📸</button>
                  <button className={styles.socialButton}>🐦</button>
                  <button className={styles.socialButton}>💼</button>
                </div>
              </div>

              <div className={styles.footerLinks}>
                <div className={styles.footerColumn}>
                  <h5 className={styles.footerColumnTitle}>Services</h5>
                  <ul className={styles.footerList}>
                    <li>
                      <a href="#haircut">Hair Styling</a>
                    </li>
                    <li>
                      <a href="#facial">Facial Treatments</a>
                    </li>
                    <li>
                      <a href="#manicure">Nail Care</a>
                    </li>
                    <li>
                      <a href="#massage">Spa & Massage</a>
                    </li>
                  </ul>
                </div>

                <div className={styles.footerColumn}>
                  <h5 className={styles.footerColumnTitle}>For Business</h5>
                  <ul className={styles.footerList}>
                    <li>
                      <a href="#register">Register Your Salon</a>
                    </li>
                    <li>
                      <a href="#partner">Partner with Us</a>
                    </li>
                    <li>
                      <a href="#business">Business Solutions</a>
                    </li>
                    <li>
                      <a href="#support">Business Support</a>
                    </li>
                  </ul>
                </div>

                <div className={styles.footerColumn}>
                  <h5 className={styles.footerColumnTitle}>Support</h5>
                  <ul className={styles.footerList}>
                    <li>
                      <a href="#help">Help Center</a>
                    </li>
                    <li>
                      <a href="#contact">Contact Us</a>
                    </li>
                    <li>
                      <a href="#terms">Terms of Service</a>
                    </li>
                    <li>
                      <a href="#privacy">Privacy Policy</a>
                    </li>
                  </ul>
                </div>

                <div className={styles.footerColumn}>
                  <h5 className={styles.footerColumnTitle}>Connect</h5>
                  <div className={styles.footerContact}>
                    <p>📞 +91 98765 43210</p>
                    <p>✉️ hello@techtrims.com</p>
                    <p>📍 Mumbai, Maharashtra</p>
                  </div>
                </div>
              </div>
            </div>

            <div className={styles.footerBottom}>
              <div className={styles.footerBottomContent}>
                <p>&copy; 2025 TechTrims. All rights reserved.</p>
                <div className={styles.footerBadges}>
                  <span className={styles.footerBadge}>🔒 Secure</span>
                  <span className={styles.footerBadge}>⭐ Verified</span>
                  <span className={styles.footerBadge}>💎 Premium</span>
                </div>
              </div>
            </div>
          </div>
        </footer>
      </main>
    </div>
  );
}

// Helper function to highlight search text
function highlightText(text, highlight) {
  if (!highlight) return text;

  const regex = new RegExp(`(${highlight})`, "gi");
  return text.split(regex).map((part, index) =>
    regex.test(part) ? (
      <mark key={index} style={{ background: "#ffd700", padding: "0 2px" }}>
        {part}
      </mark>
    ) : (
      part
    )
  );
}

function getGenderBasedServices(gender) {
  const maleServices = [
    { name: "Premium Haircut", price: 299, duration: 45, icon: "✂️" },
    { name: "Beard Styling", price: 199, duration: 30, icon: "🧔" },
    { name: "Hair Styling", price: 349, duration: 35, icon: "💇‍♂️" },
    { name: "Face Treatment", price: 449, duration: 60, icon: "🧴" },
  ];

  const femaleServices = [
    { name: "Hair Styling", price: 599, duration: 90, icon: "💇‍♀️" },
    { name: "Hair Coloring", price: 1299, duration: 150, icon: "🎨" },
    { name: "Facial Glow", price: 799, duration: 90, icon: "✨" },
    { name: "Luxury Manicure", price: 499, duration: 60, icon: "💅" },
  ];

  const otherServices = [
    { name: "Hair Treatment", price: 699, duration: 75, icon: "🌿" },
    { name: "Scalp Therapy", price: 449, duration: 45, icon: "💆" },
    { name: "Hair Wash & Dry", price: 199, duration: 30, icon: "🚿" },
    { name: "Style Consultation", price: 499, duration: 60, icon: "💫" },
  ];

  switch (gender) {
    case "Male":
      return maleServices;
    case "Female":
      return femaleServices;
    default:
      return otherServices;
  }
}
</file>

<file path="src/pages/salons/[id].js">
// pages/salons/[id].js
import { useState, useEffect, useCallback } from "react";
import { useRouter } from "next/router";
import { motion } from "framer-motion";
import dynamic from "next/dynamic";
import styles from "../../styles/SalonDetail.module.css";
import Image from "next/image";
import { UserDataManager } from "../../lib/userData";
import RetryButton from "@/components/RetryButton";
import ReviewsSection from "@/components/Salon/ReviewSection";

// Dynamic map import to avoid SSR issues
const MapContainer = dynamic(
  () => import("react-leaflet").then((mod) => mod.MapContainer),
  { ssr: false }
);
const TileLayer = dynamic(
  () => import("react-leaflet").then((mod) => mod.TileLayer),
  { ssr: false }
);
const Marker = dynamic(
  () => import("react-leaflet").then((mod) => mod.Marker),
  { ssr: false }
);

export default function SalonDetail({ initialSalon }) {
  const router = useRouter();
  const { id, mode } = router.query;
  const [bookingMode, setBookingMode] = useState(mode || "prebook");
  const [salonStats, setSalonStats] = useState({
    availableNow: 0,
    totalWaiting: 0,
    totalBooked: 0,
    avgWaitTime: 0,
  });
  const [barberStates, setBarberStates] = useState([]);
  const [userInfo, setUserInfo] = useState(null);
  const [salon, setSalon] = useState(initialSalon || null);
  const [isLoading, setIsLoading] = useState(!initialSalon);
  const [selectedServices, setSelectedServices] = useState([]);
  const [selectedTime, setSelectedTime] = useState(null);
  const [availableBarbers, setAvailableBarbers] = useState([]);
  const [selectedBarber, setSelectedBarber] = useState(null);
  const [selectedDate, setSelectedDate] = useState("");
  const [selectedSlot, setSelectedSlot] = useState("");
  const [timeSlots, setTimeSlots] = useState([]); // ✅ added this
  const [userOnboarding, setUserOnboarding] = useState(null);
  const [showRegistrationModal, setShowRegistrationModal] = useState(false);
  const [isBooking, setIsBooking] = useState(false);
  const [otpSent, setOtpSent] = useState(false);
  const [otpCode, setOtpCode] = useState("");
  const [otpMobile, setOtpMobile] = useState("");
  const [sseMessages, setSseMessages] = useState([]);
  const [regName, setRegName] = useState("");
  const [regMobile, setRegMobile] = useState("");
  const [regEmail, setRegEmail] = useState("");
  const [bookingError, setBookingError] = useState(null);

  useEffect(() => {
    // Only run once when component mounts
    if (typeof window !== "undefined") {
      const stored = localStorage.getItem("userOnboardingData");
      if (stored) {
        try {
          const parsed = JSON.parse(stored);
          setUserInfo(parsed);
          console.log("Loaded userInfo from localStorage:", parsed);
        } catch (err) {
          console.error("Failed to parse onboarding data:", err);
        }
      }
    }
  }, []);
  // ✅ NEW: Fetch real-time barber states for walk-in mode
  useEffect(() => {
    if (bookingMode !== "walkin" || !id) return;

    const fetchBarberStates = async () => {
      try {
        const res = await fetch(`/api/walkin/salon-state?salonId=${id}`);
        const data = await res.json();
        setBarberStates(data.barbers || []);
      } catch (error) {
        console.error("Error fetching barber states:", error);
      }
    };

    fetchBarberStates();

    // Update every 30 seconds
    const interval = setInterval(fetchBarberStates, 30000);

    return () => clearInterval(interval);
  }, [bookingMode, id]);

  useEffect(() => {
    if (bookingMode !== "walkin" || !id) return;

    const fetchSalonStats = async () => {
      try {
        const res = await fetch(`/api/walkin/salon-state?salonId=${id}`);
        const data = await res.json();

        setSalonStats({
          availableNow: data.availableNow || 0,
          totalWaiting: data.totalWaiting || 0,
          totalBooked: data.totalBooked || 0,
          totalServing: data.totalServing || 0,
          avgWaitTime: data.avgWaitTime || 0,
        });

        // ✅ Store barber states with time left
        setBarberStates(data.barbers || []);
      } catch (error) {
        console.error("Error fetching salon stats:", error);
      }
    };

    fetchSalonStats();
    const interval = setInterval(fetchSalonStats, 10000); // Update every 10 seconds
    return () => clearInterval(interval);
  }, [bookingMode, id]);

  useEffect(() => {
    console.log(
      "🔎 Button enable check → Services:",
      selectedServices,
      "Time:",
      selectedTime
    );
  }, [selectedServices, selectedTime]);

  useEffect(() => {
    if (selectedServices.length > 0 && salon?._id) {
      const fetchAvailableBarbers = async () => {
        try {
          // Use the first selected service name
          const firstServiceName = selectedServices[0].name;
          console.log("Fetching barbers for service:", firstServiceName);

          // Fetch barbers who can perform the selected service
          const res = await fetch(
            `/api/salons/barbers/available?salonId=${
              salon._id
            }&service=${encodeURIComponent(firstServiceName)}`
          );

          if (!res.ok) {
            throw new Error(`HTTP error! status: ${res.status}`);
          }

          const barbers = await res.json();
          console.log("Available barbers:", barbers);
          setAvailableBarbers(barbers);

          // If no barbers available, show a message but don't prevent booking
          if (barbers.length === 0) {
            console.warn("No barbers available for selected service");
          }
        } catch (err) {
          console.error("Error fetching barbers:", err);
          setAvailableBarbers([]);
        }
      };

      fetchAvailableBarbers();
    } else {
      setAvailableBarbers([]);
      setSelectedBarber(null);
    }
  }, [selectedServices, salon?._id]);

  const chosenService =
    salon?.services && selectedServices
      ? { name: selectedServices, ...(salon.services[selectedServices] || {}) }
      : null;
  const chosenBarber =
    salon?.barbers && selectedBarber
      ? salon.barbers.find(
          (b) => (b.id || b._id || b.name) === selectedBarber
        ) || null
      : null;
  const [showBookingModal, setShowBookingModal] = useState(false);

  // Client re-fetch (optional, keeps data fresh if user navigates without reload)
  const computeTimeSlotsForDate = useCallback(
    (dateStr) => {
      if (!dateStr) return [];
      const slots = [];
      const today = new Date();
      const selectedDateObj = new Date(dateStr);
      const startHour =
        selectedDateObj.toDateString() === today.toDateString()
          ? Math.max(9, today.getHours() + 1)
          : 9;
      const endHour = 20;

      const bookedSet = new Set(
        (salon.bookings || [])
          .filter((b) => {
            try {
              const bd = new Date(b.date);
              return bd.toDateString() === selectedDateObj.toDateString();
            } catch {
              return false;
            }
          })
          .map((b) => b.date === selectedDate)
      );

      for (let hour = startHour; hour < endHour; hour++) {
        for (let minute = 0; minute < 60; minute += 30) {
          const hh = String(hour).padStart(2, "0");
          const mm = String(minute).padStart(2, "0");
          const timeString = `${hh}:${mm}`;
          slots.push({
            time: timeString,
            available: !bookedSet.has(timeString),
          });
        }
      }

      return slots;
    },
    [salon, selectedDate]
  );
  useEffect(() => {
    if (!selectedDate) {
      setTimeSlots([]);
      setSelectedSlot("");
      return;
    }
    const slots = computeTimeSlotsForDate(selectedDate);
    setTimeSlots(slots);
  }, [selectedDate, computeTimeSlotsForDate]);
  const getFilteredServices = () => {
    if (!salon) return [];

    // Convert object → array
    const servicesArray = Object.entries(salon.services || {}).map(
      ([key, value]) => ({
        name: key,
        price: Number(value.price) || 0,
        enabled: value.enabled,
        duration: value.duration || 30, // fallback if not stored
        gender: value.gender || ["All"], // fallback if not stored
      })
    );

    if (!userOnboarding) return servicesArray;

    return servicesArray.filter(
      (service) =>
        service.gender.includes(userOnboarding.gender) ||
        service.gender.includes("All")
    );
  };

  if (isLoading) {
    return (
      <div className={styles.loadingContainer}>
        <div className={styles.spinner}></div>
        <p>Loading salon details...</p>
      </div>
    );
  }

  if (!salon) {
    return (
      <div className={styles.errorContainer}>
        <h2>Salon not found</h2>
        <button onClick={() => router.push("/")} className={styles.backButton}>
          ← Back to Home
        </button>
      </div>
    );
  }

  const handleServiceClick = (service) => {
    setSelectedServices((prev) => {
      const exists = prev.find((s) => s.name === service.name);
      if (exists) {
        return prev.filter((s) => s.name !== service.name);
      } else {
        return [...prev, service];
      }
    });
  };

  const handleTimeClick = (time) => {
    console.log("Time selected:", time);
    setSelectedTime(time);
    setSelectedSlot(time); // optional: keep both in sync
  };

  const makeBookingRequest = async () => {
    try {
      setBookingError(null);
      const response = await fetch("/api/bookings/create", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          ...(userToken && { Authorization: `Bearer ${userToken}` }),
        },
        body: JSON.stringify(payload),
      });

      // ✅ Handle 409 conflict INSIDE makeBookingRequest
      if (response.status === 409) {
        const errorData = await response.json();
        alert(
          "Sorry! This time slot was just booked by another customer. Please select a different time."
        );
        window.location.reload();
        throw new Error("Slot already booked");
      }

      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.error || "Booking failed");
      }

      const bookingResult = await response.json();
      return bookingResult;
    } catch (error) {
      setBookingError(error.message);
      throw error;
    }
  };

  // const handleBooking = async () => {
  //   if (selectedServices.length === 0) {
  //     alert("Please select at least one service");
  //     return;
  //   }

  //   if (!selectedDate) {
  //     alert("Please select a date");
  //     return;
  //   }

  //   if (!selectedSlot) {
  //     alert("Please select a time slot");
  //     return;
  //   }

  //   try {
  //     console.log(
  //       "Booking with:",
  //       selectedServices,
  //       selectedSlot,
  //       selectedBarber,
  //       userInfo
  //     );

  //     // Find selected barber details if one is selected
  //     const selectedBarberDetails = selectedBarber
  //       ? availableBarbers.find((b) => b._id === selectedBarber)
  //       : null;

  //     // Prepare booking data
  //     const allServices = selectedServices
  //       .map((service) => service.name)
  //       .join(", ");
  //     const totalPrice = selectedServices.reduce(
  //       (sum, service) => sum + service.price,
  //       0
  //     );
  //     const currentUserInfo = UserDataManager.getStoredUserData();
  //     const userToken = localStorage.getItem("userToken");

  //     const payload = {
  //       salonId: salon._id,
  //       service: allServices,
  //       barber: selectedBarberDetails?.name || "Any Available",
  //       barberId: selectedBarber || null,
  //       date: selectedDate,
  //       time: selectedSlot,
  //       price: totalPrice,
  //       customerName: currentUserInfo?.name || "Anonymous",
  //       customerPhone: currentUserInfo?.phone || "",
  //       user: currentUserInfo,
  //       userId: currentUserInfo?._id || currentUserInfo?.id || null,
  //     };

  //     console.log("Booking payload:", payload);

  //     // Define makeBookingRequest function
  //     const makeBookingRequest = async () => {
  //       try {
  //         setBookingError(null);
  //         const response = await fetch("/api/bookings/create", {
  //           method: "POST",
  //           headers: {
  //             "Content-Type": "application/json",
  //             ...(userToken && { Authorization: `Bearer ${userToken}` }),
  //           },
  //           body: JSON.stringify(payload),
  //         });

  //         // Handle 409 conflict
  //         if (response.status === 409) {
  //           const errorData = await response.json();
  //           alert(
  //             "Sorry! This time slot was just booked by another customer. Please select a different time."
  //           );
  //           window.location.reload();
  //           throw new Error("Slot already booked");
  //         }

  //         if (!response.ok) {
  //           const errorData = await response.json();
  //           throw new Error(errorData.error || "Booking failed");
  //         }

  //         const bookingResult = await response.json();
  //         return bookingResult;
  //       } catch (error) {
  //         setBookingError(error.message);
  //         throw error;
  //       }
  //     };

  //     // Make the booking request
  //     const bookingResult = await makeBookingRequest();

  //     // ✅ REMOVED: All the duplicate response checking code that was causing the error

  //     console.log("✅ Booking confirmed", bookingResult);

  //     // Extract the booking ID correctly
  //     const bookingId =
  //       bookingResult.bookingId || bookingResult.id || bookingResult._id;

  //     // Reset form
  //     setSelectedServices([]);
  //     setSelectedBarber(null);
  //     setSelectedDate("");
  //     setSelectedSlot("");

  //     // Redirect to booking confirmation page
  //     router.push(`/booking/confirmed?id=${bookingId}`);
  //   } catch (error) {
  //     console.error("❌ Booking error:", error);
  //     alert("Booking failed: " + error.message);
  //   }
  // };

  const handleBooking = async () => {
    // ✅ Basic service validation (required for both modes)
    if (selectedServices.length === 0) {
      alert("Please select at least one service");
      return;
    }

    // ✅ Pre-book mode: require date & time
    if (bookingMode === "prebook" && (!selectedDate || !selectedSlot)) {
      alert("Please select date and time");
      return;
    }

    // ✅ Walk-in mode: NO date/time needed, just barber selection
    if (!selectedBarber) {
      alert("Please select a barber");
      return;
    }

    try {
      console.log(
        "📌 Booking with:",
        selectedServices,
        selectedSlot,
        selectedBarber,
        userInfo
      );

      // Find selected barber details if one is selected
      const selectedBarberDetails = selectedBarber
        ? availableBarbers.find((b) => b._id === selectedBarber)
        : null;

      // Prepare booking data
      const allServices = selectedServices
        .map((service) => service.name)
        .join(", ");

      const totalPrice = selectedServices.reduce(
        (sum, service) => sum + service.price,
        0
      );

      // ✅ GET userToken FIRST
      const currentUserInfo = UserDataManager.getStoredUserData();
      const userToken = localStorage.getItem("userToken");

      // ✅ BRANCH: Different logic based on booking mode
      if (bookingMode === "walkin") {
        // ========== WALK-IN BOOKING ==========
        // ========== WALK-IN BOOKING ==========
        const walkinPayload = {
          salonId: salon?._id || id,
          barberId: selectedBarber,
          service: allServices,
          customerName: currentUserInfo?.name || "Guest",
          customerPhone:
            currentUserInfo?.phone || currentUserInfo?.mobile || "",
          customerEmail: currentUserInfo?.email || "",
          userId: currentUserInfo?._id || currentUserInfo?.id || null,
          estimatedDuration: selectedServices[0]?.duration || 45,
        };

        console.log("✅ Walk-in Booking payload:", walkinPayload);

        const walkinResponse = await fetch("/api/walkin/create-booking", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(walkinPayload),
        });

        if (!walkinResponse.ok) {
          const errorData = await walkinResponse.json();
          throw new Error(errorData.message || "Walk-in booking failed");
        }

        const walkinResult = await walkinResponse.json();
        console.log("✅ Walk-in booking confirmed:", walkinResult);

        // Reset form
        setSelectedServices([]);
        setSelectedBarber(null);

        // Redirect to walk-in confirmation with QR code
        router.push(
          `/walkin/confirmation?bookingId=${walkinResult.booking.bookingId}`
        );
      } else {
        // ========== PRE-BOOK BOOKING (EXISTING) ==========
        const prebookPayload = {
          salonId: salon?._id || id,
          service: allServices,
          barber: selectedBarberDetails?.name || "Any Available",
          barberId: selectedBarber || null,
          date: selectedDate,
          time: selectedSlot,
          price: totalPrice,
          customerName: currentUserInfo?.name || "Guest",
          customerPhone:
            currentUserInfo?.phone || currentUserInfo?.mobile || "",
          customerAge: currentUserInfo?.age || null,
          user: currentUserInfo,
          userId: currentUserInfo?._id || currentUserInfo?.id || null,
        };

        console.log("✅ Pre-book Booking payload:", prebookPayload);

        const makeBookingRequest = async () => {
          try {
            setBookingError(null);
            const response = await fetch("/api/bookings/create", {
              method: "POST",
              headers: {
                "Content-Type": "application/json",
                ...(userToken && { Authorization: `Bearer ${userToken}` }),
              },
              body: JSON.stringify(prebookPayload),
            });

            // Handle 409 conflict
            if (response.status === 409) {
              const errorData = await response.json();
              alert(
                "Sorry! This time slot was just booked by another customer. Please select a different time."
              );
              window.location.reload();
              throw new Error("Slot already booked");
            }

            if (!response.ok) {
              const errorData = await response.json();
              throw new Error(errorData.error || "Booking failed");
            }

            const bookingResult = await response.json();
            return bookingResult;
          } catch (error) {
            setBookingError(error.message);
            throw error;
          }
        };

        // Make the booking request
        const bookingResult = await makeBookingRequest();

        console.log("✅ Pre-book Booking confirmed:", bookingResult);

        // Extract the booking ID correctly
        const bookingId =
          bookingResult.bookingId || bookingResult._id || bookingResult.id;

        // Reset form
        setSelectedServices([]);
        setSelectedBarber(null);
        setSelectedDate("");
        setSelectedSlot("");

        // Redirect to booking confirmation page
        router.push(`/booking/confirmed?id=${bookingId}`);
      }
    } catch (error) {
      console.error("❌ Booking error:", error);
      alert(`Booking failed: ${error.message}`);
    }
  };

  const handleRegisterAndLink = async () => {
    // call registration API
    if (!regName || !regMobile) return alert("Please enter name and mobile");
    try {
      const res = await fetch("/api/users/register", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          name: regName,
          mobile: regMobile,
          email: regEmail,
        }),
      });
      const data = await res.json();
      if (!res.ok) {
        setIsBooking(false);
        return alert(
          "Registration failed: " + (data.message || res.statusText)
        );
      }
      // set onboarding and close modal
      setUserOnboarding({ name: regName, mobile: regMobile, email: regEmail });
      setShowRegistrationModal(false);
      alert("Account created! You are now registered.");
    } catch (e) {
      console.error(e);
      alert("Registration failed: " + e.message);
    }
  };

  const sendOtpForRegistration = async (mobile) => {
    try {
      const res = await fetch("/api/auth/send-otp", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ mobile }),
      });
      const data = await res.json();
      if (res.ok) {
        setOtpSent(true);
        setOtpMobile(mobile);
        // For dev we get OTP in response; in prod SMS is sent.
        setOtpCode(data.otp || "");
        alert("OTP sent (dev): " + (data.otp || "---"));
      } else {
        alert("OTP send failed: " + (data.message || res.statusText));
      }
    } catch (e) {
      console.error(e);
      alert("OTP send failed");
    }
  };

  const verifyOtpAndRegister = async (mobile, otp) => {
    try {
      const res = await fetch("/api/auth/verify-otp", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ mobile, otp }),
      });
      const data = await res.json();
      if (!res.ok)
        return alert("OTP verify failed: " + (data.message || res.statusText));
      // if user present, set onboarding; else open registration form
      if (data.user) {
        setUserOnboarding({
          name: data.user.name,
          mobile: data.user.mobile,
          email: data.user.email,
        });
        alert("Verified and signed in");
        setShowRegistrationModal(false);
      } else {
        // No existing user: fill registration modal fields
        setRegName(regName || "");
        setRegMobile(mobile);
        setShowRegistrationModal(true);
      }
      setOtpSent(false);
      setOtpCode("");
    } catch (e) {
      console.error(e);
      alert("OTP verify failed");
    }
  };

  return (
    <div className={styles.container}>
      {bookingError && (
        <div className="bg-red-50 border border-red-200 rounded-lg p-4 mt-4">
          <p className="text-red-700 text-sm mb-2">❌ {bookingError}</p>
          <RetryButton onRetry={makeBookingRequest} />
        </div>
      )}
      {/* Header */}
      <header className={styles.header}>
        <button onClick={() => router.back()} className={styles.backButton}>
          ← Back
        </button>
        <h1 className={styles.salonName}>{salon.salonName}</h1>
        <div className={styles.headerActions}>
          <button className={styles.shareButton}>📤</button>
          <button className={styles.favoriteButton}>❤️</button>
        </div>
      </header>

      {/* ✅ NEW: Mode Toggle */}
      <div className={styles.modeToggle}>
        <button
          className={`${styles.modeButton} ${
            bookingMode === "prebook" ? styles.active : ""
          }`}
          onClick={() => setBookingMode("prebook")}
        >
          📅 Pre-book
        </button>
        <button
          className={`${styles.modeButton} ${
            bookingMode === "walkin" ? styles.active : ""
          }`}
          onClick={() => setBookingMode("walkin")}
        >
          ⚡ Walk-in
        </button>
      </div>

      {/* Hero Section */}
      <motion.section
        className={styles.heroSection}
        initial={{ opacity: 0 }}
        animate={{ opacity: 1 }}
        transition={{ duration: 0.8 }}
      >
        <div className={styles.imageGallery}>
          {salon.salonImages && salon.salonImages.length > 0 ? (
            <Image
              src={salon.salonImages[0]}
              alt={salon.salonName}
              className={styles.mainImage}
            />
          ) : (
            <div className={styles.placeholderImage}>
              <span>📸</span>
              <p>No images available</p>
            </div>
          )}
        </div>

        <div className={styles.salonBasicInfo}>
          <div className={styles.ratingSection}>
            <div className={styles.mainRating}>
              ⭐ {salon.ratings.overall.toFixed(1)}
            </div>
            <div className={styles.reviewCount}>
              ({salon.ratings.totalReviews} reviews)
            </div>
          </div>

          <div className={styles.locationInfo}>
            <p>📍 {salon.location.address}</p>
            <p>📞 {salon.phone}</p>
          </div>

          <div className={styles.quickStats}>
            <div className={styles.stat}>
              <span className={styles.statNumber}>
                {salon.stats.totalBookings}
              </span>
              <span className={styles.statLabel}>Total Bookings</span>
            </div>
            <div className={styles.stat}>
              <span className={styles.statNumber}>
                {salon.stats.averageWaitTime}min
              </span>
              <span className={styles.statLabel}>Avg Wait Time</span>
            </div>
            <div className={styles.stat}>
              <span className={styles.statNumber}>
                {salon.stats.repeatCustomers}
              </span>
              <span className={styles.statLabel}>Repeat Customers</span>
            </div>
          </div>
        </div>
      </motion.section>
      <ReviewsSection salonId={salon._id} />

      {/* Services Section */}
      <motion.section
        className={styles.servicesSection}
        initial={{ opacity: 0, y: 30 }}
        animate={{ opacity: 1, y: 0 }}
        transition={{ duration: 0.8, delay: 0.2 }}
      >
        <h3 className={styles.sectionTitle}>Services & Pricing</h3>
        <div className={styles.servicesGrid}>
          {getFilteredServices().map((service, index) => (
            <motion.div
              key={index}
              className={`${styles.serviceCard} ${
                selectedServices.find((s) => s.name === service.name)
                  ? styles.selected
                  : ""
              }`}
              onClick={() => {
                console.log("Service clicked:", service.name);
                handleServiceClick(service);
                console.log("Current selectedServices:", service);
              }}
              whileHover={{ scale: 1.02 }}
              whileTap={{ scale: 0.98 }}
            >
              <h4 className={styles.serviceName}>{service.name}</h4>
              <p className={styles.servicePrice}>₹{service.price}</p>
              <p className={styles.serviceDuration}>{service.duration} min</p>
              <p className={styles.serviceGender}>
                {service.gender.join(", ")}
              </p>
            </motion.div>
          ))}
        </div>
      </motion.section>

      {/* Barber Selection Section */}

      {selectedServices.length > 0 && (
        <motion.section
          className={styles.barbersSection}
          initial={{ opacity: 0, y: 30 }}
          animate={{ opacity: 1, y: 0 }}
          transition={{ duration: 0.8, delay: 0.4 }}
        >
          <h3 className={styles.sectionTitle}>Choose Your Barber</h3>

          {availableBarbers.length > 0 ? (
            <div className={styles.barbersGrid}>
              {availableBarbers.map((barber) => {
                // ✅ Find real-time state for walk-in mode
                const barberState =
                  bookingMode === "walkin"
                    ? barberStates.find(
                        (b) => b.barberId === barber._id.toString()
                      )
                    : null;

                return (
                  <motion.div
                    key={barber._id}
                    className={`${styles.barberCard} ${
                      selectedBarber === barber._id ? styles.selected : ""
                    }`}
                    onClick={() => setSelectedBarber(barber._id)}
                    whileHover={{ scale: 1.03 }}
                    whileTap={{ scale: 0.98 }}
                  >
                    {/* ✅ Walk-in Mode: Show real-time status badge */}
                    {bookingMode === "walkin" && barberState && (
                      <div className={styles.walkInStatusBadge}>
                        {barberState.status === "AVAILABLE" && (
                          <span className={styles.availableNow}>
                            ✅ Available Now
                          </span>
                        )}
                        {barberState.status === "OCCUPIED" && (
                          <span className={styles.occupiedNow}>
                            🟢 Busy ({barberState.timeLeft}m left)
                          </span>
                        )}
                        {barberState.queueCount > 0 && (
                          <span className={styles.queueBadge}>
                            {barberState.queueCount} in queue
                          </span>
                        )}
                      </div>
                    )}

                    {/* Barber Photo */}
                    <div className={styles.barberPhoto}>
                      <img
                        src={barber.photo || "/default-barber.png"}
                        alt={barber.name}
                        className={styles.barberImage}
                      />
                    </div>

                    {/* Barber Info */}
                    <h4 className={styles.barberName}>{barber.name}</h4>
                    <p className={styles.barberExperience}>
                      {barber.experience} years experience
                    </p>

                    {/* Rating */}
                    {barber.rating && (
                      <p className={styles.barberRating}>
                        ⭐ {barber.rating}/5
                      </p>
                    )}

                    {/* Skills */}
                    {barber.skills && barber.skills.length > 0 && (
                      <div className={styles.barberSkills}>
                        {barber.skills.slice(0, 3).map((skill, idx) => (
                          <span key={idx} className={styles.skillChip}>
                            {skill}
                          </span>
                        ))}
                      </div>
                    )}

                    {/* ✅ Walk-in: Show wait time estimate at bottom */}
                    {bookingMode === "walkin" && barberState && (
                      <div className={styles.waitEstimate}>
                        {barberState.status === "AVAILABLE" ? (
                          <span className={styles.noWait}>No Wait</span>
                        ) : (
                          <span className={styles.waitTime}>
                            ~
                            {barberState.timeLeft + barberState.queueCount * 45}{" "}
                            mins
                          </span>
                        )}
                      </div>
                    )}
                  </motion.div>
                );
              })}
            </div>
          ) : (
            <div className="text-center py-8 bg-blue-50 rounded-lg">
              <h4 className="text-lg font-semibold text-blue-800 mb-2">
                Salon Will Assign Best Available Barber
              </h4>
              <p className="text-blue-600">
                No specialized barbers are currently available for the selected
                services, but the salon will assign the best available barber
                for your appointment.
              </p>
            </div>
          )}
        </motion.section>
      )}
      {/* ✅ Walk-in Mode: Real-Time Status Dashboard */}
      {/* ✅ Walk-in Mode: Real-Time Status Dashboard */}
      {bookingMode === "walkin" && (
        <motion.section
          className={styles.realTimeStatus}
          initial={{ opacity: 0, y: 20 }}
          animate={{ opacity: 1, y: 0 }}
        >
          <h3 className={styles.statusTitle}>📊 Live Salon Status</h3>

          <div className={styles.statusGrid}>
            <div className={styles.statusCard}>
              <div className={styles.statusIcon}>🟢</div>
              <div className={styles.statusValue}>
                {salonStats.totalServing}
              </div>
              <div className={styles.statusLabel}>Serving Now</div>
              {barberStates
                .filter((b) => b.status === "OCCUPIED")
                .map((b) => (
                  <div key={b.barberId} className={styles.miniInfo}>
                    {b.name}: {b.timeLeft}m
                  </div>
                ))}
            </div>

            <div className={styles.statusCard}>
              <div className={styles.statusIcon}>🟠</div>
              <div className={styles.statusValue}>
                {salonStats.totalWaiting}
              </div>
              <div className={styles.statusLabel}>In Queue</div>
            </div>

            <div className={styles.statusCard}>
              <div className={styles.statusIcon}>🔴</div>
              <div className={styles.statusValue}>{salonStats.totalBooked}</div>
              <div className={styles.statusLabel}>Booked (Not Arrived)</div>
            </div>

            <div className={styles.statusCard}>
              <div className={styles.statusIcon}>⏱️</div>
              <div className={styles.statusValue}>
                ~{salonStats.avgWaitTime} min
              </div>
              <div className={styles.statusLabel}>Avg Wait</div>
            </div>
          </div>

          {/* Chair Visualization */}
          <div className={styles.chairsSection}>
            <h4 className={styles.chairsTitle}>💈 Barber Chairs</h4>
            <div className={styles.chairsGrid}>
              {barberStates.map((barber, index) => (
                <div key={barber.barberId} className={styles.chairItem}>
                  <div
                    className={`${styles.chair} ${
                      barber.status === "AVAILABLE"
                        ? styles.available
                        : barber.status === "OCCUPIED"
                        ? styles.occupied
                        : styles.available
                    }`}
                  >
                    <div className={styles.chairIcon}>💺</div>
                    <div
                      className={`${styles.chairStatus} ${
                        barber.status === "AVAILABLE"
                          ? styles.green
                          : barber.status === "OCCUPIED"
                          ? styles.orange
                          : styles.green
                      }`}
                    >
                      ●
                    </div>
                  </div>
                  <p className={styles.chairLabel}>
                    Chair #{barber.chairNumber || index + 1}
                  </p>
                  <p className={styles.chairBarber}>{barber.name}</p>

                  {barber.status === "AVAILABLE" ? (
                    <span className={styles.chairBadge}>Available</span>
                  ) : (
                    <div className={styles.chairBusy}>
                      <span className={styles.chairBadgeOccupied}>
                        In Service
                      </span>
                      <p className={styles.chairCustomer}>
                        {barber.currentCustomer}
                      </p>
                      <p className={styles.chairTime}>
                        ~{barber.timeLeft}m left
                      </p>
                      {barber.queueCount > 0 && (
                        <p className={styles.chairQueue}>
                          {barber.queueCount} waiting
                        </p>
                      )}
                    </div>
                  )}
                </div>
              ))}
            </div>
          </div>

          {/* Legend */}
          <div className={styles.statusLegend}>
            <div className={styles.legendItem}>
              <span className={`${styles.legendDot} ${styles.green}`}>●</span>
              <span>Available</span>
            </div>
            <div className={styles.legendItem}>
              <span className={`${styles.legendDot} ${styles.orange}`}>●</span>
              <span>In Service</span>
            </div>
            <div className={styles.legendItem}>
              <span className={`${styles.legendDot} ${styles.red}`}>●</span>
              <span>Booked</span>
            </div>
          </div>
        </motion.section>
      )}
      {selectedServices.length > 0 && availableBarbers.length === 0 && (
        <motion.section
          className={styles.noBarbersSection}
          initial={{ opacity: 0, y: 30 }}
          animate={{ opacity: 1, y: 0 }}
          transition={{ duration: 0.8, delay: 0.4 }}
        >
          <div className="text-center py-8 bg-yellow-50 rounded-lg">
            <h3 className="text-lg font-semibold text-yellow-800 mb-2">
              No Specialized Barbers Available
            </h3>
            <p className="text-yellow-600">
              Sorry, no barbers are currently available for the selected
              services. Please try different services or contact the salon
              directly.
            </p>
          </div>
        </motion.section>
      )}

      {/* Date & Time Selection - Only for Pre-book Mode */}
      {bookingMode === "prebook" && (
        <motion.section
          className={styles.bookingSection}
          initial={{ opacity: 0, y: 30 }}
          animate={{ opacity: 1, y: 0 }}
          transition={{ duration: 0.8, delay: 0.6 }}
        >
          <h3 className={styles.sectionTitle}>Select Date & Time</h3>
          <div className={styles.dateTimePicker}>
            <input
              type="date"
              value={selectedDate}
              onChange={(e) => setSelectedDate(e.target.value)}
              className={styles.dateInput}
            />
            <div className={styles.timeSlots}>
              {selectedDate ? (
                timeSlots.length === 0 ? (
                  <div>No slots available for selected date</div>
                ) : (
                  <div className={styles.timeSlotsWrapper}>
                    {timeSlots.map((slot, idx) => (
                      <button
                        key={idx}
                        className={`${styles.timeSlot} ${
                          selectedSlot === slot.time ? styles.selected : ""
                        } ${!slot.available ? styles.disabled : ""}`}
                        onClick={() => {
                          console.log("Slot clicked:", slot.time);
                          handleTimeClick(slot.time);
                          console.log("Current selectedSlot:", slot.time);
                        }}
                        disabled={!slot.available} // ✅ ensure unavailable slots can’t be clicked
                      >
                        {slot.time}
                      </button>
                    ))}
                  </div>
                )
              ) : (
                <p>Please select a date</p>
              )}
            </div>
          </div>
        </motion.section>
      )}

      {/* Map Section */}
      {salon.location.latitude && salon.location.longitude && (
        <motion.section
          className={styles.mapSection}
          initial={{ opacity: 0, y: 30 }}
          animate={{ opacity: 1, y: 0 }}
          transition={{ duration: 0.8, delay: 0.8 }}
        >
          <h3 className={styles.sectionTitle}>Location</h3>
          <MapContainer
            center={[salon.location.latitude, salon.location.longitude]}
            zoom={15}
            style={{ height: "300px", width: "100%" }}
          >
            <TileLayer
              url="https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png"
              attribution="&copy; OpenStreetMap contributors"
            />
            <Marker
              position={[salon.location.latitude, salon.location.longitude]}
            />
          </MapContainer>
        </motion.section>
      )}

      {/* Book Appointment Button */}
      <div className={styles.bookButtonContainer}>
        <button
          onClick={handleBooking}
          disabled={
            selectedServices.length === 0 ||
            !selectedBarber ||
            (bookingMode === "prebook" && !selectedSlot)
          }
          className={`${styles.bookButton} ${
            selectedServices.length === 0 ||
            !selectedBarber ||
            (bookingMode === "prebook" && !selectedSlot)
              ? styles.disabled
              : ""
          }`}
        >
          {bookingMode === "walkin" ? "Book Walk-in Now" : "Book Appointment"}
          Book Appointment
          {availableBarbers.length === 0 && selectedServices.length > 0 && (
            <small className={styles.buttonSubtext}>
              (Salon will assign barber)
            </small>
          )}
        </button>
      </div>

      {/* Booking Modal */}
      {/* Registration Modal - shown after booking if user not onboarded */}
      {showRegistrationModal && (
        <div className={styles.modalOverlay}>
          <div className={styles.modalContent}>
            <h3>Create your account</h3>
            <p>
              We prefilled your booking info — just confirm to create an
              account.
            </p>
            <input
              placeholder="Name"
              value={regName}
              onChange={(e) => setRegName(e.target.value)}
            />
            <input
              placeholder="Mobile"
              value={regMobile}
              onChange={(e) => setRegMobile(e.target.value)}
            />
            <input
              placeholder="Email (optional)"
              value={regEmail}
              onChange={(e) => setRegEmail(e.target.value)}
            />
            <div style={{ marginTop: "12px" }}>
              <button
                className={styles.confirmButton}
                onClick={handleRegisterAndLink}
              >
                Create Account
              </button>
              <button
                className={styles.cancelButton}
                onClick={() => setShowRegistrationModal(false)}
              >
                Skip
              </button>
            </div>
          </div>
        </div>
      )}

      {showBookingModal && (
        <div className={styles.modalOverlay}>
          <div className={styles.modalContent}>
            <h3>Confirm Your Booking</h3>
            <p>
              <strong>Service:</strong> {chosenService?.name}
            </p>
            <p>
              <strong>Barber:</strong> {chosenBarber?.name}
            </p>
            <p>
              <strong>Date:</strong> {selectedDate}
            </p>
            <p>
              <strong>Time:</strong> {selectedSlot}
            </p>
            <div className={styles.modalActions}>
              <button
                className={styles.confirmButton}
                onClick={async () => {
                  setIsBooking(true);
                  // build payload
                  const payload = {
                    salonId: id,
                    service: chosenService
                      ? chosenService.name
                      : selectedServices,
                    barber: chosenBarber
                      ? chosenBarber._id || chosenBarber.name
                      : selectedBarber,
                    date: selectedDate,
                    time: selectedSlot,
                    user: {
                      ...(userOnboarding || {}),
                      phoneNumber:
                        userOnboarding?.phoneNumber ||
                        userOnboarding?.phone ||
                        userOnboarding?.mobile ||
                        "",
                      age: userOnboarding?.age || null,
                    },
                  };
                  try {
                    const res = await fetch("/api/bookings", {
                      method: "POST",
                      headers: { "Content-Type": "application/json" },
                      body: JSON.stringify(payload),
                    });
                    if (!res.ok) {
                      setIsBooking(false);
                      const err = await res
                        .json()
                        .catch(() => ({ message: "Unknown error" }));
                      alert(
                        "Booking failed: " + (err.message || res.statusText)
                      );
                      return;
                    }
                    const data = await res.json();
                    alert(
                      "Booking confirmed! Booking ID: " +
                        (data.bookingId || data.id || "N/A")
                    );
                    if (!userOnboarding) {
                      setRegName(payload.user?.name || "");
                      setRegMobile(payload.user?.mobile || "");
                      setShowRegistrationModal(true);
                    }
                    setShowBookingModal(false);
                    setIsBooking(false);
                    // lock selected slot locally
                    setTimeSlots((prev) =>
                      prev.map((s) =>
                        s.time === selectedSlot ? { ...s, available: false } : s
                      )
                    );
                    // optionally navigate to confirmation page
                    router.push(
                      "user/bookings/confirmed?id=" +
                        (data.bookingId || data.id)
                    );
                  } catch (e) {
                    console.error(e);
                    alert("Booking failed: " + e.message);
                  }
                }}
              >
                Confirm
              </button>
              <button
                className={styles.cancelButton}
                onClick={() => setShowBookingModal(false)}
              >
                Cancel
              </button>
            </div>
          </div>
        </div>
      )}
    </div>
  );
}
export async function getServerSideProps(context) {
  const { id } = context.params;

  try {
    const baseUrl = process.env.NEXT_PUBLIC_BASE_URL || "http://localhost:3000";
    const response = await fetch(`${baseUrl}/api/salons/${id}`);
    const data = await response.json();

    if (!response.ok) {
      return { notFound: true };
    }

    return {
      props: {
        initialSalon: data.salon,
      },
    };
  } catch (error) {
    console.error("SSR fetch error:", error);
    return { notFound: true };
  }
}
</file>

</files>
